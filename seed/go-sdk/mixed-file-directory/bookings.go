// This file was auto-generated by Fern from our API Definition.

package api

import (
	json "encoding/json"
	fmt "fmt"
	core "github.com/mixed-file-directory/fern/core"
)

type SearchAvailabilityRequest struct {
	// Query conditions used to filter buyer-accessible booking availabilities.
	Query *SearchAvailabilityQuery `json:"query,omitempty" url:"-"`
}

type CancelBookingRequest struct {
	// A unique key to make this request an idempotent operation.
	IdempotencyKey *string `json:"idempotency_key,omitempty" url:"-"`
	// The revision number for the booking used for optimistic concurrency.
	BookingVersion *int `json:"booking_version,omitempty" url:"-"`
}

type CreateBookingRequest struct {
	// A unique key to make this request an idempotent operation.
	IdempotencyKey *string `json:"idempotency_key,omitempty" url:"-"`
	// The details of the booking to be created.
	Booking *Booking `json:"booking,omitempty" url:"-"`
}

type BookingsListRequest struct {
	// The maximum number of results per page to return in a paged response.
	Limit *int `json:"-" url:"limit,omitempty"`
	// The pagination cursor from the preceding response to return the next page of the results. Do not set this when retrieving the first page of the results.
	Cursor *string `json:"-" url:"cursor,omitempty"`
	// The team member for whom to retrieve bookings. If this is not set, bookings of all members are retrieved.
	TeamMemberId *string `json:"-" url:"team_member_id,omitempty"`
	// The location for which to retrieve bookings. If this is not set, all locations' bookings are retrieved.
	LocationId *string `json:"-" url:"location_id,omitempty"`
	// The RFC 3339 timestamp specifying the earliest of the start time. If this is not set, the current time is used.
	StartAtMin *string `json:"-" url:"start_at_min,omitempty"`
	// The RFC 3339 timestamp specifying the latest of the start time. If this is not set, the time of 31 days after `start_at_min` is used.
	StartAtMax *string `json:"-" url:"start_at_max,omitempty"`
}

// Represents a booking as a time-bound service contract for a seller's staff member to provide a specified service
// at a given location to a requesting customer in one or more appointment segments.
type Booking struct {
	// A unique ID of this object representing a booking.
	Id *string `json:"id,omitempty" url:"id,omitempty"`
	// The revision number for the booking used for optimistic concurrency.
	Version *int `json:"version,omitempty" url:"version,omitempty"`
	// The status of the booking, describing where the booking stands with respect to the booking state machine.
	// See [BookingStatus](#type-bookingstatus) for possible values
	Status *BookingStatus `json:"status,omitempty" url:"status,omitempty"`
	// The RFC 3339 timestamp specifying the creation time of this booking.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The RFC 3339 timestamp specifying the most recent update time of this booking.
	UpdatedAt *string `json:"updated_at,omitempty" url:"updated_at,omitempty"`
	// The RFC 3339 timestamp specifying the starting time of this booking.
	StartAt *string `json:"start_at,omitempty" url:"start_at,omitempty"`
	// The ID of the [Location](entity:Location) object representing the location where the booked service is provided. Once set when the booking is created, its value cannot be changed.
	LocationId *string `json:"location_id,omitempty" url:"location_id,omitempty"`
	// The ID of the [Customer](entity:Customer) object representing the customer receiving the booked service.
	CustomerId *string `json:"customer_id,omitempty" url:"customer_id,omitempty"`
	// The free-text field for the customer to supply notes about the booking. For example, the note can be preferences that cannot be expressed by supported attributes of a relevant [CatalogObject](entity:CatalogObject) instance.
	CustomerNote *string `json:"customer_note,omitempty" url:"customer_note,omitempty"`
	// The free-text field for the seller to supply notes about the booking. For example, the note can be preferences that cannot be expressed by supported attributes of a specific [CatalogObject](entity:CatalogObject) instance.
	// This field should not be visible to customers.
	SellerNote *string `json:"seller_note,omitempty" url:"seller_note,omitempty"`
	// A list of appointment segments for this booking.
	AppointmentSegments []*AppointmentSegment `json:"appointment_segments,omitempty" url:"appointment_segments,omitempty"`
	// Additional time at the end of a booking.
	// Applications should not make this field visible to customers of a seller.
	TransitionTimeMinutes *int `json:"transition_time_minutes,omitempty" url:"transition_time_minutes,omitempty"`
	// Whether the booking is of a full business day.
	AllDay *bool `json:"all_day,omitempty" url:"all_day,omitempty"`
	// The type of location where the booking is held.
	// Access to this field requires seller-level permissions.
	// See [BusinessAppointmentSettingsBookingLocationType](#type-businessappointmentsettingsbookinglocationtype) for possible values
	LocationType *BusinessAppointmentSettingsBookingLocationType `json:"location_type,omitempty" url:"location_type,omitempty"`
	// Information about the booking creator.
	CreatorDetails *BookingCreatorDetails `json:"creator_details,omitempty" url:"creator_details,omitempty"`
	// The source of the booking.
	// Access to this field requires seller-level permissions.
	// See [BookingBookingSource](#type-bookingbookingsource) for possible values
	Source *BookingBookingSource `json:"source,omitempty" url:"source,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (b *Booking) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *Booking) UnmarshalJSON(data []byte) error {
	type unmarshaler Booking
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = Booking(value)

	extraProperties, err := core.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties

	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *Booking) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type CancelBookingResponse struct {
	// The booking that was cancelled.
	Booking *Booking `json:"booking,omitempty" url:"booking,omitempty"`
	// Errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CancelBookingResponse) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CancelBookingResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler CancelBookingResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CancelBookingResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CancelBookingResponse) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreateBookingResponse struct {
	// The booking that was created.
	Booking *Booking `json:"booking,omitempty" url:"booking,omitempty"`
	// Errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CreateBookingResponse) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateBookingResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler CreateBookingResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CreateBookingResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateBookingResponse) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type GetBookingResponse struct {
	// The booking that was requested.
	Booking *Booking `json:"booking,omitempty" url:"booking,omitempty"`
	// Errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GetBookingResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetBookingResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetBookingResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetBookingResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetBookingResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetBusinessBookingProfileResponse struct {
	// The seller's booking profile.
	BusinessBookingProfile *BusinessBookingProfile `json:"business_booking_profile,omitempty" url:"business_booking_profile,omitempty"`
	// Errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GetBusinessBookingProfileResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetBusinessBookingProfileResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetBusinessBookingProfileResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetBusinessBookingProfileResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetBusinessBookingProfileResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type ListBookingsResponse struct {
	// The list of targeted bookings.
	Bookings []*Booking `json:"bookings,omitempty" url:"bookings,omitempty"`
	// The pagination cursor to be used in the subsequent request to get the next page of the results. Stop retrieving the next page of the results when the cursor is not set.
	Cursor *string `json:"cursor,omitempty" url:"cursor,omitempty"`
	// Errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *ListBookingsResponse) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *ListBookingsResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ListBookingsResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListBookingsResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListBookingsResponse) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// The query used to search for buyer-accessible availabilities of bookings.
type SearchAvailabilityQuery struct {
	// The query filter to search for buyer-accessible availabilities of existing bookings.
	Filter *SearchAvailabilityFilter `json:"filter,omitempty" url:"filter,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *SearchAvailabilityQuery) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SearchAvailabilityQuery) UnmarshalJSON(data []byte) error {
	type unmarshaler SearchAvailabilityQuery
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SearchAvailabilityQuery(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SearchAvailabilityQuery) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SearchAvailabilityResponse struct {
	// List of appointment slots available for booking.
	Availabilities []*Availability `json:"availabilities,omitempty" url:"availabilities,omitempty"`
	// Errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *SearchAvailabilityResponse) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SearchAvailabilityResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler SearchAvailabilityResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SearchAvailabilityResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SearchAvailabilityResponse) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type UpdateBookingResponse struct {
	// The booking that was updated.
	Booking *Booking `json:"booking,omitempty" url:"booking,omitempty"`
	// Errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (u *UpdateBookingResponse) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdateBookingResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler UpdateBookingResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpdateBookingResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties

	u._rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateBookingResponse) String() string {
	if len(u._rawJSON) > 0 {
		if value, err := core.StringifyJSON(u._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UpdateBookingRequest struct {
	// A unique key to make this request an idempotent operation.
	IdempotencyKey *string `json:"idempotency_key,omitempty" url:"-"`
	// The booking to be updated. Individual attributes explicitly specified here override the corresponding values of the existing booking.
	Booking *Booking `json:"booking,omitempty" url:"-"`
}
