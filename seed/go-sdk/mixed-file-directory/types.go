// This file was auto-generated by Fern from our API Definition.

package api

import (
	json "encoding/json"
	fmt "fmt"
	core "github.com/mixed-file-directory/fern/core"
)

// Defines the request parameters for the `AcceptDispute` endpoint.
type AcceptDisputeRequest struct {
	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (a *AcceptDisputeRequest) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AcceptDisputeRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler AcceptDisputeRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AcceptDisputeRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *AcceptDisputeRequest) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type AcceptedPaymentMethods struct {
	// Whether Apple Pay is accepted at checkout.
	ApplePay *bool `json:"apple_pay,omitempty" url:"apple_pay,omitempty"`
	// Whether Google Pay is accepted at checkout.
	GooglePay *bool `json:"google_pay,omitempty" url:"google_pay,omitempty"`
	// Whether Cash App Pay is accepted at checkout.
	CashAppPay *bool `json:"cash_app_pay,omitempty" url:"cash_app_pay,omitempty"`
	// Whether Afterpay/Clearpay is accepted at checkout.
	AfterpayClearpay *bool `json:"afterpay_clearpay,omitempty" url:"afterpay_clearpay,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (a *AcceptedPaymentMethods) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AcceptedPaymentMethods) UnmarshalJSON(data []byte) error {
	type unmarshaler AcceptedPaymentMethods
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AcceptedPaymentMethods(value)

	extraProperties, err := core.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *AcceptedPaymentMethods) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// Represents an [AccumulateLoyaltyPoints](api-endpoint:Loyalty-AccumulateLoyaltyPoints) response.
type AccumulateLoyaltyPointsResponse struct {
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The resulting loyalty event.
	Event *LoyaltyEvent `json:"event,omitempty" url:"event,omitempty"`
	// The resulting loyalty events. The `ACCUMULATE_POINTS` event is always included.
	// When using the Orders API, the `ACCUMULATE_PROMOTION_POINTS` event is included
	// if the purchase also qualifies for a loyalty promotion.
	Events []*LoyaltyEvent `json:"events,omitempty" url:"events,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (a *AccumulateLoyaltyPointsResponse) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AccumulateLoyaltyPointsResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler AccumulateLoyaltyPointsResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AccumulateLoyaltyPointsResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *AccumulateLoyaltyPointsResponse) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// ACH-specific details about `BANK_ACCOUNT` type payments with the `transfer_type` of `ACH`.
type AchDetails struct {
	// The routing number for the bank account.
	RoutingNumber *string `json:"routing_number,omitempty" url:"routing_number,omitempty"`
	// The last few digits of the bank account number.
	AccountNumberSuffix *string `json:"account_number_suffix,omitempty" url:"account_number_suffix,omitempty"`
	// The type of the bank account performing the transfer. The account type can be `CHECKING`,
	// `SAVINGS`, or `UNKNOWN`.
	AccountType *string `json:"account_type,omitempty" url:"account_type,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (a *AchDetails) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AchDetails) UnmarshalJSON(data []byte) error {
	type unmarshaler AchDetails
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AchDetails(value)

	extraProperties, err := core.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *AchDetails) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type ActionCancelReason string

const (
	ActionCancelReasonActionCancelReasonDoNotUse ActionCancelReason = "ACTION_CANCEL_REASON_DO_NOT_USE"
	ActionCancelReasonBuyerCanceled              ActionCancelReason = "BUYER_CANCELED"
	ActionCancelReasonSellerCanceled             ActionCancelReason = "SELLER_CANCELED"
	ActionCancelReasonTimedOut                   ActionCancelReason = "TIMED_OUT"
	ActionCancelReasonUnsupported                ActionCancelReason = "UNSUPPORTED"
)

func NewActionCancelReasonFromString(s string) (ActionCancelReason, error) {
	switch s {
	case "ACTION_CANCEL_REASON_DO_NOT_USE":
		return ActionCancelReasonActionCancelReasonDoNotUse, nil
	case "BUYER_CANCELED":
		return ActionCancelReasonBuyerCanceled, nil
	case "SELLER_CANCELED":
		return ActionCancelReasonSellerCanceled, nil
	case "TIMED_OUT":
		return ActionCancelReasonTimedOut, nil
	case "UNSUPPORTED":
		return ActionCancelReasonUnsupported, nil
	}
	var t ActionCancelReason
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a ActionCancelReason) Ptr() *ActionCancelReason {
	return &a
}

type ActivityType string

const (
	ActivityTypeUnknownPayoutEntryTypeDoNotUse ActivityType = "UNKNOWN_PAYOUT_ENTRY_TYPE_DO_NOT_USE"
	ActivityTypeAdjustment                     ActivityType = "ADJUSTMENT"
	ActivityTypeAppFeeRefund                   ActivityType = "APP_FEE_REFUND"
	ActivityTypeAppFeeRevenue                  ActivityType = "APP_FEE_REVENUE"
	ActivityTypeAutomaticSavings               ActivityType = "AUTOMATIC_SAVINGS"
	ActivityTypeAutomaticSavingsReversed       ActivityType = "AUTOMATIC_SAVINGS_REVERSED"
	ActivityTypeCharge                         ActivityType = "CHARGE"
	ActivityTypeDepositFee                     ActivityType = "DEPOSIT_FEE"
	ActivityTypeDispute                        ActivityType = "DISPUTE"
	ActivityTypeEscheatment                    ActivityType = "ESCHEATMENT"
	ActivityTypeFee                            ActivityType = "FEE"
	ActivityTypeFreeProcessing                 ActivityType = "FREE_PROCESSING"
	ActivityTypeHoldAdjustment                 ActivityType = "HOLD_ADJUSTMENT"
	ActivityTypeInitialBalanceChange           ActivityType = "INITIAL_BALANCE_CHANGE"
	ActivityTypeMoneyTransfer                  ActivityType = "MONEY_TRANSFER"
	ActivityTypeMoneyTransferReversal          ActivityType = "MONEY_TRANSFER_REVERSAL"
	ActivityTypeOpenDispute                    ActivityType = "OPEN_DISPUTE"
	ActivityTypeOther                          ActivityType = "OTHER"
	ActivityTypeOtherAdjustment                ActivityType = "OTHER_ADJUSTMENT"
	ActivityTypePaidServiceFee                 ActivityType = "PAID_SERVICE_FEE"
	ActivityTypePaidServiceFeeRefund           ActivityType = "PAID_SERVICE_FEE_REFUND"
	ActivityTypeRedemptionCode                 ActivityType = "REDEMPTION_CODE"
	ActivityTypeRefund                         ActivityType = "REFUND"
	ActivityTypeReleaseAdjustment              ActivityType = "RELEASE_ADJUSTMENT"
	ActivityTypeReserveHold                    ActivityType = "RESERVE_HOLD"
	ActivityTypeReserveRelease                 ActivityType = "RESERVE_RELEASE"
	ActivityTypeReturnedPayout                 ActivityType = "RETURNED_PAYOUT"
	ActivityTypeSquareCapitalPayment           ActivityType = "SQUARE_CAPITAL_PAYMENT"
	ActivityTypeSquareCapitalReversedPayment   ActivityType = "SQUARE_CAPITAL_REVERSED_PAYMENT"
	ActivityTypeSubscriptionFee                ActivityType = "SUBSCRIPTION_FEE"
	ActivityTypeSubscriptionFeePaidRefund      ActivityType = "SUBSCRIPTION_FEE_PAID_REFUND"
	ActivityTypeSubscriptionFeeRefund          ActivityType = "SUBSCRIPTION_FEE_REFUND"
	ActivityTypeTaxOnFee                       ActivityType = "TAX_ON_FEE"
	ActivityTypeThirdPartyFee                  ActivityType = "THIRD_PARTY_FEE"
	ActivityTypeThirdPartyFeeRefund            ActivityType = "THIRD_PARTY_FEE_REFUND"
)

func NewActivityTypeFromString(s string) (ActivityType, error) {
	switch s {
	case "UNKNOWN_PAYOUT_ENTRY_TYPE_DO_NOT_USE":
		return ActivityTypeUnknownPayoutEntryTypeDoNotUse, nil
	case "ADJUSTMENT":
		return ActivityTypeAdjustment, nil
	case "APP_FEE_REFUND":
		return ActivityTypeAppFeeRefund, nil
	case "APP_FEE_REVENUE":
		return ActivityTypeAppFeeRevenue, nil
	case "AUTOMATIC_SAVINGS":
		return ActivityTypeAutomaticSavings, nil
	case "AUTOMATIC_SAVINGS_REVERSED":
		return ActivityTypeAutomaticSavingsReversed, nil
	case "CHARGE":
		return ActivityTypeCharge, nil
	case "DEPOSIT_FEE":
		return ActivityTypeDepositFee, nil
	case "DISPUTE":
		return ActivityTypeDispute, nil
	case "ESCHEATMENT":
		return ActivityTypeEscheatment, nil
	case "FEE":
		return ActivityTypeFee, nil
	case "FREE_PROCESSING":
		return ActivityTypeFreeProcessing, nil
	case "HOLD_ADJUSTMENT":
		return ActivityTypeHoldAdjustment, nil
	case "INITIAL_BALANCE_CHANGE":
		return ActivityTypeInitialBalanceChange, nil
	case "MONEY_TRANSFER":
		return ActivityTypeMoneyTransfer, nil
	case "MONEY_TRANSFER_REVERSAL":
		return ActivityTypeMoneyTransferReversal, nil
	case "OPEN_DISPUTE":
		return ActivityTypeOpenDispute, nil
	case "OTHER":
		return ActivityTypeOther, nil
	case "OTHER_ADJUSTMENT":
		return ActivityTypeOtherAdjustment, nil
	case "PAID_SERVICE_FEE":
		return ActivityTypePaidServiceFee, nil
	case "PAID_SERVICE_FEE_REFUND":
		return ActivityTypePaidServiceFeeRefund, nil
	case "REDEMPTION_CODE":
		return ActivityTypeRedemptionCode, nil
	case "REFUND":
		return ActivityTypeRefund, nil
	case "RELEASE_ADJUSTMENT":
		return ActivityTypeReleaseAdjustment, nil
	case "RESERVE_HOLD":
		return ActivityTypeReserveHold, nil
	case "RESERVE_RELEASE":
		return ActivityTypeReserveRelease, nil
	case "RETURNED_PAYOUT":
		return ActivityTypeReturnedPayout, nil
	case "SQUARE_CAPITAL_PAYMENT":
		return ActivityTypeSquareCapitalPayment, nil
	case "SQUARE_CAPITAL_REVERSED_PAYMENT":
		return ActivityTypeSquareCapitalReversedPayment, nil
	case "SUBSCRIPTION_FEE":
		return ActivityTypeSubscriptionFee, nil
	case "SUBSCRIPTION_FEE_PAID_REFUND":
		return ActivityTypeSubscriptionFeePaidRefund, nil
	case "SUBSCRIPTION_FEE_REFUND":
		return ActivityTypeSubscriptionFeeRefund, nil
	case "TAX_ON_FEE":
		return ActivityTypeTaxOnFee, nil
	case "THIRD_PARTY_FEE":
		return ActivityTypeThirdPartyFee, nil
	case "THIRD_PARTY_FEE_REFUND":
		return ActivityTypeThirdPartyFeeRefund, nil
	}
	var t ActivityType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a ActivityType) Ptr() *ActivityType {
	return &a
}

// Defines the fields that are included in the request body of
// a request to the [AddGroupToCustomer](api-endpoint:Customers-AddGroupToCustomer) endpoint.
type AddGroupToCustomerRequest struct {
	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (a *AddGroupToCustomerRequest) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AddGroupToCustomerRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler AddGroupToCustomerRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AddGroupToCustomerRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *AddGroupToCustomerRequest) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// Defines the fields that are included in the response body of
// a request to the [AddGroupToCustomer](api-endpoint:Customers-AddGroupToCustomer) endpoint.
type AddGroupToCustomerResponse struct {
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (a *AddGroupToCustomerResponse) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AddGroupToCustomerResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler AddGroupToCustomerResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AddGroupToCustomerResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *AddGroupToCustomerResponse) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// Represents an additional recipient (other than the merchant) receiving a portion of this tender.
type AdditionalRecipient struct {
	// The location ID for a recipient (other than the merchant) receiving a portion of this tender.
	LocationId string `json:"location_id" url:"location_id"`
	// The description of the additional recipient.
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	// The amount of money distributed to the recipient.
	AmountMoney *Money `json:"amount_money,omitempty" url:"amount_money,omitempty"`
	// The unique ID for the RETIRED `AdditionalRecipientReceivable` object. This field should be empty for any `AdditionalRecipient` objects created after the retirement.
	ReceivableId *string `json:"receivable_id,omitempty" url:"receivable_id,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (a *AdditionalRecipient) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AdditionalRecipient) UnmarshalJSON(data []byte) error {
	type unmarshaler AdditionalRecipient
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AdditionalRecipient(value)

	extraProperties, err := core.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *AdditionalRecipient) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// Represents a postal address in a country.
// For more information, see [Working with Addresses](https://developer.squareup.com/docs/build-basics/working-with-addresses).
type Address struct {
	// The first line of the address.
	//
	// Fields that start with `address_line` provide the address's most specific
	// details, like street number, street name, and building name. They do _not_
	// provide less specific details like city, state/province, or country (these
	// details are provided in other fields).
	AddressLine1 *string `json:"address_line_1,omitempty" url:"address_line_1,omitempty"`
	// The second line of the address, if any.
	AddressLine2 *string `json:"address_line_2,omitempty" url:"address_line_2,omitempty"`
	// The third line of the address, if any.
	AddressLine3 *string `json:"address_line_3,omitempty" url:"address_line_3,omitempty"`
	// The city or town of the address. For a full list of field meanings by country, see [Working with Addresses](https://developer.squareup.com/docs/build-basics/working-with-addresses).
	Locality *string `json:"locality,omitempty" url:"locality,omitempty"`
	// A civil region within the address's `locality`, if any.
	Sublocality *string `json:"sublocality,omitempty" url:"sublocality,omitempty"`
	// A civil region within the address's `sublocality`, if any.
	Sublocality2 *string `json:"sublocality_2,omitempty" url:"sublocality_2,omitempty"`
	// A civil region within the address's `sublocality_2`, if any.
	Sublocality3 *string `json:"sublocality_3,omitempty" url:"sublocality_3,omitempty"`
	// A civil entity within the address's country. In the US, this
	// is the state. For a full list of field meanings by country, see [Working with Addresses](https://developer.squareup.com/docs/build-basics/working-with-addresses).
	AdministrativeDistrictLevel1 *string `json:"administrative_district_level_1,omitempty" url:"administrative_district_level_1,omitempty"`
	// A civil entity within the address's `administrative_district_level_1`.
	// In the US, this is the county.
	AdministrativeDistrictLevel2 *string `json:"administrative_district_level_2,omitempty" url:"administrative_district_level_2,omitempty"`
	// A civil entity within the address's `administrative_district_level_2`,
	// if any.
	AdministrativeDistrictLevel3 *string `json:"administrative_district_level_3,omitempty" url:"administrative_district_level_3,omitempty"`
	// The address's postal code. For a full list of field meanings by country, see [Working with Addresses](https://developer.squareup.com/docs/build-basics/working-with-addresses).
	PostalCode *string `json:"postal_code,omitempty" url:"postal_code,omitempty"`
	// The address's country, in the two-letter format of ISO 3166. For example, `US` or `FR`.
	// See [Country](#type-country) for possible values
	Country *Country `json:"country,omitempty" url:"country,omitempty"`
	// Optional first name when it's representing recipient.
	FirstName *string `json:"first_name,omitempty" url:"first_name,omitempty"`
	// Optional last name when it's representing recipient.
	LastName *string `json:"last_name,omitempty" url:"last_name,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (a *Address) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *Address) UnmarshalJSON(data []byte) error {
	type unmarshaler Address
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = Address(value)

	extraProperties, err := core.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *Address) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// Represents an [AdjustLoyaltyPoints](api-endpoint:Loyalty-AdjustLoyaltyPoints) request.
type AdjustLoyaltyPointsResponse struct {
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The resulting event data for the adjustment.
	Event *LoyaltyEvent `json:"event,omitempty" url:"event,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (a *AdjustLoyaltyPointsResponse) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AdjustLoyaltyPointsResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler AdjustLoyaltyPointsResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AdjustLoyaltyPointsResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *AdjustLoyaltyPointsResponse) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// Additional details about Afterpay payments.
type AfterpayDetails struct {
	// Email address on the buyer's Afterpay account.
	EmailAddress *string `json:"email_address,omitempty" url:"email_address,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (a *AfterpayDetails) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AfterpayDetails) UnmarshalJSON(data []byte) error {
	type unmarshaler AfterpayDetails
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AfterpayDetails(value)

	extraProperties, err := core.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *AfterpayDetails) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// Details about the application that took the payment.
type ApplicationDetails struct {
	// The Square product, such as Square Point of Sale (POS),
	// Square Invoices, or Square Virtual Terminal.
	// See [ExternalSquareProduct](#type-externalsquareproduct) for possible values
	SquareProduct *ApplicationDetailsExternalSquareProduct `json:"square_product,omitempty" url:"square_product,omitempty"`
	// The Square ID assigned to the application used to take the payment.
	// Application developers can use this information to identify payments that
	// their application processed.
	// For example, if a developer uses a custom application to process payments,
	// this field contains the application ID from the Developer Dashboard.
	// If a seller uses a [Square App Marketplace](https://developer.squareup.com/docs/app-marketplace)
	// application to process payments, the field contains the corresponding application ID.
	ApplicationId *string `json:"application_id,omitempty" url:"application_id,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (a *ApplicationDetails) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *ApplicationDetails) UnmarshalJSON(data []byte) error {
	type unmarshaler ApplicationDetails
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = ApplicationDetails(value)

	extraProperties, err := core.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *ApplicationDetails) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// A list of products to return to external callers.
type ApplicationDetailsExternalSquareProduct string

const (
	ApplicationDetailsExternalSquareProductAppointments    ApplicationDetailsExternalSquareProduct = "APPOINTMENTS"
	ApplicationDetailsExternalSquareProductEcommerceApi    ApplicationDetailsExternalSquareProduct = "ECOMMERCE_API"
	ApplicationDetailsExternalSquareProductInvoices        ApplicationDetailsExternalSquareProduct = "INVOICES"
	ApplicationDetailsExternalSquareProductOnlineStore     ApplicationDetailsExternalSquareProduct = "ONLINE_STORE"
	ApplicationDetailsExternalSquareProductOther           ApplicationDetailsExternalSquareProduct = "OTHER"
	ApplicationDetailsExternalSquareProductRestaurants     ApplicationDetailsExternalSquareProduct = "RESTAURANTS"
	ApplicationDetailsExternalSquareProductRetail          ApplicationDetailsExternalSquareProduct = "RETAIL"
	ApplicationDetailsExternalSquareProductSquarePos       ApplicationDetailsExternalSquareProduct = "SQUARE_POS"
	ApplicationDetailsExternalSquareProductTerminalApi     ApplicationDetailsExternalSquareProduct = "TERMINAL_API"
	ApplicationDetailsExternalSquareProductVirtualTerminal ApplicationDetailsExternalSquareProduct = "VIRTUAL_TERMINAL"
)

func NewApplicationDetailsExternalSquareProductFromString(s string) (ApplicationDetailsExternalSquareProduct, error) {
	switch s {
	case "APPOINTMENTS":
		return ApplicationDetailsExternalSquareProductAppointments, nil
	case "ECOMMERCE_API":
		return ApplicationDetailsExternalSquareProductEcommerceApi, nil
	case "INVOICES":
		return ApplicationDetailsExternalSquareProductInvoices, nil
	case "ONLINE_STORE":
		return ApplicationDetailsExternalSquareProductOnlineStore, nil
	case "OTHER":
		return ApplicationDetailsExternalSquareProductOther, nil
	case "RESTAURANTS":
		return ApplicationDetailsExternalSquareProductRestaurants, nil
	case "RETAIL":
		return ApplicationDetailsExternalSquareProductRetail, nil
	case "SQUARE_POS":
		return ApplicationDetailsExternalSquareProductSquarePos, nil
	case "TERMINAL_API":
		return ApplicationDetailsExternalSquareProductTerminalApi, nil
	case "VIRTUAL_TERMINAL":
		return ApplicationDetailsExternalSquareProductVirtualTerminal, nil
	}
	var t ApplicationDetailsExternalSquareProduct
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a ApplicationDetailsExternalSquareProduct) Ptr() *ApplicationDetailsExternalSquareProduct {
	return &a
}

// Defines an appointment segment of a booking.
type AppointmentSegment struct {
	// The time span in minutes of an appointment segment.
	DurationMinutes *int `json:"duration_minutes,omitempty" url:"duration_minutes,omitempty"`
	// The ID of the [CatalogItemVariation](entity:CatalogItemVariation) object representing the service booked in this segment.
	ServiceVariationId *string `json:"service_variation_id,omitempty" url:"service_variation_id,omitempty"`
	// The ID of the [TeamMember](entity:TeamMember) object representing the team member booked in this segment.
	TeamMemberId string `json:"team_member_id" url:"team_member_id"`
	// The current version of the item variation representing the service booked in this segment.
	ServiceVariationVersion *int64 `json:"service_variation_version,omitempty" url:"service_variation_version,omitempty"`
	// Time between the end of this segment and the beginning of the subsequent segment.
	IntermissionMinutes *int `json:"intermission_minutes,omitempty" url:"intermission_minutes,omitempty"`
	// Whether the customer accepts any team member, instead of a specific one, to serve this segment.
	AnyTeamMember *bool `json:"any_team_member,omitempty" url:"any_team_member,omitempty"`
	// The IDs of the seller-accessible resources used for this appointment segment.
	ResourceIds []string `json:"resource_ids,omitempty" url:"resource_ids,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (a *AppointmentSegment) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AppointmentSegment) UnmarshalJSON(data []byte) error {
	type unmarshaler AppointmentSegment
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AppointmentSegment(value)

	extraProperties, err := core.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *AppointmentSegment) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// Defines an appointment slot that encapsulates the appointment segments, location and starting time available for booking.
type Availability struct {
	// The RFC 3339 timestamp specifying the beginning time of the slot available for booking.
	StartAt *string `json:"start_at,omitempty" url:"start_at,omitempty"`
	// The ID of the location available for booking.
	LocationId *string `json:"location_id,omitempty" url:"location_id,omitempty"`
	// The list of appointment segments available for booking
	AppointmentSegments []*AppointmentSegment `json:"appointment_segments,omitempty" url:"appointment_segments,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (a *Availability) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *Availability) UnmarshalJSON(data []byte) error {
	type unmarshaler Availability
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = Availability(value)

	extraProperties, err := core.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *Availability) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// Represents a bank account. For more information about
// linking a bank account to a Square account, see
// [Bank Accounts API](https://developer.squareup.com/docs/bank-accounts-api).
type BankAccount struct {
	// The unique, Square-issued identifier for the bank account.
	Id string `json:"id" url:"id"`
	// The last few digits of the account number.
	AccountNumberSuffix string `json:"account_number_suffix" url:"account_number_suffix"`
	// The ISO 3166 Alpha-2 country code where the bank account is based.
	// See [Country](#type-country) for possible values
	Country Country `json:"country" url:"country"`
	// The 3-character ISO 4217 currency code indicating the operating
	// currency of the bank account. For example, the currency code for US dollars
	// is `USD`.
	// See [Currency](#type-currency) for possible values
	Currency Currency `json:"currency" url:"currency"`
	// The financial purpose of the associated bank account.
	// See [BankAccountType](#type-bankaccounttype) for possible values
	AccountType BankAccountType `json:"account_type" url:"account_type"`
	// Name of the account holder. This name must match the name
	// on the targeted bank account record.
	HolderName string `json:"holder_name" url:"holder_name"`
	// Primary identifier for the bank. For more information, see
	// [Bank Accounts API](https://developer.squareup.com/docs/bank-accounts-api).
	PrimaryBankIdentificationNumber string `json:"primary_bank_identification_number" url:"primary_bank_identification_number"`
	// Secondary identifier for the bank. For more information, see
	// [Bank Accounts API](https://developer.squareup.com/docs/bank-accounts-api).
	SecondaryBankIdentificationNumber *string `json:"secondary_bank_identification_number,omitempty" url:"secondary_bank_identification_number,omitempty"`
	// Reference identifier that will be displayed to UK bank account owners
	// when collecting direct debit authorization. Only required for UK bank accounts.
	DebitMandateReferenceId *string `json:"debit_mandate_reference_id,omitempty" url:"debit_mandate_reference_id,omitempty"`
	// Client-provided identifier for linking the banking account to an entity
	// in a third-party system (for example, a bank account number or a user identifier).
	ReferenceId *string `json:"reference_id,omitempty" url:"reference_id,omitempty"`
	// The location to which the bank account belongs.
	LocationId *string `json:"location_id,omitempty" url:"location_id,omitempty"`
	// Read-only. The current verification status of this BankAccount object.
	// See [BankAccountStatus](#type-bankaccountstatus) for possible values
	Status BankAccountStatus `json:"status" url:"status"`
	// Indicates whether it is possible for Square to send money to this bank account.
	Creditable bool `json:"creditable" url:"creditable"`
	// Indicates whether it is possible for Square to take money from this
	// bank account.
	Debitable bool `json:"debitable" url:"debitable"`
	// A Square-assigned, unique identifier for the bank account based on the
	// account information. The account fingerprint can be used to compare account
	// entries and determine if the they represent the same real-world bank account.
	Fingerprint *string `json:"fingerprint,omitempty" url:"fingerprint,omitempty"`
	// The current version of the `BankAccount`.
	Version *int `json:"version,omitempty" url:"version,omitempty"`
	// Read only. Name of actual financial institution.
	// For example "Bank of America".
	BankName *string `json:"bank_name,omitempty" url:"bank_name,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (b *BankAccount) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BankAccount) UnmarshalJSON(data []byte) error {
	type unmarshaler BankAccount
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BankAccount(value)

	extraProperties, err := core.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties

	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *BankAccount) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

// Published when you link an external bank account to a Square
// account in the Seller Dashboard. Square sets the initial status to
// `VERIFICATION_IN_PROGRESS` and publishes the event.
type BankAccountCreatedWebhook struct {
	// The ID of the target merchant associated with the event.
	MerchantId *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The ID of the target location associated with the event.
	LocationId *string `json:"location_id,omitempty" url:"location_id,omitempty"`
	// The type of event this represents, `"bank_account.created"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// A unique ID for the webhook event.
	EventId *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// Timestamp of when the webhook event was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// Data associated with the event.
	Data *BankAccountCreatedWebhookData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (b *BankAccountCreatedWebhook) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BankAccountCreatedWebhook) UnmarshalJSON(data []byte) error {
	type unmarshaler BankAccountCreatedWebhook
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BankAccountCreatedWebhook(value)

	extraProperties, err := core.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties

	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *BankAccountCreatedWebhook) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type BankAccountCreatedWebhookData struct {
	// Name of the affected object’s type, `"bank_account"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// ID of the affected bank account.
	Id *string `json:"id,omitempty" url:"id,omitempty"`
	// An object containing the created bank account.
	Object *BankAccountCreatedWebhookObject `json:"object,omitempty" url:"object,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (b *BankAccountCreatedWebhookData) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BankAccountCreatedWebhookData) UnmarshalJSON(data []byte) error {
	type unmarshaler BankAccountCreatedWebhookData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BankAccountCreatedWebhookData(value)

	extraProperties, err := core.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties

	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *BankAccountCreatedWebhookData) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type BankAccountCreatedWebhookObject struct {
	// The created bank account.
	BankAccount *BankAccount `json:"bank_account,omitempty" url:"bank_account,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (b *BankAccountCreatedWebhookObject) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BankAccountCreatedWebhookObject) UnmarshalJSON(data []byte) error {
	type unmarshaler BankAccountCreatedWebhookObject
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BankAccountCreatedWebhookObject(value)

	extraProperties, err := core.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties

	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *BankAccountCreatedWebhookObject) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

// Published when Square sets the status of a
// [BankAccount](entity:BankAccount) to `DISABLED`.
type BankAccountDisabledWebhook struct {
	// The ID of the target merchant associated with the event.
	MerchantId *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The ID of the target location associated with the event.
	LocationId *string `json:"location_id,omitempty" url:"location_id,omitempty"`
	// The type of event this represents, `"bank_account.disabled"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// A unique ID for the webhook event.
	EventId *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// Timestamp of when the webhook event was disabled, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// Data associated with the event.
	Data *BankAccountDisabledWebhookData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (b *BankAccountDisabledWebhook) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BankAccountDisabledWebhook) UnmarshalJSON(data []byte) error {
	type unmarshaler BankAccountDisabledWebhook
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BankAccountDisabledWebhook(value)

	extraProperties, err := core.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties

	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *BankAccountDisabledWebhook) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type BankAccountDisabledWebhookData struct {
	// Name of the affected object’s type, `"bank_account"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// ID of the affected bank account.
	Id *string `json:"id,omitempty" url:"id,omitempty"`
	// An object containing the disabled bank account.
	Object *BankAccountDisabledWebhookObject `json:"object,omitempty" url:"object,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (b *BankAccountDisabledWebhookData) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BankAccountDisabledWebhookData) UnmarshalJSON(data []byte) error {
	type unmarshaler BankAccountDisabledWebhookData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BankAccountDisabledWebhookData(value)

	extraProperties, err := core.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties

	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *BankAccountDisabledWebhookData) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type BankAccountDisabledWebhookObject struct {
	// The disabled bank account.
	BankAccount *BankAccount `json:"bank_account,omitempty" url:"bank_account,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (b *BankAccountDisabledWebhookObject) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BankAccountDisabledWebhookObject) UnmarshalJSON(data []byte) error {
	type unmarshaler BankAccountDisabledWebhookObject
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BankAccountDisabledWebhookObject(value)

	extraProperties, err := core.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties

	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *BankAccountDisabledWebhookObject) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

// Additional details about BANK_ACCOUNT type payments.
type BankAccountPaymentDetails struct {
	// The name of the bank associated with the bank account.
	BankName *string `json:"bank_name,omitempty" url:"bank_name,omitempty"`
	// The type of the bank transfer. The type can be `ACH` or `UNKNOWN`.
	TransferType *string `json:"transfer_type,omitempty" url:"transfer_type,omitempty"`
	// The ownership type of the bank account performing the transfer.
	// The type can be `INDIVIDUAL`, `COMPANY`, or `UNKNOWN`.
	AccountOwnershipType *string `json:"account_ownership_type,omitempty" url:"account_ownership_type,omitempty"`
	// Uniquely identifies the bank account for this seller and can be used
	// to determine if payments are from the same bank account.
	Fingerprint *string `json:"fingerprint,omitempty" url:"fingerprint,omitempty"`
	// The two-letter ISO code representing the country the bank account is located in.
	Country *string `json:"country,omitempty" url:"country,omitempty"`
	// The statement description as sent to the bank.
	StatementDescription *string `json:"statement_description,omitempty" url:"statement_description,omitempty"`
	// ACH-specific information about the transfer. The information is only populated
	// if the `transfer_type` is `ACH`.
	AchDetails *AchDetails `json:"ach_details,omitempty" url:"ach_details,omitempty"`
	// Information about errors encountered during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (b *BankAccountPaymentDetails) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BankAccountPaymentDetails) UnmarshalJSON(data []byte) error {
	type unmarshaler BankAccountPaymentDetails
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BankAccountPaymentDetails(value)

	extraProperties, err := core.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties

	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *BankAccountPaymentDetails) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

// Indicates the current verification status of a `BankAccount` object.
type BankAccountStatus string

const (
	BankAccountStatusVerificationInProgress BankAccountStatus = "VERIFICATION_IN_PROGRESS"
	BankAccountStatusVerified               BankAccountStatus = "VERIFIED"
	BankAccountStatusDisabled               BankAccountStatus = "DISABLED"
)

func NewBankAccountStatusFromString(s string) (BankAccountStatus, error) {
	switch s {
	case "VERIFICATION_IN_PROGRESS":
		return BankAccountStatusVerificationInProgress, nil
	case "VERIFIED":
		return BankAccountStatusVerified, nil
	case "DISABLED":
		return BankAccountStatusDisabled, nil
	}
	var t BankAccountStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (b BankAccountStatus) Ptr() *BankAccountStatus {
	return &b
}

// Indicates the financial purpose of the bank account.
type BankAccountType string

const (
	BankAccountTypeUnknown          BankAccountType = "UNKNOWN"
	BankAccountTypeChecking         BankAccountType = "CHECKING"
	BankAccountTypeSavings          BankAccountType = "SAVINGS"
	BankAccountTypeInvestment       BankAccountType = "INVESTMENT"
	BankAccountTypeOther            BankAccountType = "OTHER"
	BankAccountTypeBusinessChecking BankAccountType = "BUSINESS_CHECKING"
)

func NewBankAccountTypeFromString(s string) (BankAccountType, error) {
	switch s {
	case "UNKNOWN":
		return BankAccountTypeUnknown, nil
	case "CHECKING":
		return BankAccountTypeChecking, nil
	case "SAVINGS":
		return BankAccountTypeSavings, nil
	case "INVESTMENT":
		return BankAccountTypeInvestment, nil
	case "OTHER":
		return BankAccountTypeOther, nil
	case "BUSINESS_CHECKING":
		return BankAccountTypeBusinessChecking, nil
	}
	var t BankAccountType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (b BankAccountType) Ptr() *BankAccountType {
	return &b
}

// Published when Square sets the status of a
// [BankAccount](entity:BankAccount) to `VERIFIED`.
type BankAccountVerifiedWebhook struct {
	// The ID of the target merchant associated with the event.
	MerchantId *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The ID of the target location associated with the event.
	LocationId *string `json:"location_id,omitempty" url:"location_id,omitempty"`
	// The type of event this represents, `"bank_account.verified"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// A unique ID for the webhook event.
	EventId *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// Timestamp of when the webhook event was verified, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// Data associated with the event.
	Data *BankAccountVerifiedWebhookData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (b *BankAccountVerifiedWebhook) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BankAccountVerifiedWebhook) UnmarshalJSON(data []byte) error {
	type unmarshaler BankAccountVerifiedWebhook
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BankAccountVerifiedWebhook(value)

	extraProperties, err := core.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties

	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *BankAccountVerifiedWebhook) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type BankAccountVerifiedWebhookData struct {
	// Name of the affected object’s type, `"bank_account"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// ID of the affected bank account.
	Id *string `json:"id,omitempty" url:"id,omitempty"`
	// An object containing the verified bank account.
	Object *BankAccountVerifiedWebhookObject `json:"object,omitempty" url:"object,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (b *BankAccountVerifiedWebhookData) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BankAccountVerifiedWebhookData) UnmarshalJSON(data []byte) error {
	type unmarshaler BankAccountVerifiedWebhookData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BankAccountVerifiedWebhookData(value)

	extraProperties, err := core.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties

	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *BankAccountVerifiedWebhookData) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type BankAccountVerifiedWebhookObject struct {
	// The verified bank account.
	BankAccount *BankAccount `json:"bank_account,omitempty" url:"bank_account,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (b *BankAccountVerifiedWebhookObject) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BankAccountVerifiedWebhookObject) UnmarshalJSON(data []byte) error {
	type unmarshaler BankAccountVerifiedWebhookObject
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BankAccountVerifiedWebhookObject(value)

	extraProperties, err := core.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties

	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *BankAccountVerifiedWebhookObject) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

// Represents a batched request included in a call to the **SubmitBatch**
// endpoint.
type BatchRequest struct {
	// HTTP method for the API call.
	// See [BatchRequestHttpMethod](#type-batchrequesthttpmethod) for possible values
	Method BatchRequestHttpMethod `json:"method" url:"method"`
	// Endpoint path for the API call.
	RelativePath string `json:"relative_path" url:"relative_path"`
	// [Square access token](https://developer.squareup.com/docs/build-basics/access-tokens) for the API
	// call.
	AccessToken string `json:"access_token" url:"access_token"`
	// Request body for the API call. Only used for API calls using POST.
	Body map[string]string `json:"body,omitempty" url:"body,omitempty"`
	// Client-provided value to identify the request.
	RequestId *string `json:"request_id,omitempty" url:"request_id,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (b *BatchRequest) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BatchRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler BatchRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BatchRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties

	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *BatchRequest) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

// Indicates the applicable HTTP method.
type BatchRequestHttpMethod string

const (
	BatchRequestHttpMethodGet    BatchRequestHttpMethod = "GET"
	BatchRequestHttpMethodPost   BatchRequestHttpMethod = "POST"
	BatchRequestHttpMethodPut    BatchRequestHttpMethod = "PUT"
	BatchRequestHttpMethodDelete BatchRequestHttpMethod = "DELETE"
)

func NewBatchRequestHttpMethodFromString(s string) (BatchRequestHttpMethod, error) {
	switch s {
	case "GET":
		return BatchRequestHttpMethodGet, nil
	case "POST":
		return BatchRequestHttpMethodPost, nil
	case "PUT":
		return BatchRequestHttpMethodPut, nil
	case "DELETE":
		return BatchRequestHttpMethodDelete, nil
	}
	var t BatchRequestHttpMethod
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (b BatchRequestHttpMethod) Ptr() *BatchRequestHttpMethod {
	return &b
}

// Represents an individual response for a batched request to the
// **SubmitBatch** endpoint.
type BatchResponse struct {
	// HTTP status code for the response
	StatusCode *int `json:"status_code,omitempty" url:"status_code,omitempty"`
	// The body of the response (if any).
	Body map[string]string `json:"body,omitempty" url:"body,omitempty"`
	// Contains any important headers for the response, indexed by header
	// name. For example, if the response includes a pagination header, the header
	// value is available from `headers["Link"]`.
	Headers map[string]string `json:"headers,omitempty" url:"headers,omitempty"`
	// The value provided in a request for `request_id` in the corresponding
	// `BatchRequest` (if any).
	RequestId *string `json:"request_id,omitempty" url:"request_id,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (b *BatchResponse) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BatchResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler BatchResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BatchResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties

	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *BatchResponse) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

// Represents a response for an individual upsert request in a [BulkUpsertCustomerCustomAttributes](api-endpoint:CustomerCustomAttributes-BulkUpsertCustomerCustomAttributes) operation.
type BatchUpsertCustomerCustomAttributesResponseCustomerCustomAttributeUpsertResponse struct {
	// The ID of the customer profile associated with the custom attribute.
	CustomerId *string `json:"customer_id,omitempty" url:"customer_id,omitempty"`
	// The new or updated custom attribute.
	CustomAttribute *CustomAttribute `json:"custom_attribute,omitempty" url:"custom_attribute,omitempty"`
	// Any errors that occurred while processing the individual request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (b *BatchUpsertCustomerCustomAttributesResponseCustomerCustomAttributeUpsertResponse) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BatchUpsertCustomerCustomAttributesResponseCustomerCustomAttributeUpsertResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler BatchUpsertCustomerCustomAttributesResponseCustomerCustomAttributeUpsertResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BatchUpsertCustomerCustomAttributesResponseCustomerCustomAttributeUpsertResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties

	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *BatchUpsertCustomerCustomAttributesResponseCustomerCustomAttributeUpsertResponse) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

// Supported sources a booking was created from.
type BookingBookingSource string

const (
	BookingBookingSourceFirstPartyMerchant BookingBookingSource = "FIRST_PARTY_MERCHANT"
	BookingBookingSourceFirstPartyBuyer    BookingBookingSource = "FIRST_PARTY_BUYER"
	BookingBookingSourceThirdPartyBuyer    BookingBookingSource = "THIRD_PARTY_BUYER"
	BookingBookingSourceApi                BookingBookingSource = "API"
)

func NewBookingBookingSourceFromString(s string) (BookingBookingSource, error) {
	switch s {
	case "FIRST_PARTY_MERCHANT":
		return BookingBookingSourceFirstPartyMerchant, nil
	case "FIRST_PARTY_BUYER":
		return BookingBookingSourceFirstPartyBuyer, nil
	case "THIRD_PARTY_BUYER":
		return BookingBookingSourceThirdPartyBuyer, nil
	case "API":
		return BookingBookingSourceApi, nil
	}
	var t BookingBookingSource
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (b BookingBookingSource) Ptr() *BookingBookingSource {
	return &b
}

// Published when a booking is created.
//
// To receive this event with buyer-level permissions, you must have `APPOINTMENTS_READ` set for the OAuth scope.
// To receive this event with seller-level permissions, you must have `APPOINTMENTS_ALL_READ` and `APPOINTMENTS_READ` set for the OAuth scope.
type BookingCreatedWebhook struct {
	// The ID of the target seller associated with the event.
	MerchantId *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The type of this event. The value is `"booking.created"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// A unique ID for the webhook event.
	EventId *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// The timestamp of when the webhook event was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The data associated with the event.
	Data *BookingCreatedWebhookData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (b *BookingCreatedWebhook) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BookingCreatedWebhook) UnmarshalJSON(data []byte) error {
	type unmarshaler BookingCreatedWebhook
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BookingCreatedWebhook(value)

	extraProperties, err := core.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties

	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *BookingCreatedWebhook) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type BookingCreatedWebhookData struct {
	// The type of the event data object. The value is `"booking"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// The ID of the event data object.
	Id *string `json:"id,omitempty" url:"id,omitempty"`
	// An object containing the created booking.
	Object *BookingCreatedWebhookObject `json:"object,omitempty" url:"object,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (b *BookingCreatedWebhookData) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BookingCreatedWebhookData) UnmarshalJSON(data []byte) error {
	type unmarshaler BookingCreatedWebhookData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BookingCreatedWebhookData(value)

	extraProperties, err := core.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties

	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *BookingCreatedWebhookData) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type BookingCreatedWebhookObject struct {
	// The created booking.
	Booking *Booking `json:"booking,omitempty" url:"booking,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (b *BookingCreatedWebhookObject) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BookingCreatedWebhookObject) UnmarshalJSON(data []byte) error {
	type unmarshaler BookingCreatedWebhookObject
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BookingCreatedWebhookObject(value)

	extraProperties, err := core.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties

	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *BookingCreatedWebhookObject) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

// Information about a booking creator.
type BookingCreatorDetails struct {
	// The seller-accessible type of the creator of the booking.
	// See [BookingCreatorDetailsCreatorType](#type-bookingcreatordetailscreatortype) for possible values
	CreatorType *BookingCreatorDetailsCreatorType `json:"creator_type,omitempty" url:"creator_type,omitempty"`
	// The ID of the team member who created the booking, when the booking creator is of the `TEAM_MEMBER` type.
	// Access to this field requires seller-level permissions.
	TeamMemberId *string `json:"team_member_id,omitempty" url:"team_member_id,omitempty"`
	// The ID of the customer who created the booking, when the booking creator is of the `CUSTOMER` type.
	// Access to this field requires seller-level permissions.
	CustomerId *string `json:"customer_id,omitempty" url:"customer_id,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (b *BookingCreatorDetails) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BookingCreatorDetails) UnmarshalJSON(data []byte) error {
	type unmarshaler BookingCreatorDetails
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BookingCreatorDetails(value)

	extraProperties, err := core.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties

	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *BookingCreatorDetails) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

// Supported types of a booking creator.
type BookingCreatorDetailsCreatorType string

const (
	BookingCreatorDetailsCreatorTypeTeamMember BookingCreatorDetailsCreatorType = "TEAM_MEMBER"
	BookingCreatorDetailsCreatorTypeCustomer   BookingCreatorDetailsCreatorType = "CUSTOMER"
)

func NewBookingCreatorDetailsCreatorTypeFromString(s string) (BookingCreatorDetailsCreatorType, error) {
	switch s {
	case "TEAM_MEMBER":
		return BookingCreatorDetailsCreatorTypeTeamMember, nil
	case "CUSTOMER":
		return BookingCreatorDetailsCreatorTypeCustomer, nil
	}
	var t BookingCreatorDetailsCreatorType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (b BookingCreatorDetailsCreatorType) Ptr() *BookingCreatorDetailsCreatorType {
	return &b
}

// Supported booking statuses.
type BookingStatus string

const (
	BookingStatusPending             BookingStatus = "PENDING"
	BookingStatusCancelledByCustomer BookingStatus = "CANCELLED_BY_CUSTOMER"
	BookingStatusCancelledBySeller   BookingStatus = "CANCELLED_BY_SELLER"
	BookingStatusDeclined            BookingStatus = "DECLINED"
	BookingStatusAccepted            BookingStatus = "ACCEPTED"
	BookingStatusNoShow              BookingStatus = "NO_SHOW"
)

func NewBookingStatusFromString(s string) (BookingStatus, error) {
	switch s {
	case "PENDING":
		return BookingStatusPending, nil
	case "CANCELLED_BY_CUSTOMER":
		return BookingStatusCancelledByCustomer, nil
	case "CANCELLED_BY_SELLER":
		return BookingStatusCancelledBySeller, nil
	case "DECLINED":
		return BookingStatusDeclined, nil
	case "ACCEPTED":
		return BookingStatusAccepted, nil
	case "NO_SHOW":
		return BookingStatusNoShow, nil
	}
	var t BookingStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (b BookingStatus) Ptr() *BookingStatus {
	return &b
}

// Published when a booking is updated or cancelled.
//
// To receive this event with buyer-level permissions, you must have `APPOINTMENTS_READ` set for the OAuth scope.
// To receive this event with seller-level permissions, you must have `APPOINTMENTS_ALL_READ` and `APPOINTMENTS_READ` set for the OAuth scope.
type BookingUpdatedWebhook struct {
	// The ID of the target seller associated with the event.
	MerchantId *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The type of this event. The value is `"booking.updated"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// A unique ID for the webhook event.
	EventId *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// The timestamp of when the webhook event was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The data associated with the event.
	Data *BookingUpdatedWebhookData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (b *BookingUpdatedWebhook) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BookingUpdatedWebhook) UnmarshalJSON(data []byte) error {
	type unmarshaler BookingUpdatedWebhook
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BookingUpdatedWebhook(value)

	extraProperties, err := core.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties

	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *BookingUpdatedWebhook) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type BookingUpdatedWebhookData struct {
	// The type of the event data object. The value is `"booking"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// The ID of the event data object.
	Id *string `json:"id,omitempty" url:"id,omitempty"`
	// An object containing the updated booking.
	Object *BookingUpdatedWebhookObject `json:"object,omitempty" url:"object,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (b *BookingUpdatedWebhookData) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BookingUpdatedWebhookData) UnmarshalJSON(data []byte) error {
	type unmarshaler BookingUpdatedWebhookData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BookingUpdatedWebhookData(value)

	extraProperties, err := core.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties

	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *BookingUpdatedWebhookData) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type BookingUpdatedWebhookObject struct {
	// The updated booking.
	Booking *Booking `json:"booking,omitempty" url:"booking,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (b *BookingUpdatedWebhookObject) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BookingUpdatedWebhookObject) UnmarshalJSON(data []byte) error {
	type unmarshaler BookingUpdatedWebhookObject
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BookingUpdatedWebhookObject(value)

	extraProperties, err := core.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties

	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *BookingUpdatedWebhookObject) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

// A record of an employee's break during a shift.
type Break struct {
	// The UUID for this object.
	Id *string `json:"id,omitempty" url:"id,omitempty"`
	// RFC 3339; follows the same timezone information as `Shift`. Precision up to
	// the minute is respected; seconds are truncated.
	StartAt string `json:"start_at" url:"start_at"`
	// RFC 3339; follows the same timezone information as `Shift`. Precision up to
	// the minute is respected; seconds are truncated.
	EndAt *string `json:"end_at,omitempty" url:"end_at,omitempty"`
	// The `BreakType` that this `Break` was templated on.
	BreakTypeId string `json:"break_type_id" url:"break_type_id"`
	// A human-readable name.
	Name string `json:"name" url:"name"`
	// Format: RFC-3339 P[n]Y[n]M[n]DT[n]H[n]M[n]S. The expected length of
	// the break.
	ExpectedDuration string `json:"expected_duration" url:"expected_duration"`
	// Whether this break counts towards time worked for compensation
	// purposes.
	IsPaid bool `json:"is_paid" url:"is_paid"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (b *Break) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *Break) UnmarshalJSON(data []byte) error {
	type unmarshaler Break
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = Break(value)

	extraProperties, err := core.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties

	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *Break) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

// A defined break template that sets an expectation for possible `Break`
// instances on a `Shift`.
type BreakType struct {
	// The UUID for this object.
	Id *string `json:"id,omitempty" url:"id,omitempty"`
	// The ID of the business location this type of break applies to.
	LocationId string `json:"location_id" url:"location_id"`
	// A human-readable name for this type of break. The name is displayed to
	// employees in Square products.
	BreakName string `json:"break_name" url:"break_name"`
	// Format: RFC-3339 P[n]Y[n]M[n]DT[n]H[n]M[n]S. The expected length of
	// this break. Precision less than minutes is truncated.
	ExpectedDuration string `json:"expected_duration" url:"expected_duration"`
	// Whether this break counts towards time worked for compensation
	// purposes.
	IsPaid bool `json:"is_paid" url:"is_paid"`
	// Used for resolving concurrency issues. The request fails if the version
	// provided does not match the server version at the time of the request. If a value is not
	// provided, Square's servers execute a "blind" write; potentially
	// overwriting another writer's data.
	Version *int `json:"version,omitempty" url:"version,omitempty"`
	// A read-only timestamp in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// A read-only timestamp in RFC 3339 format.
	UpdatedAt *string `json:"updated_at,omitempty" url:"updated_at,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (b *BreakType) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BreakType) UnmarshalJSON(data []byte) error {
	type unmarshaler BreakType
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BreakType(value)

	extraProperties, err := core.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties

	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *BreakType) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

// The service appointment settings, including where and how the service is provided.
type BusinessAppointmentSettings struct {
	// Types of the location allowed for bookings.
	// See [BusinessAppointmentSettingsBookingLocationType](#type-businessappointmentsettingsbookinglocationtype) for possible values
	LocationTypes []BusinessAppointmentSettingsBookingLocationType `json:"location_types,omitempty" url:"location_types,omitempty"`
	// The time unit of the service duration for bookings.
	// See [BusinessAppointmentSettingsAlignmentTime](#type-businessappointmentsettingsalignmenttime) for possible values
	AlignmentTime *BusinessAppointmentSettingsAlignmentTime `json:"alignment_time,omitempty" url:"alignment_time,omitempty"`
	// The minimum lead time in seconds before a service can be booked. Bookings must be created at least this far ahead of the booking's starting time.
	MinBookingLeadTimeSeconds *int `json:"min_booking_lead_time_seconds,omitempty" url:"min_booking_lead_time_seconds,omitempty"`
	// The maximum lead time in seconds before a service can be booked. Bookings must be created at most this far ahead of the booking's starting time.
	MaxBookingLeadTimeSeconds *int `json:"max_booking_lead_time_seconds,omitempty" url:"max_booking_lead_time_seconds,omitempty"`
	// Indicates whether a customer can choose from all available time slots and have a staff member assigned
	// automatically (`true`) or not (`false`).
	AnyTeamMemberBookingEnabled *bool `json:"any_team_member_booking_enabled,omitempty" url:"any_team_member_booking_enabled,omitempty"`
	// Indicates whether a customer can book multiple services in a single online booking.
	MultipleServiceBookingEnabled *bool `json:"multiple_service_booking_enabled,omitempty" url:"multiple_service_booking_enabled,omitempty"`
	// Indicates whether the daily appointment limit applies to team members or to
	// business locations.
	// See [BusinessAppointmentSettingsMaxAppointmentsPerDayLimitType](#type-businessappointmentsettingsmaxappointmentsperdaylimittype) for possible values
	MaxAppointmentsPerDayLimitType *BusinessAppointmentSettingsMaxAppointmentsPerDayLimitType `json:"max_appointments_per_day_limit_type,omitempty" url:"max_appointments_per_day_limit_type,omitempty"`
	// The maximum number of daily appointments per team member or per location.
	MaxAppointmentsPerDayLimit *int `json:"max_appointments_per_day_limit,omitempty" url:"max_appointments_per_day_limit,omitempty"`
	// The cut-off time in seconds for allowing clients to cancel or reschedule an appointment.
	CancellationWindowSeconds *int `json:"cancellation_window_seconds,omitempty" url:"cancellation_window_seconds,omitempty"`
	// The flat-fee amount charged for a no-show booking.
	CancellationFeeMoney *Money `json:"cancellation_fee_money,omitempty" url:"cancellation_fee_money,omitempty"`
	// The cancellation policy adopted by the seller.
	// See [BusinessAppointmentSettingsCancellationPolicy](#type-businessappointmentsettingscancellationpolicy) for possible values
	CancellationPolicy *BusinessAppointmentSettingsCancellationPolicy `json:"cancellation_policy,omitempty" url:"cancellation_policy,omitempty"`
	// The free-form text of the seller's cancellation policy.
	CancellationPolicyText *string `json:"cancellation_policy_text,omitempty" url:"cancellation_policy_text,omitempty"`
	// Indicates whether customers has an assigned staff member (`true`) or can select s staff member of their choice (`false`).
	SkipBookingFlowStaffSelection *bool `json:"skip_booking_flow_staff_selection,omitempty" url:"skip_booking_flow_staff_selection,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (b *BusinessAppointmentSettings) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BusinessAppointmentSettings) UnmarshalJSON(data []byte) error {
	type unmarshaler BusinessAppointmentSettings
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BusinessAppointmentSettings(value)

	extraProperties, err := core.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties

	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *BusinessAppointmentSettings) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

// Time units of a service duration for bookings.
type BusinessAppointmentSettingsAlignmentTime string

const (
	BusinessAppointmentSettingsAlignmentTimeServiceDuration BusinessAppointmentSettingsAlignmentTime = "SERVICE_DURATION"
	BusinessAppointmentSettingsAlignmentTimeQuarterHourly   BusinessAppointmentSettingsAlignmentTime = "QUARTER_HOURLY"
	BusinessAppointmentSettingsAlignmentTimeHalfHourly      BusinessAppointmentSettingsAlignmentTime = "HALF_HOURLY"
	BusinessAppointmentSettingsAlignmentTimeHourly          BusinessAppointmentSettingsAlignmentTime = "HOURLY"
)

func NewBusinessAppointmentSettingsAlignmentTimeFromString(s string) (BusinessAppointmentSettingsAlignmentTime, error) {
	switch s {
	case "SERVICE_DURATION":
		return BusinessAppointmentSettingsAlignmentTimeServiceDuration, nil
	case "QUARTER_HOURLY":
		return BusinessAppointmentSettingsAlignmentTimeQuarterHourly, nil
	case "HALF_HOURLY":
		return BusinessAppointmentSettingsAlignmentTimeHalfHourly, nil
	case "HOURLY":
		return BusinessAppointmentSettingsAlignmentTimeHourly, nil
	}
	var t BusinessAppointmentSettingsAlignmentTime
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (b BusinessAppointmentSettingsAlignmentTime) Ptr() *BusinessAppointmentSettingsAlignmentTime {
	return &b
}

// Supported types of location where service is provided.
type BusinessAppointmentSettingsBookingLocationType string

const (
	BusinessAppointmentSettingsBookingLocationTypeBusinessLocation BusinessAppointmentSettingsBookingLocationType = "BUSINESS_LOCATION"
	BusinessAppointmentSettingsBookingLocationTypeCustomerLocation BusinessAppointmentSettingsBookingLocationType = "CUSTOMER_LOCATION"
	BusinessAppointmentSettingsBookingLocationTypePhone            BusinessAppointmentSettingsBookingLocationType = "PHONE"
)

func NewBusinessAppointmentSettingsBookingLocationTypeFromString(s string) (BusinessAppointmentSettingsBookingLocationType, error) {
	switch s {
	case "BUSINESS_LOCATION":
		return BusinessAppointmentSettingsBookingLocationTypeBusinessLocation, nil
	case "CUSTOMER_LOCATION":
		return BusinessAppointmentSettingsBookingLocationTypeCustomerLocation, nil
	case "PHONE":
		return BusinessAppointmentSettingsBookingLocationTypePhone, nil
	}
	var t BusinessAppointmentSettingsBookingLocationType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (b BusinessAppointmentSettingsBookingLocationType) Ptr() *BusinessAppointmentSettingsBookingLocationType {
	return &b
}

// The category of the seller’s cancellation policy.
type BusinessAppointmentSettingsCancellationPolicy string

const (
	BusinessAppointmentSettingsCancellationPolicyCancellationTreatedAsNoShow BusinessAppointmentSettingsCancellationPolicy = "CANCELLATION_TREATED_AS_NO_SHOW"
	BusinessAppointmentSettingsCancellationPolicyCustomPolicy                BusinessAppointmentSettingsCancellationPolicy = "CUSTOM_POLICY"
)

func NewBusinessAppointmentSettingsCancellationPolicyFromString(s string) (BusinessAppointmentSettingsCancellationPolicy, error) {
	switch s {
	case "CANCELLATION_TREATED_AS_NO_SHOW":
		return BusinessAppointmentSettingsCancellationPolicyCancellationTreatedAsNoShow, nil
	case "CUSTOM_POLICY":
		return BusinessAppointmentSettingsCancellationPolicyCustomPolicy, nil
	}
	var t BusinessAppointmentSettingsCancellationPolicy
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (b BusinessAppointmentSettingsCancellationPolicy) Ptr() *BusinessAppointmentSettingsCancellationPolicy {
	return &b
}

// Types of daily appointment limits.
type BusinessAppointmentSettingsMaxAppointmentsPerDayLimitType string

const (
	BusinessAppointmentSettingsMaxAppointmentsPerDayLimitTypePerTeamMember BusinessAppointmentSettingsMaxAppointmentsPerDayLimitType = "PER_TEAM_MEMBER"
	BusinessAppointmentSettingsMaxAppointmentsPerDayLimitTypePerLocation   BusinessAppointmentSettingsMaxAppointmentsPerDayLimitType = "PER_LOCATION"
)

func NewBusinessAppointmentSettingsMaxAppointmentsPerDayLimitTypeFromString(s string) (BusinessAppointmentSettingsMaxAppointmentsPerDayLimitType, error) {
	switch s {
	case "PER_TEAM_MEMBER":
		return BusinessAppointmentSettingsMaxAppointmentsPerDayLimitTypePerTeamMember, nil
	case "PER_LOCATION":
		return BusinessAppointmentSettingsMaxAppointmentsPerDayLimitTypePerLocation, nil
	}
	var t BusinessAppointmentSettingsMaxAppointmentsPerDayLimitType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (b BusinessAppointmentSettingsMaxAppointmentsPerDayLimitType) Ptr() *BusinessAppointmentSettingsMaxAppointmentsPerDayLimitType {
	return &b
}

type BusinessBookingProfile struct {
	// The ID of the seller, obtainable using the Merchants API.
	SellerId *string `json:"seller_id,omitempty" url:"seller_id,omitempty"`
	// The RFC 3339 timestamp specifying the booking's creation time.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// Indicates whether the seller is open for booking.
	BookingEnabled *bool `json:"booking_enabled,omitempty" url:"booking_enabled,omitempty"`
	// The choice of customer's time zone information of a booking.
	// The Square online booking site and all notifications to customers uses either the seller location’s time zone
	// or the time zone the customer chooses at booking.
	// See [BusinessBookingProfileCustomerTimezoneChoice](#type-businessbookingprofilecustomertimezonechoice) for possible values
	CustomerTimezoneChoice *BusinessBookingProfileCustomerTimezoneChoice `json:"customer_timezone_choice,omitempty" url:"customer_timezone_choice,omitempty"`
	// The policy for the seller to automatically accept booking requests (`ACCEPT_ALL`) or not (`REQUIRES_ACCEPTANCE`).
	// See [BusinessBookingProfileBookingPolicy](#type-businessbookingprofilebookingpolicy) for possible values
	BookingPolicy *BusinessBookingProfileBookingPolicy `json:"booking_policy,omitempty" url:"booking_policy,omitempty"`
	// Indicates whether customers can cancel or reschedule their own bookings (`true`) or not (`false`).
	AllowUserCancel *bool `json:"allow_user_cancel,omitempty" url:"allow_user_cancel,omitempty"`
	// Settings for appointment-type bookings.
	BusinessAppointmentSettings *BusinessAppointmentSettings `json:"business_appointment_settings,omitempty" url:"business_appointment_settings,omitempty"`
	// Indicates whether the seller's subscription to Square Appointments supports creating, updating or canceling an appointment through the API (`true`) or not (`false`) using seller permission.
	SupportSellerLevelWrites *bool `json:"support_seller_level_writes,omitempty" url:"support_seller_level_writes,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (b *BusinessBookingProfile) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BusinessBookingProfile) UnmarshalJSON(data []byte) error {
	type unmarshaler BusinessBookingProfile
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BusinessBookingProfile(value)

	extraProperties, err := core.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties

	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *BusinessBookingProfile) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

// Policies for accepting bookings.
type BusinessBookingProfileBookingPolicy string

const (
	BusinessBookingProfileBookingPolicyAcceptAll          BusinessBookingProfileBookingPolicy = "ACCEPT_ALL"
	BusinessBookingProfileBookingPolicyRequiresAcceptance BusinessBookingProfileBookingPolicy = "REQUIRES_ACCEPTANCE"
)

func NewBusinessBookingProfileBookingPolicyFromString(s string) (BusinessBookingProfileBookingPolicy, error) {
	switch s {
	case "ACCEPT_ALL":
		return BusinessBookingProfileBookingPolicyAcceptAll, nil
	case "REQUIRES_ACCEPTANCE":
		return BusinessBookingProfileBookingPolicyRequiresAcceptance, nil
	}
	var t BusinessBookingProfileBookingPolicy
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (b BusinessBookingProfileBookingPolicy) Ptr() *BusinessBookingProfileBookingPolicy {
	return &b
}

// Choices of customer-facing time zone used for bookings.
type BusinessBookingProfileCustomerTimezoneChoice string

const (
	BusinessBookingProfileCustomerTimezoneChoiceBusinessLocationTimezone BusinessBookingProfileCustomerTimezoneChoice = "BUSINESS_LOCATION_TIMEZONE"
	BusinessBookingProfileCustomerTimezoneChoiceCustomerChoice           BusinessBookingProfileCustomerTimezoneChoice = "CUSTOMER_CHOICE"
)

func NewBusinessBookingProfileCustomerTimezoneChoiceFromString(s string) (BusinessBookingProfileCustomerTimezoneChoice, error) {
	switch s {
	case "BUSINESS_LOCATION_TIMEZONE":
		return BusinessBookingProfileCustomerTimezoneChoiceBusinessLocationTimezone, nil
	case "CUSTOMER_CHOICE":
		return BusinessBookingProfileCustomerTimezoneChoiceCustomerChoice, nil
	}
	var t BusinessBookingProfileCustomerTimezoneChoice
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (b BusinessBookingProfileCustomerTimezoneChoice) Ptr() *BusinessBookingProfileCustomerTimezoneChoice {
	return &b
}

// The hours of operation for a location.
type BusinessHours struct {
	// The list of time periods during which the business is open. There can be at most 10 periods per day.
	Periods []*BusinessHoursPeriod `json:"periods,omitempty" url:"periods,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (b *BusinessHours) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BusinessHours) UnmarshalJSON(data []byte) error {
	type unmarshaler BusinessHours
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BusinessHours(value)

	extraProperties, err := core.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties

	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *BusinessHours) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

// Represents a period of time during which a business location is open.
type BusinessHoursPeriod struct {
	// The day of the week for this time period.
	// See [DayOfWeek](#type-dayofweek) for possible values
	DayOfWeek *DayOfWeek `json:"day_of_week,omitempty" url:"day_of_week,omitempty"`
	// The start time of a business hours period, specified in local time using partial-time
	// RFC 3339 format. For example, `8:30:00` for a period starting at 8:30 in the morning.
	// Note that the seconds value is always :00, but it is appended for conformance to the RFC.
	StartLocalTime *string `json:"start_local_time,omitempty" url:"start_local_time,omitempty"`
	// The end time of a business hours period, specified in local time using partial-time
	// RFC 3339 format. For example, `21:00:00` for a period ending at 9:00 in the evening.
	// Note that the seconds value is always :00, but it is appended for conformance to the RFC.
	EndLocalTime *string `json:"end_local_time,omitempty" url:"end_local_time,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (b *BusinessHoursPeriod) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BusinessHoursPeriod) UnmarshalJSON(data []byte) error {
	type unmarshaler BusinessHoursPeriod
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BusinessHoursPeriod(value)

	extraProperties, err := core.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties

	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *BusinessHoursPeriod) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

// Additional details about a Buy Now Pay Later payment type.
type BuyNowPayLaterDetails struct {
	// The brand used for the Buy Now Pay Later payment.
	// The brand can be `AFTERPAY`, `CLEARPAY` or `UNKNOWN`.
	Brand *string `json:"brand,omitempty" url:"brand,omitempty"`
	// Details about an Afterpay payment. These details are only populated if the `brand` is
	// `AFTERPAY`.
	AfterpayDetails *AfterpayDetails `json:"afterpay_details,omitempty" url:"afterpay_details,omitempty"`
	// Details about a Clearpay payment. These details are only populated if the `brand` is
	// `CLEARPAY`.
	ClearpayDetails *ClearpayDetails `json:"clearpay_details,omitempty" url:"clearpay_details,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (b *BuyNowPayLaterDetails) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BuyNowPayLaterDetails) UnmarshalJSON(data []byte) error {
	type unmarshaler BuyNowPayLaterDetails
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BuyNowPayLaterDetails(value)

	extraProperties, err := core.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties

	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *BuyNowPayLaterDetails) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

// Represents a [CalculateLoyaltyPoints](api-endpoint:Loyalty-CalculateLoyaltyPoints) response.
type CalculateLoyaltyPointsResponse struct {
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The number of points that the buyer can earn from the base loyalty program.
	Points *int `json:"points,omitempty" url:"points,omitempty"`
	// The number of points that the buyer can earn from a loyalty promotion. To be eligible
	// to earn promotion points, the purchase must first qualify for program points. When `order_id`
	// is not provided in the request, this value is always 0.
	PromotionPoints *int `json:"promotion_points,omitempty" url:"promotion_points,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CalculateLoyaltyPointsResponse) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CalculateLoyaltyPointsResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler CalculateLoyaltyPointsResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CalculateLoyaltyPointsResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CalculateLoyaltyPointsResponse) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Represents a [CancelLoyaltyPromotion](api-endpoint:Loyalty-CancelLoyaltyPromotion) request.
type CancelLoyaltyPromotionRequest struct {
	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CancelLoyaltyPromotionRequest) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CancelLoyaltyPromotionRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler CancelLoyaltyPromotionRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CancelLoyaltyPromotionRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CancelLoyaltyPromotionRequest) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Represents a [CancelLoyaltyPromotion](api-endpoint:Loyalty-CancelLoyaltyPromotion) response.
// Either `loyalty_promotion` or `errors` is present in the response.
type CancelLoyaltyPromotionResponse struct {
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The canceled loyalty promotion.
	LoyaltyPromotion *LoyaltyPromotion `json:"loyalty_promotion,omitempty" url:"loyalty_promotion,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CancelLoyaltyPromotionResponse) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CancelLoyaltyPromotionResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler CancelLoyaltyPromotionResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CancelLoyaltyPromotionResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CancelLoyaltyPromotionResponse) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Defines the response returned by
// [CancelPaymentByIdempotencyKey](api-endpoint:Payments-CancelPaymentByIdempotencyKey).
// On success, `errors` is empty.
type CancelPaymentByIdempotencyKeyResponse struct {
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CancelPaymentByIdempotencyKeyResponse) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CancelPaymentByIdempotencyKeyResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler CancelPaymentByIdempotencyKeyResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CancelPaymentByIdempotencyKeyResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CancelPaymentByIdempotencyKeyResponse) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Describes the request to cancel (void) a payment using
// [CancelPayment](api-endpoint:Payments-CancelPayment).
// You can only cancel a payment that is approved (not completed).
// For more information, see
// [Delayed capture of a payment](https://developer.squareup.com/docs/payments-api/take-payments/card-payments#delayed-capture-of-a-card-payment).
type CancelPaymentRequest struct {
	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CancelPaymentRequest) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CancelPaymentRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler CancelPaymentRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CancelPaymentRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CancelPaymentRequest) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Defines input parameters in a request to the
// [CancelSubscription](api-endpoint:Subscriptions-CancelSubscription) endpoint.
type CancelSubscriptionRequest struct {
	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CancelSubscriptionRequest) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CancelSubscriptionRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler CancelSubscriptionRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CancelSubscriptionRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CancelSubscriptionRequest) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CancelTerminalActionResponse struct {
	// Information on errors encountered during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The canceled `TerminalAction`
	Action *TerminalAction `json:"action,omitempty" url:"action,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CancelTerminalActionResponse) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CancelTerminalActionResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler CancelTerminalActionResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CancelTerminalActionResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CancelTerminalActionResponse) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CancelTerminalCheckoutResponse struct {
	// Information about errors encountered during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The canceled `TerminalCheckout`.
	Checkout *TerminalCheckout `json:"checkout,omitempty" url:"checkout,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CancelTerminalCheckoutResponse) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CancelTerminalCheckoutResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler CancelTerminalCheckoutResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CancelTerminalCheckoutResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CancelTerminalCheckoutResponse) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CancelTerminalRefundResponse struct {
	// Information about errors encountered during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The updated `TerminalRefund`.
	Refund *TerminalRefund `json:"refund,omitempty" url:"refund,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CancelTerminalRefundResponse) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CancelTerminalRefundResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler CancelTerminalRefundResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CancelTerminalRefundResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CancelTerminalRefundResponse) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CaptureTransactionRequest struct {
	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CaptureTransactionRequest) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CaptureTransactionRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler CaptureTransactionRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CaptureTransactionRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CaptureTransactionRequest) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Defines the fields that are included in the response body of
// a request to the [CaptureTransaction](api-endpoint:Transactions-CaptureTransaction) endpoint.
type CaptureTransactionResponse struct {
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CaptureTransactionResponse) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CaptureTransactionResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler CaptureTransactionResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CaptureTransactionResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CaptureTransactionResponse) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Published when a Card's expiration information or pan is automatically updated.
type CardAutomaticallyUpdatedWebhook struct {
	// The ID of the target seller associated with the event.
	MerchantId *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The type of this event. The value is `"card.automatically_updated"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// A unique ID for the webhook event.
	EventId *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// The timestamp of when the webhook event was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The data associated with the event.
	Data *CardAutomaticallyUpdatedWebhookData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CardAutomaticallyUpdatedWebhook) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CardAutomaticallyUpdatedWebhook) UnmarshalJSON(data []byte) error {
	type unmarshaler CardAutomaticallyUpdatedWebhook
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CardAutomaticallyUpdatedWebhook(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CardAutomaticallyUpdatedWebhook) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CardAutomaticallyUpdatedWebhookData struct {
	// The type of the event data object. The value is `"card"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// The ID of the event data object.
	Id *string `json:"id,omitempty" url:"id,omitempty"`
	// An object containing the automatically updated card.
	Object *CardAutomaticallyUpdatedWebhookObject `json:"object,omitempty" url:"object,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CardAutomaticallyUpdatedWebhookData) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CardAutomaticallyUpdatedWebhookData) UnmarshalJSON(data []byte) error {
	type unmarshaler CardAutomaticallyUpdatedWebhookData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CardAutomaticallyUpdatedWebhookData(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CardAutomaticallyUpdatedWebhookData) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CardAutomaticallyUpdatedWebhookObject struct {
	// The automatically updated card.
	Card *Card `json:"card,omitempty" url:"card,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CardAutomaticallyUpdatedWebhookObject) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CardAutomaticallyUpdatedWebhookObject) UnmarshalJSON(data []byte) error {
	type unmarshaler CardAutomaticallyUpdatedWebhookObject
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CardAutomaticallyUpdatedWebhookObject(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CardAutomaticallyUpdatedWebhookObject) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Indicates a card's brand, such as `VISA` or `MASTERCARD`.
type CardBrand string

const (
	CardBrandOtherBrand        CardBrand = "OTHER_BRAND"
	CardBrandVisa              CardBrand = "VISA"
	CardBrandMastercard        CardBrand = "MASTERCARD"
	CardBrandAmericanExpress   CardBrand = "AMERICAN_EXPRESS"
	CardBrandDiscover          CardBrand = "DISCOVER"
	CardBrandDiscoverDiners    CardBrand = "DISCOVER_DINERS"
	CardBrandJcb               CardBrand = "JCB"
	CardBrandChinaUnionpay     CardBrand = "CHINA_UNIONPAY"
	CardBrandSquareGiftCard    CardBrand = "SQUARE_GIFT_CARD"
	CardBrandSquareCapitalCard CardBrand = "SQUARE_CAPITAL_CARD"
	CardBrandInterac           CardBrand = "INTERAC"
	CardBrandEftpos            CardBrand = "EFTPOS"
	CardBrandFelica            CardBrand = "FELICA"
	CardBrandEbt               CardBrand = "EBT"
)

func NewCardBrandFromString(s string) (CardBrand, error) {
	switch s {
	case "OTHER_BRAND":
		return CardBrandOtherBrand, nil
	case "VISA":
		return CardBrandVisa, nil
	case "MASTERCARD":
		return CardBrandMastercard, nil
	case "AMERICAN_EXPRESS":
		return CardBrandAmericanExpress, nil
	case "DISCOVER":
		return CardBrandDiscover, nil
	case "DISCOVER_DINERS":
		return CardBrandDiscoverDiners, nil
	case "JCB":
		return CardBrandJcb, nil
	case "CHINA_UNIONPAY":
		return CardBrandChinaUnionpay, nil
	case "SQUARE_GIFT_CARD":
		return CardBrandSquareGiftCard, nil
	case "SQUARE_CAPITAL_CARD":
		return CardBrandSquareCapitalCard, nil
	case "INTERAC":
		return CardBrandInterac, nil
	case "EFTPOS":
		return CardBrandEftpos, nil
	case "FELICA":
		return CardBrandFelica, nil
	case "EBT":
		return CardBrandEbt, nil
	}
	var t CardBrand
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CardBrand) Ptr() *CardBrand {
	return &c
}

// Indicates the brand for a co-branded card.
type CardCoBrand string

const (
	CardCoBrandUnknown  CardCoBrand = "UNKNOWN"
	CardCoBrandAfterpay CardCoBrand = "AFTERPAY"
	CardCoBrandClearpay CardCoBrand = "CLEARPAY"
)

func NewCardCoBrandFromString(s string) (CardCoBrand, error) {
	switch s {
	case "UNKNOWN":
		return CardCoBrandUnknown, nil
	case "AFTERPAY":
		return CardCoBrandAfterpay, nil
	case "CLEARPAY":
		return CardCoBrandClearpay, nil
	}
	var t CardCoBrand
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CardCoBrand) Ptr() *CardCoBrand {
	return &c
}

// Published when a Card is created or imported.
type CardCreatedWebhook struct {
	// The ID of the target seller associated with the event.
	MerchantId *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The type of this event. The value is `"card.created"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// A unique ID for the webhook event.
	EventId *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// The timestamp of when the webhook event was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The data associated with the event.
	Data *CardCreatedWebhookData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CardCreatedWebhook) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CardCreatedWebhook) UnmarshalJSON(data []byte) error {
	type unmarshaler CardCreatedWebhook
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CardCreatedWebhook(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CardCreatedWebhook) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CardCreatedWebhookData struct {
	// The type of the event data object. The value is `"card"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// The ID of the event data object.
	Id *string `json:"id,omitempty" url:"id,omitempty"`
	// An object containing the created card.
	Object *CardCreatedWebhookObject `json:"object,omitempty" url:"object,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CardCreatedWebhookData) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CardCreatedWebhookData) UnmarshalJSON(data []byte) error {
	type unmarshaler CardCreatedWebhookData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CardCreatedWebhookData(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CardCreatedWebhookData) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CardCreatedWebhookObject struct {
	// The created card.
	Card *Card `json:"card,omitempty" url:"card,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CardCreatedWebhookObject) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CardCreatedWebhookObject) UnmarshalJSON(data []byte) error {
	type unmarshaler CardCreatedWebhookObject
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CardCreatedWebhookObject(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CardCreatedWebhookObject) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Published when a Card is disabled.
type CardDisabledWebhook struct {
	// The ID of the target seller associated with the event.
	MerchantId *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The type of this event. The value is `"card.disabled"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// A unique ID for the webhook event.
	EventId *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// The timestamp of when the webhook event was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The data associated with the event.
	Data *CardDisabledWebhookData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CardDisabledWebhook) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CardDisabledWebhook) UnmarshalJSON(data []byte) error {
	type unmarshaler CardDisabledWebhook
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CardDisabledWebhook(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CardDisabledWebhook) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CardDisabledWebhookData struct {
	// The type of the event data object. The value is `"card"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// The ID of the event data object.
	Id *string `json:"id,omitempty" url:"id,omitempty"`
	// An object containing the disabled card.
	Object *CardDisabledWebhookObject `json:"object,omitempty" url:"object,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CardDisabledWebhookData) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CardDisabledWebhookData) UnmarshalJSON(data []byte) error {
	type unmarshaler CardDisabledWebhookData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CardDisabledWebhookData(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CardDisabledWebhookData) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CardDisabledWebhookObject struct {
	// The disabled card.
	Card *Card `json:"card,omitempty" url:"card,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CardDisabledWebhookObject) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CardDisabledWebhookObject) UnmarshalJSON(data []byte) error {
	type unmarshaler CardDisabledWebhookObject
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CardDisabledWebhookObject(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CardDisabledWebhookObject) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Published when a Card is GDPR forgotten/vaulted.
type CardForgottenWebhook struct {
	// The ID of the target seller associated with the event.
	MerchantId *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The type of this event. The value is `"card.forgotten"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// A unique ID for the webhook event.
	EventId *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// The timestamp of when the webhook event was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The data associated with the event.
	Data *CardForgottenWebhookData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CardForgottenWebhook) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CardForgottenWebhook) UnmarshalJSON(data []byte) error {
	type unmarshaler CardForgottenWebhook
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CardForgottenWebhook(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CardForgottenWebhook) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CardForgottenWebhookCard struct {
	// Unique ID for this card. Generated by Square.
	Id *string `json:"id,omitempty" url:"id,omitempty"`
	// The ID of a customer created using the Customers API associated with the card.
	CustomerId *string `json:"customer_id,omitempty" url:"customer_id,omitempty"`
	// Indicates whether or not a card can be used for payments.
	Enabled *bool `json:"enabled,omitempty" url:"enabled,omitempty"`
	// An optional user-defined reference ID that associates this card with
	// another entity in an external system. For example, a customer ID from an
	// external customer management system.
	ReferenceId *string `json:"reference_id,omitempty" url:"reference_id,omitempty"`
	// Current version number of the card. Increments with each card update. Requests to update an
	// existing Card object will be rejected unless the version in the request matches the current
	// version for the Card.
	Version *int64 `json:"version,omitempty" url:"version,omitempty"`
	// The ID of the merchant associated with the card.
	MerchantId *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CardForgottenWebhookCard) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CardForgottenWebhookCard) UnmarshalJSON(data []byte) error {
	type unmarshaler CardForgottenWebhookCard
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CardForgottenWebhookCard(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CardForgottenWebhookCard) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CardForgottenWebhookData struct {
	// The type of the event data object. The value is `"card"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// The ID of the event data object.
	Id *string `json:"id,omitempty" url:"id,omitempty"`
	// An object containing the forgotten card.
	Object *CardForgottenWebhookObject `json:"object,omitempty" url:"object,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CardForgottenWebhookData) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CardForgottenWebhookData) UnmarshalJSON(data []byte) error {
	type unmarshaler CardForgottenWebhookData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CardForgottenWebhookData(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CardForgottenWebhookData) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CardForgottenWebhookObject struct {
	// The forgotten card.
	Card *CardForgottenWebhookCard `json:"card,omitempty" url:"card,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CardForgottenWebhookObject) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CardForgottenWebhookObject) UnmarshalJSON(data []byte) error {
	type unmarshaler CardForgottenWebhookObject
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CardForgottenWebhookObject(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CardForgottenWebhookObject) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Reflects the current status of a card payment. Contains only non-confidential information.
type CardPaymentDetails struct {
	// The card payment's current state. The state can be AUTHORIZED, CAPTURED, VOIDED, or
	// FAILED.
	Status *string `json:"status,omitempty" url:"status,omitempty"`
	// The credit card's non-confidential details.
	Card *Card `json:"card,omitempty" url:"card,omitempty"`
	// The method used to enter the card's details for the payment. The method can be
	// `KEYED`, `SWIPED`, `EMV`, `ON_FILE`, or `CONTACTLESS`.
	EntryMethod *string `json:"entry_method,omitempty" url:"entry_method,omitempty"`
	// The status code returned from the Card Verification Value (CVV) check. The code can be
	// `CVV_ACCEPTED`, `CVV_REJECTED`, or `CVV_NOT_CHECKED`.
	CvvStatus *string `json:"cvv_status,omitempty" url:"cvv_status,omitempty"`
	// The status code returned from the Address Verification System (AVS) check. The code can be
	// `AVS_ACCEPTED`, `AVS_REJECTED`, or `AVS_NOT_CHECKED`.
	AvsStatus *string `json:"avs_status,omitempty" url:"avs_status,omitempty"`
	// The status code returned by the card issuer that describes the payment's
	// authorization status.
	AuthResultCode *string `json:"auth_result_code,omitempty" url:"auth_result_code,omitempty"`
	// For EMV payments, the application ID identifies the EMV application used for the payment.
	ApplicationIdentifier *string `json:"application_identifier,omitempty" url:"application_identifier,omitempty"`
	// For EMV payments, the human-readable name of the EMV application used for the payment.
	ApplicationName *string `json:"application_name,omitempty" url:"application_name,omitempty"`
	// For EMV payments, the cryptogram generated for the payment.
	ApplicationCryptogram *string `json:"application_cryptogram,omitempty" url:"application_cryptogram,omitempty"`
	// For EMV payments, the method used to verify the cardholder's identity. The method can be
	// `PIN`, `SIGNATURE`, `PIN_AND_SIGNATURE`, `ON_DEVICE`, or `NONE`.
	VerificationMethod *string `json:"verification_method,omitempty" url:"verification_method,omitempty"`
	// For EMV payments, the results of the cardholder verification. The result can be
	// `SUCCESS`, `FAILURE`, or `UNKNOWN`.
	VerificationResults *string `json:"verification_results,omitempty" url:"verification_results,omitempty"`
	// The statement description sent to the card networks.
	//
	// Note: The actual statement description varies and is likely to be truncated and appended with
	// additional information on a per issuer basis.
	StatementDescription *string `json:"statement_description,omitempty" url:"statement_description,omitempty"`
	// **Deprecated**: Use `Payment.device_details` instead.
	//
	// Details about the device that took the payment.
	DeviceDetails *DeviceDetails `json:"device_details,omitempty" url:"device_details,omitempty"`
	// The timeline for card payments.
	CardPaymentTimeline *CardPaymentTimeline `json:"card_payment_timeline,omitempty" url:"card_payment_timeline,omitempty"`
	// Whether the card must be physically present for the payment to
	// be refunded. If set to `true`, the card must be present.
	RefundRequiresCardPresence *bool `json:"refund_requires_card_presence,omitempty" url:"refund_requires_card_presence,omitempty"`
	// Information about errors encountered during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CardPaymentDetails) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CardPaymentDetails) UnmarshalJSON(data []byte) error {
	type unmarshaler CardPaymentDetails
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CardPaymentDetails(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CardPaymentDetails) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// The timeline for card payments.
type CardPaymentTimeline struct {
	// The timestamp when the payment was authorized, in RFC 3339 format.
	AuthorizedAt *string `json:"authorized_at,omitempty" url:"authorized_at,omitempty"`
	// The timestamp when the payment was captured, in RFC 3339 format.
	CapturedAt *string `json:"captured_at,omitempty" url:"captured_at,omitempty"`
	// The timestamp when the payment was voided, in RFC 3339 format.
	VoidedAt *string `json:"voided_at,omitempty" url:"voided_at,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CardPaymentTimeline) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CardPaymentTimeline) UnmarshalJSON(data []byte) error {
	type unmarshaler CardPaymentTimeline
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CardPaymentTimeline(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CardPaymentTimeline) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Indicates a card's prepaid type, such as `NOT_PREPAID` or `PREPAID`.
type CardPrepaidType string

const (
	CardPrepaidTypeUnknownPrepaidType CardPrepaidType = "UNKNOWN_PREPAID_TYPE"
	CardPrepaidTypeNotPrepaid         CardPrepaidType = "NOT_PREPAID"
	CardPrepaidTypePrepaid            CardPrepaidType = "PREPAID"
)

func NewCardPrepaidTypeFromString(s string) (CardPrepaidType, error) {
	switch s {
	case "UNKNOWN_PREPAID_TYPE":
		return CardPrepaidTypeUnknownPrepaidType, nil
	case "NOT_PREPAID":
		return CardPrepaidTypeNotPrepaid, nil
	case "PREPAID":
		return CardPrepaidTypePrepaid, nil
	}
	var t CardPrepaidType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CardPrepaidType) Ptr() *CardPrepaidType {
	return &c
}

// Indicates a card's type, such as `CREDIT` or `DEBIT`.
type CardType string

const (
	CardTypeUnknownCardType CardType = "UNKNOWN_CARD_TYPE"
	CardTypeCredit          CardType = "CREDIT"
	CardTypeDebit           CardType = "DEBIT"
)

func NewCardTypeFromString(s string) (CardType, error) {
	switch s {
	case "UNKNOWN_CARD_TYPE":
		return CardTypeUnknownCardType, nil
	case "CREDIT":
		return CardTypeCredit, nil
	case "DEBIT":
		return CardTypeDebit, nil
	}
	var t CardType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CardType) Ptr() *CardType {
	return &c
}

// Published when a Card is updated by the developer using the UpdateCard endpoint.
type CardUpdatedWebhook struct {
	// The ID of the target seller associated with the event.
	MerchantId *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The type of this event. The value is `"card.updated"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// A unique ID for the webhook event.
	EventId *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// The timestamp of when the webhook event was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The data associated with the event.
	Data *CardUpdatedWebhookData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CardUpdatedWebhook) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CardUpdatedWebhook) UnmarshalJSON(data []byte) error {
	type unmarshaler CardUpdatedWebhook
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CardUpdatedWebhook(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CardUpdatedWebhook) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CardUpdatedWebhookData struct {
	// The type of the event data object. The value is `"card"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// The ID of the event data object.
	Id *string `json:"id,omitempty" url:"id,omitempty"`
	// An object containing the updated card.
	Object *Card `json:"object,omitempty" url:"object,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CardUpdatedWebhookData) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CardUpdatedWebhookData) UnmarshalJSON(data []byte) error {
	type unmarshaler CardUpdatedWebhookData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CardUpdatedWebhookData(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CardUpdatedWebhookData) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CardUpdatedWebhookObject struct {
	// The updated card.
	Card *Card `json:"card,omitempty" url:"card,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CardUpdatedWebhookObject) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CardUpdatedWebhookObject) UnmarshalJSON(data []byte) error {
	type unmarshaler CardUpdatedWebhookObject
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CardUpdatedWebhookObject(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CardUpdatedWebhookObject) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Additional details about `WALLET` type payments with the `brand` of `CASH_APP`.
type CashAppDetails struct {
	// The name of the Cash App account holder.
	BuyerFullName *string `json:"buyer_full_name,omitempty" url:"buyer_full_name,omitempty"`
	// The country of the Cash App account holder, in ISO 3166-1-alpha-2 format.
	//
	// For possible values, see [Country](entity:Country).
	BuyerCountryCode *string `json:"buyer_country_code,omitempty" url:"buyer_country_code,omitempty"`
	// $Cashtag of the Cash App account holder.
	BuyerCashtag *string `json:"buyer_cashtag,omitempty" url:"buyer_cashtag,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CashAppDetails) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CashAppDetails) UnmarshalJSON(data []byte) error {
	type unmarshaler CashAppDetails
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CashAppDetails(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CashAppDetails) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CashDrawerDevice struct {
	// The device Square-issued ID
	Id *string `json:"id,omitempty" url:"id,omitempty"`
	// The device merchant-specified name.
	Name *string `json:"name,omitempty" url:"name,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CashDrawerDevice) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CashDrawerDevice) UnmarshalJSON(data []byte) error {
	type unmarshaler CashDrawerDevice
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CashDrawerDevice(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CashDrawerDevice) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// The types of events on a CashDrawerShift.
// Each event type represents an employee action on the actual cash drawer
// represented by a CashDrawerShift.
type CashDrawerEventType string

const (
	CashDrawerEventTypeNoSale                      CashDrawerEventType = "NO_SALE"
	CashDrawerEventTypeCashTenderPayment           CashDrawerEventType = "CASH_TENDER_PAYMENT"
	CashDrawerEventTypeOtherTenderPayment          CashDrawerEventType = "OTHER_TENDER_PAYMENT"
	CashDrawerEventTypeCashTenderCancelledPayment  CashDrawerEventType = "CASH_TENDER_CANCELLED_PAYMENT"
	CashDrawerEventTypeOtherTenderCancelledPayment CashDrawerEventType = "OTHER_TENDER_CANCELLED_PAYMENT"
	CashDrawerEventTypeCashTenderRefund            CashDrawerEventType = "CASH_TENDER_REFUND"
	CashDrawerEventTypeOtherTenderRefund           CashDrawerEventType = "OTHER_TENDER_REFUND"
	CashDrawerEventTypePaidIn                      CashDrawerEventType = "PAID_IN"
	CashDrawerEventTypePaidOut                     CashDrawerEventType = "PAID_OUT"
)

func NewCashDrawerEventTypeFromString(s string) (CashDrawerEventType, error) {
	switch s {
	case "NO_SALE":
		return CashDrawerEventTypeNoSale, nil
	case "CASH_TENDER_PAYMENT":
		return CashDrawerEventTypeCashTenderPayment, nil
	case "OTHER_TENDER_PAYMENT":
		return CashDrawerEventTypeOtherTenderPayment, nil
	case "CASH_TENDER_CANCELLED_PAYMENT":
		return CashDrawerEventTypeCashTenderCancelledPayment, nil
	case "OTHER_TENDER_CANCELLED_PAYMENT":
		return CashDrawerEventTypeOtherTenderCancelledPayment, nil
	case "CASH_TENDER_REFUND":
		return CashDrawerEventTypeCashTenderRefund, nil
	case "OTHER_TENDER_REFUND":
		return CashDrawerEventTypeOtherTenderRefund, nil
	case "PAID_IN":
		return CashDrawerEventTypePaidIn, nil
	case "PAID_OUT":
		return CashDrawerEventTypePaidOut, nil
	}
	var t CashDrawerEventType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CashDrawerEventType) Ptr() *CashDrawerEventType {
	return &c
}

// This model gives the details of a cash drawer shift.
// The cash_payment_money, cash_refund_money, cash_paid_in_money,
// and cash_paid_out_money fields are all computed by summing their respective
// event types.
type CashDrawerShift struct {
	// The shift unique ID.
	Id *string `json:"id,omitempty" url:"id,omitempty"`
	// The shift current state.
	// See [CashDrawerShiftState](#type-cashdrawershiftstate) for possible values
	State *CashDrawerShiftState `json:"state,omitempty" url:"state,omitempty"`
	// The time when the shift began, in ISO 8601 format.
	OpenedAt *string `json:"opened_at,omitempty" url:"opened_at,omitempty"`
	// The time when the shift ended, in ISO 8601 format.
	EndedAt *string `json:"ended_at,omitempty" url:"ended_at,omitempty"`
	// The time when the shift was closed, in ISO 8601 format.
	ClosedAt *string `json:"closed_at,omitempty" url:"closed_at,omitempty"`
	// The IDs of all employees that were logged into Square Point of Sale at any
	// point while the cash drawer shift was open.
	EmployeeIds []string `json:"employee_ids,omitempty" url:"employee_ids,omitempty"`
	// The ID of the employee that started the cash drawer shift.
	OpeningEmployeeId *string `json:"opening_employee_id,omitempty" url:"opening_employee_id,omitempty"`
	// The ID of the employee that ended the cash drawer shift.
	EndingEmployeeId *string `json:"ending_employee_id,omitempty" url:"ending_employee_id,omitempty"`
	// The ID of the employee that closed the cash drawer shift by auditing
	// the cash drawer contents.
	ClosingEmployeeId *string `json:"closing_employee_id,omitempty" url:"closing_employee_id,omitempty"`
	// The free-form text description of a cash drawer by an employee.
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	// The amount of money in the cash drawer at the start of the shift.
	// The amount must be greater than or equal to zero.
	OpenedCashMoney *Money `json:"opened_cash_money,omitempty" url:"opened_cash_money,omitempty"`
	// The amount of money added to the cash drawer from cash payments.
	// This is computed by summing all events with the types CASH_TENDER_PAYMENT and
	// CASH_TENDER_CANCELED_PAYMENT. The amount is always greater than or equal to
	// zero.
	CashPaymentMoney *Money `json:"cash_payment_money,omitempty" url:"cash_payment_money,omitempty"`
	// The amount of money removed from the cash drawer from cash refunds.
	// It is computed by summing the events of type CASH_TENDER_REFUND. The amount
	// is always greater than or equal to zero.
	CashRefundsMoney *Money `json:"cash_refunds_money,omitempty" url:"cash_refunds_money,omitempty"`
	// The amount of money added to the cash drawer for reasons other than cash
	// payments. It is computed by summing the events of type PAID_IN. The amount is
	// always greater than or equal to zero.
	CashPaidInMoney *Money `json:"cash_paid_in_money,omitempty" url:"cash_paid_in_money,omitempty"`
	// The amount of money removed from the cash drawer for reasons other than
	// cash refunds. It is computed by summing the events of type PAID_OUT. The amount
	// is always greater than or equal to zero.
	CashPaidOutMoney *Money `json:"cash_paid_out_money,omitempty" url:"cash_paid_out_money,omitempty"`
	// The amount of money that should be in the cash drawer at the end of the
	// shift, based on the shift's other money amounts.
	// This can be negative if employees have not correctly recorded all the events
	// on the cash drawer.
	// cash_paid_out_money is a summation of amounts from cash_payment_money (zero
	// or positive), cash_refunds_money (zero or negative), cash_paid_in_money (zero
	// or positive), and cash_paid_out_money (zero or negative) event types.
	ExpectedCashMoney *Money `json:"expected_cash_money,omitempty" url:"expected_cash_money,omitempty"`
	// The amount of money found in the cash drawer at the end of the shift
	// by an auditing employee. The amount should be positive.
	ClosedCashMoney *Money `json:"closed_cash_money,omitempty" url:"closed_cash_money,omitempty"`
	// The device running Square Point of Sale that was connected to the cash drawer.
	Device *CashDrawerDevice `json:"device,omitempty" url:"device,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CashDrawerShift) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CashDrawerShift) UnmarshalJSON(data []byte) error {
	type unmarshaler CashDrawerShift
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CashDrawerShift(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CashDrawerShift) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CashDrawerShiftEvent struct {
	// The unique ID of the event.
	Id *string `json:"id,omitempty" url:"id,omitempty"`
	// The ID of the employee that created the event.
	EmployeeId *string `json:"employee_id,omitempty" url:"employee_id,omitempty"`
	// The type of cash drawer shift event.
	// See [CashDrawerEventType](#type-cashdrawereventtype) for possible values
	EventType *CashDrawerEventType `json:"event_type,omitempty" url:"event_type,omitempty"`
	// The amount of money that was added to or removed from the cash drawer
	// in the event. The amount can be positive (for added money)
	// or zero (for other tender type payments). The addition or removal of money can be determined by
	// by the event type.
	EventMoney *Money `json:"event_money,omitempty" url:"event_money,omitempty"`
	// The event time in ISO 8601 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// An optional description of the event, entered by the employee that
	// created the event.
	Description *string `json:"description,omitempty" url:"description,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CashDrawerShiftEvent) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CashDrawerShiftEvent) UnmarshalJSON(data []byte) error {
	type unmarshaler CashDrawerShiftEvent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CashDrawerShiftEvent(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CashDrawerShiftEvent) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// The current state of a cash drawer shift.
type CashDrawerShiftState string

const (
	CashDrawerShiftStateOpen   CashDrawerShiftState = "OPEN"
	CashDrawerShiftStateEnded  CashDrawerShiftState = "ENDED"
	CashDrawerShiftStateClosed CashDrawerShiftState = "CLOSED"
)

func NewCashDrawerShiftStateFromString(s string) (CashDrawerShiftState, error) {
	switch s {
	case "OPEN":
		return CashDrawerShiftStateOpen, nil
	case "ENDED":
		return CashDrawerShiftStateEnded, nil
	case "CLOSED":
		return CashDrawerShiftStateClosed, nil
	}
	var t CashDrawerShiftState
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CashDrawerShiftState) Ptr() *CashDrawerShiftState {
	return &c
}

// The summary of a closed cash drawer shift.
// This model contains only the money counted to start a cash drawer shift, counted
// at the end of the shift, and the amount that should be in the drawer at shift
// end based on summing all cash drawer shift events.
type CashDrawerShiftSummary struct {
	// The shift unique ID.
	Id *string `json:"id,omitempty" url:"id,omitempty"`
	// The shift current state.
	// See [CashDrawerShiftState](#type-cashdrawershiftstate) for possible values
	State *CashDrawerShiftState `json:"state,omitempty" url:"state,omitempty"`
	// The shift start time in ISO 8601 format.
	OpenedAt *string `json:"opened_at,omitempty" url:"opened_at,omitempty"`
	// The shift end time in ISO 8601 format.
	EndedAt *string `json:"ended_at,omitempty" url:"ended_at,omitempty"`
	// The shift close time in ISO 8601 format.
	ClosedAt *string `json:"closed_at,omitempty" url:"closed_at,omitempty"`
	// An employee free-text description of a cash drawer shift.
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	// The amount of money in the cash drawer at the start of the shift. This
	// must be a positive amount.
	OpenedCashMoney *Money `json:"opened_cash_money,omitempty" url:"opened_cash_money,omitempty"`
	// The amount of money that should be in the cash drawer at the end of the
	// shift, based on the cash drawer events on the shift.
	// The amount is correct if all shift employees accurately recorded their
	// cash drawer shift events. Unrecorded events and events with the wrong amount
	// result in an incorrect expected_cash_money amount that can be negative.
	ExpectedCashMoney *Money `json:"expected_cash_money,omitempty" url:"expected_cash_money,omitempty"`
	// The amount of money found in the cash drawer at the end of the shift by
	// an auditing employee. The amount must be greater than or equal to zero.
	ClosedCashMoney *Money `json:"closed_cash_money,omitempty" url:"closed_cash_money,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CashDrawerShiftSummary) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CashDrawerShiftSummary) UnmarshalJSON(data []byte) error {
	type unmarshaler CashDrawerShiftSummary
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CashDrawerShiftSummary(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CashDrawerShiftSummary) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// A category to which a `CatalogItem` instance belongs.
type CatalogCategory struct {
	// The category name. This is a searchable attribute for use in applicable query filters, and its value length is of Unicode code points.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// The IDs of images associated with this `CatalogCategory` instance.
	// Currently these images are not displayed by Square, but are free to be displayed in 3rd party applications.
	ImageIds []string `json:"image_ids,omitempty" url:"image_ids,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CatalogCategory) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CatalogCategory) UnmarshalJSON(data []byte) error {
	type unmarshaler CatalogCategory
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CatalogCategory(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CatalogCategory) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Contains information defining a custom attribute. Custom attributes are
// intended to store additional information about a catalog object or to associate a
// catalog object with an entity in another system. Do not use custom attributes
// to store any sensitive information (personally identifiable information, card details, etc.).
// [Read more about custom attributes](https://developer.squareup.com/docs/catalog-api/add-custom-attributes)
type CatalogCustomAttributeDefinition struct {
	// The type of this custom attribute. Cannot be modified after creation.
	// Required.
	// See [CatalogCustomAttributeDefinitionType](#type-catalogcustomattributedefinitiontype) for possible values
	Type CatalogCustomAttributeDefinitionType `json:"type" url:"type"`
	// The name of this definition for API and seller-facing UI purposes.
	// The name must be unique within the (merchant, application) pair. Required.
	// May not be empty and may not exceed 255 characters. Can be modified after creation.
	Name string `json:"name" url:"name"`
	// Seller-oriented description of the meaning of this Custom Attribute,
	// any constraints that the seller should observe, etc. May be displayed as a tooltip in Square UIs.
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	// **Read only.** Contains information about the application that
	// created this custom attribute definition.
	SourceApplication *SourceApplication `json:"source_application,omitempty" url:"source_application,omitempty"`
	// The set of Catalog Object Types that this Custom Attribute may be applied to.
	// Currently, only `ITEM` and `ITEM_VARIATION` are allowed. At least one type must be included.
	// See [CatalogObjectType](#type-catalogobjecttype) for possible values
	AllowedObjectTypes []CatalogObjectType `json:"allowed_object_types,omitempty" url:"allowed_object_types,omitempty"`
	// The visibility of a custom attribute in seller-facing UIs (including Square Point
	// of Sale applications and Square Dashboard). May be modified.
	// See [CatalogCustomAttributeDefinitionSellerVisibility](#type-catalogcustomattributedefinitionsellervisibility) for possible values
	SellerVisibility *CatalogCustomAttributeDefinitionSellerVisibility `json:"seller_visibility,omitempty" url:"seller_visibility,omitempty"`
	// The visibility of a custom attribute to applications other than the application
	// that created the attribute.
	// See [CatalogCustomAttributeDefinitionAppVisibility](#type-catalogcustomattributedefinitionappvisibility) for possible values
	AppVisibility *CatalogCustomAttributeDefinitionAppVisibility `json:"app_visibility,omitempty" url:"app_visibility,omitempty"`
	// Optionally, populated when `type` = `STRING`, unset otherwise.
	StringConfig *CatalogCustomAttributeDefinitionStringConfig `json:"string_config,omitempty" url:"string_config,omitempty"`
	// Optionally, populated when `type` = `NUMBER`, unset otherwise.
	NumberConfig *CatalogCustomAttributeDefinitionNumberConfig `json:"number_config,omitempty" url:"number_config,omitempty"`
	// Populated when `type` is set to `SELECTION`, unset otherwise.
	SelectionConfig *CatalogCustomAttributeDefinitionSelectionConfig `json:"selection_config,omitempty" url:"selection_config,omitempty"`
	// The number of custom attributes that reference this
	// custom attribute definition. Set by the server in response to a ListCatalog
	// request with `include_counts` set to `true`. If the actual count is greater
	// than 100, `custom_attribute_usage_count` will be set to `100`.
	CustomAttributeUsageCount *int `json:"custom_attribute_usage_count,omitempty" url:"custom_attribute_usage_count,omitempty"`
	// The name of the desired custom attribute key that can be used to access
	// the custom attribute value on catalog objects. Cannot be modified after the
	// custom attribute definition has been created.
	// Must be between 1 and 60 characters, and may only contain the characters `[a-zA-Z0-9_-]`.
	Key *string `json:"key,omitempty" url:"key,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CatalogCustomAttributeDefinition) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CatalogCustomAttributeDefinition) UnmarshalJSON(data []byte) error {
	type unmarshaler CatalogCustomAttributeDefinition
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CatalogCustomAttributeDefinition(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CatalogCustomAttributeDefinition) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Defines the visibility of a custom attribute to applications other than their
// creating application.
type CatalogCustomAttributeDefinitionAppVisibility string

const (
	CatalogCustomAttributeDefinitionAppVisibilityAppVisibilityDoNotUse        CatalogCustomAttributeDefinitionAppVisibility = "APP_VISIBILITY_DO_NOT_USE"
	CatalogCustomAttributeDefinitionAppVisibilityAppVisibilityHidden          CatalogCustomAttributeDefinitionAppVisibility = "APP_VISIBILITY_HIDDEN"
	CatalogCustomAttributeDefinitionAppVisibilityAppVisibilityReadOnly        CatalogCustomAttributeDefinitionAppVisibility = "APP_VISIBILITY_READ_ONLY"
	CatalogCustomAttributeDefinitionAppVisibilityAppVisibilityReadWriteValues CatalogCustomAttributeDefinitionAppVisibility = "APP_VISIBILITY_READ_WRITE_VALUES"
)

func NewCatalogCustomAttributeDefinitionAppVisibilityFromString(s string) (CatalogCustomAttributeDefinitionAppVisibility, error) {
	switch s {
	case "APP_VISIBILITY_DO_NOT_USE":
		return CatalogCustomAttributeDefinitionAppVisibilityAppVisibilityDoNotUse, nil
	case "APP_VISIBILITY_HIDDEN":
		return CatalogCustomAttributeDefinitionAppVisibilityAppVisibilityHidden, nil
	case "APP_VISIBILITY_READ_ONLY":
		return CatalogCustomAttributeDefinitionAppVisibilityAppVisibilityReadOnly, nil
	case "APP_VISIBILITY_READ_WRITE_VALUES":
		return CatalogCustomAttributeDefinitionAppVisibilityAppVisibilityReadWriteValues, nil
	}
	var t CatalogCustomAttributeDefinitionAppVisibility
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CatalogCustomAttributeDefinitionAppVisibility) Ptr() *CatalogCustomAttributeDefinitionAppVisibility {
	return &c
}

type CatalogCustomAttributeDefinitionNumberConfig struct {
	// An integer between 0 and 5 that represents the maximum number of
	// positions allowed after the decimal in number custom attribute values
	// For example:
	//
	// - if the precision is 0, the quantity can be 1, 2, 3, etc.
	// - if the precision is 1, the quantity can be 0.1, 0.2, etc.
	// - if the precision is 2, the quantity can be 0.01, 0.12, etc.
	//
	// Default: 5
	Precision *int `json:"precision,omitempty" url:"precision,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CatalogCustomAttributeDefinitionNumberConfig) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CatalogCustomAttributeDefinitionNumberConfig) UnmarshalJSON(data []byte) error {
	type unmarshaler CatalogCustomAttributeDefinitionNumberConfig
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CatalogCustomAttributeDefinitionNumberConfig(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CatalogCustomAttributeDefinitionNumberConfig) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Configuration associated with `SELECTION`-type custom attribute definitions.
type CatalogCustomAttributeDefinitionSelectionConfig struct {
	// The maximum number of selections that can be set. The maximum value for this
	// attribute is 100. The default value is 1. The value can be modified, but changing the value will not
	// affect existing custom attribute values on objects. Clients need to
	// handle custom attributes with more selected values than allowed by this limit.
	MaxAllowedSelections *int `json:"max_allowed_selections,omitempty" url:"max_allowed_selections,omitempty"`
	// The set of valid `CatalogCustomAttributeSelections`. Up to a maximum of 100
	// selections can be defined. Can be modified.
	AllowedSelections []*CatalogCustomAttributeDefinitionSelectionConfigCustomAttributeSelection `json:"allowed_selections,omitempty" url:"allowed_selections,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CatalogCustomAttributeDefinitionSelectionConfig) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CatalogCustomAttributeDefinitionSelectionConfig) UnmarshalJSON(data []byte) error {
	type unmarshaler CatalogCustomAttributeDefinitionSelectionConfig
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CatalogCustomAttributeDefinitionSelectionConfig(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CatalogCustomAttributeDefinitionSelectionConfig) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// A named selection for this `SELECTION`-type custom attribute definition.
type CatalogCustomAttributeDefinitionSelectionConfigCustomAttributeSelection struct {
	// Unique ID set by Square.
	Uid *string `json:"uid,omitempty" url:"uid,omitempty"`
	// Selection name, unique within `allowed_selections`.
	Name string `json:"name" url:"name"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CatalogCustomAttributeDefinitionSelectionConfigCustomAttributeSelection) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CatalogCustomAttributeDefinitionSelectionConfigCustomAttributeSelection) UnmarshalJSON(data []byte) error {
	type unmarshaler CatalogCustomAttributeDefinitionSelectionConfigCustomAttributeSelection
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CatalogCustomAttributeDefinitionSelectionConfigCustomAttributeSelection(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CatalogCustomAttributeDefinitionSelectionConfigCustomAttributeSelection) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Defines the visibility of a custom attribute to sellers in Square
// client applications, Square APIs or in Square UIs (including Square Point
// of Sale applications and Square Dashboard).
type CatalogCustomAttributeDefinitionSellerVisibility string

const (
	CatalogCustomAttributeDefinitionSellerVisibilitySellerVisibilityDoNotUse        CatalogCustomAttributeDefinitionSellerVisibility = "SELLER_VISIBILITY_DO_NOT_USE"
	CatalogCustomAttributeDefinitionSellerVisibilitySellerVisibilityHidden          CatalogCustomAttributeDefinitionSellerVisibility = "SELLER_VISIBILITY_HIDDEN"
	CatalogCustomAttributeDefinitionSellerVisibilitySellerVisibilityReadWriteValues CatalogCustomAttributeDefinitionSellerVisibility = "SELLER_VISIBILITY_READ_WRITE_VALUES"
)

func NewCatalogCustomAttributeDefinitionSellerVisibilityFromString(s string) (CatalogCustomAttributeDefinitionSellerVisibility, error) {
	switch s {
	case "SELLER_VISIBILITY_DO_NOT_USE":
		return CatalogCustomAttributeDefinitionSellerVisibilitySellerVisibilityDoNotUse, nil
	case "SELLER_VISIBILITY_HIDDEN":
		return CatalogCustomAttributeDefinitionSellerVisibilitySellerVisibilityHidden, nil
	case "SELLER_VISIBILITY_READ_WRITE_VALUES":
		return CatalogCustomAttributeDefinitionSellerVisibilitySellerVisibilityReadWriteValues, nil
	}
	var t CatalogCustomAttributeDefinitionSellerVisibility
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CatalogCustomAttributeDefinitionSellerVisibility) Ptr() *CatalogCustomAttributeDefinitionSellerVisibility {
	return &c
}

// Configuration associated with Custom Attribute Definitions of type `STRING`.
type CatalogCustomAttributeDefinitionStringConfig struct {
	// If true, each Custom Attribute instance associated with this Custom Attribute
	// Definition must have a unique value within the seller's catalog. For
	// example, this may be used for a value like a SKU that should not be
	// duplicated within a seller's catalog. May not be modified after the
	// definition has been created.
	EnforceUniqueness *bool `json:"enforce_uniqueness,omitempty" url:"enforce_uniqueness,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CatalogCustomAttributeDefinitionStringConfig) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CatalogCustomAttributeDefinitionStringConfig) UnmarshalJSON(data []byte) error {
	type unmarshaler CatalogCustomAttributeDefinitionStringConfig
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CatalogCustomAttributeDefinitionStringConfig(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CatalogCustomAttributeDefinitionStringConfig) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Defines the possible types for a custom attribute.
type CatalogCustomAttributeDefinitionType string

const (
	CatalogCustomAttributeDefinitionTypeAttributeTypeDoNotUse CatalogCustomAttributeDefinitionType = "ATTRIBUTE_TYPE_DO_NOT_USE"
	CatalogCustomAttributeDefinitionTypeString                CatalogCustomAttributeDefinitionType = "STRING"
	CatalogCustomAttributeDefinitionTypeInteger               CatalogCustomAttributeDefinitionType = "INTEGER"
	CatalogCustomAttributeDefinitionTypeBoolean               CatalogCustomAttributeDefinitionType = "BOOLEAN"
	CatalogCustomAttributeDefinitionTypeNumber                CatalogCustomAttributeDefinitionType = "NUMBER"
	CatalogCustomAttributeDefinitionTypeSelection             CatalogCustomAttributeDefinitionType = "SELECTION"
	CatalogCustomAttributeDefinitionTypeStringInt             CatalogCustomAttributeDefinitionType = "STRING_INT"
	CatalogCustomAttributeDefinitionTypeTokenInt              CatalogCustomAttributeDefinitionType = "TOKEN_INT"
)

func NewCatalogCustomAttributeDefinitionTypeFromString(s string) (CatalogCustomAttributeDefinitionType, error) {
	switch s {
	case "ATTRIBUTE_TYPE_DO_NOT_USE":
		return CatalogCustomAttributeDefinitionTypeAttributeTypeDoNotUse, nil
	case "STRING":
		return CatalogCustomAttributeDefinitionTypeString, nil
	case "INTEGER":
		return CatalogCustomAttributeDefinitionTypeInteger, nil
	case "BOOLEAN":
		return CatalogCustomAttributeDefinitionTypeBoolean, nil
	case "NUMBER":
		return CatalogCustomAttributeDefinitionTypeNumber, nil
	case "SELECTION":
		return CatalogCustomAttributeDefinitionTypeSelection, nil
	case "STRING_INT":
		return CatalogCustomAttributeDefinitionTypeStringInt, nil
	case "TOKEN_INT":
		return CatalogCustomAttributeDefinitionTypeTokenInt, nil
	}
	var t CatalogCustomAttributeDefinitionType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CatalogCustomAttributeDefinitionType) Ptr() *CatalogCustomAttributeDefinitionType {
	return &c
}

// An instance of a custom attribute. Custom attributes can be defined and
// added to `ITEM` and `ITEM_VARIATION` type catalog objects.
// [Read more about custom attributes](https://developer.squareup.com/docs/catalog-api/add-custom-attributes).
type CatalogCustomAttributeValue struct {
	// The name of the custom attribute.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// The string value of the custom attribute. Populated if `type` = `STRING`.
	StringValue *string `json:"string_value,omitempty" url:"string_value,omitempty"`
	// The id of the [CatalogCustomAttributeDefinition](entity:CatalogCustomAttributeDefinition) this value belongs to.
	CustomAttributeDefinitionId *string `json:"custom_attribute_definition_id,omitempty" url:"custom_attribute_definition_id,omitempty"`
	// A copy of type from the associated `CatalogCustomAttributeDefinition`.
	// See [CatalogCustomAttributeDefinitionType](#type-catalogcustomattributedefinitiontype) for possible values
	Type *CatalogCustomAttributeDefinitionType `json:"type,omitempty" url:"type,omitempty"`
	// Populated if `type` = `NUMBER`. Contains a string
	// representation of a decimal number, using a `.` as the decimal separator.
	NumberValue *string `json:"number_value,omitempty" url:"number_value,omitempty"`
	// A `true` or `false` value. Populated if `type` = `BOOLEAN`.
	BooleanValue *bool `json:"boolean_value,omitempty" url:"boolean_value,omitempty"`
	// One or more choices from `allowed_selections`. Populated if `type` = `SELECTION`.
	SelectionUidValues []string `json:"selection_uid_values,omitempty" url:"selection_uid_values,omitempty"`
	// A copy of key from the associated `CatalogCustomAttributeDefinition`.
	Key *string `json:"key,omitempty" url:"key,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CatalogCustomAttributeValue) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CatalogCustomAttributeValue) UnmarshalJSON(data []byte) error {
	type unmarshaler CatalogCustomAttributeValue
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CatalogCustomAttributeValue(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CatalogCustomAttributeValue) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// A discount applicable to items.
type CatalogDiscount struct {
	// The discount name. This is a searchable attribute for use in applicable query filters, and its value length is of Unicode code points.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// Indicates whether the discount is a fixed amount or percentage, or entered at the time of sale.
	// See [CatalogDiscountType](#type-catalogdiscounttype) for possible values
	DiscountType *CatalogDiscountType `json:"discount_type,omitempty" url:"discount_type,omitempty"`
	// The percentage of the discount as a string representation of a decimal number, using a `.` as the decimal
	// separator and without a `%` sign. A value of `7.5` corresponds to `7.5%`. Specify a percentage of `0` if `discount_type`
	// is `VARIABLE_PERCENTAGE`.
	//
	// Do not use this field for amount-based or variable discounts.
	Percentage *string `json:"percentage,omitempty" url:"percentage,omitempty"`
	// The amount of the discount. Specify an amount of `0` if `discount_type` is `VARIABLE_AMOUNT`.
	//
	// Do not use this field for percentage-based or variable discounts.
	AmountMoney *Money `json:"amount_money,omitempty" url:"amount_money,omitempty"`
	// Indicates whether a mobile staff member needs to enter their PIN to apply the
	// discount to a payment in the Square Point of Sale app.
	PinRequired *bool `json:"pin_required,omitempty" url:"pin_required,omitempty"`
	// The color of the discount display label in the Square Point of Sale app. This must be a valid hex color code.
	LabelColor *string `json:"label_color,omitempty" url:"label_color,omitempty"`
	// Indicates whether this discount should reduce the price used to calculate tax.
	//
	// Most discounts should use `MODIFY_TAX_BASIS`. However, in some circumstances taxes must
	// be calculated based on an item's price, ignoring a particular discount. For example,
	// in many US jurisdictions, a manufacturer coupon or instant rebate reduces the price a
	// customer pays but does not reduce the sale price used to calculate how much sales tax is
	// due. In this case, the discount representing that manufacturer coupon should have
	// `DO_NOT_MODIFY_TAX_BASIS` for this field.
	//
	// If you are unsure whether you need to use this field, consult your tax professional.
	// See [CatalogDiscountModifyTaxBasis](#type-catalogdiscountmodifytaxbasis) for possible values
	ModifyTaxBasis *CatalogDiscountModifyTaxBasis `json:"modify_tax_basis,omitempty" url:"modify_tax_basis,omitempty"`
	// For a percentage discount, the maximum absolute value of the discount. For example, if a
	// 50% discount has a `maximum_amount_money` of $20, a $100 purchase will yield a $20 discount,
	// not a $50 discount.
	MaximumAmountMoney *Money `json:"maximum_amount_money,omitempty" url:"maximum_amount_money,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CatalogDiscount) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CatalogDiscount) UnmarshalJSON(data []byte) error {
	type unmarshaler CatalogDiscount
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CatalogDiscount(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CatalogDiscount) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CatalogDiscountModifyTaxBasis string

const (
	CatalogDiscountModifyTaxBasisModifyTaxBasis      CatalogDiscountModifyTaxBasis = "MODIFY_TAX_BASIS"
	CatalogDiscountModifyTaxBasisDoNotModifyTaxBasis CatalogDiscountModifyTaxBasis = "DO_NOT_MODIFY_TAX_BASIS"
)

func NewCatalogDiscountModifyTaxBasisFromString(s string) (CatalogDiscountModifyTaxBasis, error) {
	switch s {
	case "MODIFY_TAX_BASIS":
		return CatalogDiscountModifyTaxBasisModifyTaxBasis, nil
	case "DO_NOT_MODIFY_TAX_BASIS":
		return CatalogDiscountModifyTaxBasisDoNotModifyTaxBasis, nil
	}
	var t CatalogDiscountModifyTaxBasis
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CatalogDiscountModifyTaxBasis) Ptr() *CatalogDiscountModifyTaxBasis {
	return &c
}

// How to apply a CatalogDiscount to a CatalogItem.
type CatalogDiscountType string

const (
	CatalogDiscountTypeFixedPercentage    CatalogDiscountType = "FIXED_PERCENTAGE"
	CatalogDiscountTypeFixedAmount        CatalogDiscountType = "FIXED_AMOUNT"
	CatalogDiscountTypeVariablePercentage CatalogDiscountType = "VARIABLE_PERCENTAGE"
	CatalogDiscountTypeVariableAmount     CatalogDiscountType = "VARIABLE_AMOUNT"
)

func NewCatalogDiscountTypeFromString(s string) (CatalogDiscountType, error) {
	switch s {
	case "FIXED_PERCENTAGE":
		return CatalogDiscountTypeFixedPercentage, nil
	case "FIXED_AMOUNT":
		return CatalogDiscountTypeFixedAmount, nil
	case "VARIABLE_PERCENTAGE":
		return CatalogDiscountTypeVariablePercentage, nil
	case "VARIABLE_AMOUNT":
		return CatalogDiscountTypeVariableAmount, nil
	}
	var t CatalogDiscountType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CatalogDiscountType) Ptr() *CatalogDiscountType {
	return &c
}

// A mapping between a temporary client-supplied ID and a permanent server-generated ID.
//
// When calling [UpsertCatalogObject](api-endpoint:Catalog-UpsertCatalogObject) or
// [BatchUpsertCatalogObjects](api-endpoint:Catalog-BatchUpsertCatalogObjects) to
// create a [CatalogObject](entity:CatalogObject) instance, you can supply
// a temporary ID for the to-be-created object, especially when the object is to be referenced
// elsewhere in the same request body. This temporary ID can be any string unique within
// the call, but must be prefixed by "#".
//
// After the request is submitted and the object created, a permanent server-generated ID is assigned
// to the new object. The permanent ID is unique across the Square catalog.
type CatalogIdMapping struct {
	// The client-supplied temporary `#`-prefixed ID for a new `CatalogObject`.
	ClientObjectId *string `json:"client_object_id,omitempty" url:"client_object_id,omitempty"`
	// The permanent ID for the CatalogObject created by the server.
	ObjectId *string `json:"object_id,omitempty" url:"object_id,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CatalogIdMapping) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CatalogIdMapping) UnmarshalJSON(data []byte) error {
	type unmarshaler CatalogIdMapping
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CatalogIdMapping(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CatalogIdMapping) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// An image file to use in Square catalogs. It can be associated with
// `CatalogItem`, `CatalogItemVariation`, `CatalogCategory`, and `CatalogModifierList` objects.
// Only the images on items and item variations are exposed in Dashboard.
// Only the first image on an item is displayed in Square Point of Sale (SPOS).
// Images on items and variations are displayed through Square Online Store.
// Images on other object types are for use by 3rd party application developers.
type CatalogImage struct {
	// The internal name to identify this image in calls to the Square API.
	// This is a searchable attribute for use in applicable query filters
	// using the [SearchCatalogObjects](api-endpoint:Catalog-SearchCatalogObjects).
	// It is not unique and should not be shown in a buyer facing context.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// The URL of this image, generated by Square after an image is uploaded
	// using the [CreateCatalogImage](api-endpoint:Catalog-CreateCatalogImage) endpoint.
	// To modify the image, use the UpdateCatalogImage endpoint. Do not change the URL field.
	Url *string `json:"url,omitempty" url:"url,omitempty"`
	// A caption that describes what is shown in the image. Displayed in the
	// Square Online Store. This is a searchable attribute for use in applicable query filters
	// using the [SearchCatalogObjects](api-endpoint:Catalog-SearchCatalogObjects).
	Caption *string `json:"caption,omitempty" url:"caption,omitempty"`
	// The immutable order ID for this image object created by the Photo Studio service in Square Online Store.
	PhotoStudioOrderId *string `json:"photo_studio_order_id,omitempty" url:"photo_studio_order_id,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CatalogImage) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CatalogImage) UnmarshalJSON(data []byte) error {
	type unmarshaler CatalogImage
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CatalogImage(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CatalogImage) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CatalogInfoRequest struct {
	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CatalogInfoRequest) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CatalogInfoRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler CatalogInfoRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CatalogInfoRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CatalogInfoRequest) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CatalogInfoResponseLimits struct {
	// The maximum number of objects that may appear within a single batch in a
	// `/v2/catalog/batch-upsert` request.
	BatchUpsertMaxObjectsPerBatch *int `json:"batch_upsert_max_objects_per_batch,omitempty" url:"batch_upsert_max_objects_per_batch,omitempty"`
	// The maximum number of objects that may appear across all batches in a
	// `/v2/catalog/batch-upsert` request.
	BatchUpsertMaxTotalObjects *int `json:"batch_upsert_max_total_objects,omitempty" url:"batch_upsert_max_total_objects,omitempty"`
	// The maximum number of object IDs that may appear in a `/v2/catalog/batch-retrieve`
	// request.
	BatchRetrieveMaxObjectIds *int `json:"batch_retrieve_max_object_ids,omitempty" url:"batch_retrieve_max_object_ids,omitempty"`
	// The maximum number of results that may be returned in a page of a
	// `/v2/catalog/search` response.
	SearchMaxPageLimit *int `json:"search_max_page_limit,omitempty" url:"search_max_page_limit,omitempty"`
	// The maximum number of object IDs that may be included in a single
	// `/v2/catalog/batch-delete` request.
	BatchDeleteMaxObjectIds *int `json:"batch_delete_max_object_ids,omitempty" url:"batch_delete_max_object_ids,omitempty"`
	// The maximum number of item IDs that may be included in a single
	// `/v2/catalog/update-item-taxes` request.
	UpdateItemTaxesMaxItemIds *int `json:"update_item_taxes_max_item_ids,omitempty" url:"update_item_taxes_max_item_ids,omitempty"`
	// The maximum number of tax IDs to be enabled that may be included in a single
	// `/v2/catalog/update-item-taxes` request.
	UpdateItemTaxesMaxTaxesToEnable *int `json:"update_item_taxes_max_taxes_to_enable,omitempty" url:"update_item_taxes_max_taxes_to_enable,omitempty"`
	// The maximum number of tax IDs to be disabled that may be included in a single
	// `/v2/catalog/update-item-taxes` request.
	UpdateItemTaxesMaxTaxesToDisable *int `json:"update_item_taxes_max_taxes_to_disable,omitempty" url:"update_item_taxes_max_taxes_to_disable,omitempty"`
	// The maximum number of item IDs that may be included in a single
	// `/v2/catalog/update-item-modifier-lists` request.
	UpdateItemModifierListsMaxItemIds *int `json:"update_item_modifier_lists_max_item_ids,omitempty" url:"update_item_modifier_lists_max_item_ids,omitempty"`
	// The maximum number of modifier list IDs to be enabled that may be included in
	// a single `/v2/catalog/update-item-modifier-lists` request.
	UpdateItemModifierListsMaxModifierListsToEnable *int `json:"update_item_modifier_lists_max_modifier_lists_to_enable,omitempty" url:"update_item_modifier_lists_max_modifier_lists_to_enable,omitempty"`
	// The maximum number of modifier list IDs to be disabled that may be included in
	// a single `/v2/catalog/update-item-modifier-lists` request.
	UpdateItemModifierListsMaxModifierListsToDisable *int `json:"update_item_modifier_lists_max_modifier_lists_to_disable,omitempty" url:"update_item_modifier_lists_max_modifier_lists_to_disable,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CatalogInfoResponseLimits) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CatalogInfoResponseLimits) UnmarshalJSON(data []byte) error {
	type unmarshaler CatalogInfoResponseLimits
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CatalogInfoResponseLimits(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CatalogInfoResponseLimits) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// A [CatalogObject](entity:CatalogObject) instance of the `ITEM` type, also referred to as an item, in the catalog.
type CatalogItem struct {
	// The item's name. This is a searchable attribute for use in applicable query filters, its value must not be empty, and the length is of Unicode code points.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// The item's description. This is a searchable attribute for use in applicable query filters, and its value length is of Unicode code points.
	//
	// Deprecated at 2022-07-20, this field is planned to retire in 6 months. You should migrate to use `description_html` to set the description
	// of the [CatalogItem](entity:CatalogItem) instance. The `description` and `description_html` field values are kept in sync. If you try to
	// set the both fields, the `description_html` text value overwrites the `description` value. Updates in one field are also reflected in the other,
	// except for when you use an early version before Square API 2022-07-20 and `description_html` is set to blank, setting the `description` value to null
	// does not nullify `description_html`.
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	// The text of the item's display label in the Square Point of Sale app. Only up to the first five characters of the string are used.
	// This attribute is searchable, and its value length is of Unicode code points.
	Abbreviation *string `json:"abbreviation,omitempty" url:"abbreviation,omitempty"`
	// The color of the item's display label in the Square Point of Sale app. This must be a valid hex color code.
	LabelColor *string `json:"label_color,omitempty" url:"label_color,omitempty"`
	// If `true`, the item can be added to shipping orders from the merchant's online store.
	AvailableOnline *bool `json:"available_online,omitempty" url:"available_online,omitempty"`
	// If `true`, the item can be added to pickup orders from the merchant's online store.
	AvailableForPickup *bool `json:"available_for_pickup,omitempty" url:"available_for_pickup,omitempty"`
	// If `true`, the item can be added to electronically fulfilled orders from the merchant's online store.
	AvailableElectronically *bool `json:"available_electronically,omitempty" url:"available_electronically,omitempty"`
	// The ID of the item's category, if any.
	CategoryId *string `json:"category_id,omitempty" url:"category_id,omitempty"`
	// A set of IDs indicating the taxes enabled for
	// this item. When updating an item, any taxes listed here will be added to the item.
	// Taxes may also be added to or deleted from an item using `UpdateItemTaxes`.
	TaxIds []string `json:"tax_ids,omitempty" url:"tax_ids,omitempty"`
	// A set of `CatalogItemModifierListInfo` objects
	// representing the modifier lists that apply to this item, along with the overrides and min
	// and max limits that are specific to this item. Modifier lists
	// may also be added to or deleted from an item using `UpdateItemModifierLists`.
	ModifierListInfo []*CatalogItemModifierListInfo `json:"modifier_list_info,omitempty" url:"modifier_list_info,omitempty"`
	// **Retired**. The URL of an image representing this item. Retired
	// in favor of `image_id` in [CatalogObject](entity:CatalogObject).
	ImageUrl *string `json:"image_url,omitempty" url:"image_url,omitempty"`
	// A list of [CatalogItemVariation](entity:CatalogItemVariation) objects for this item. An item must have
	// at least one variation.
	Variations []*CatalogObject `json:"variations,omitempty" url:"variations,omitempty"`
	// The product type of the item. May not be changed once an item has been created.
	//
	// Only items of product type `REGULAR` or `APPOINTMENTS_SERVICE` may be created by this API; items with other product
	// types are read-only.
	// See [CatalogItemProductType](#type-catalogitemproducttype) for possible values
	ProductType *CatalogItemProductType `json:"product_type,omitempty" url:"product_type,omitempty"`
	// If `false`, the Square Point of Sale app will present the `CatalogItem`'s
	// details screen immediately, allowing the merchant to choose `CatalogModifier`s
	// before adding the item to the cart. This is the default behavior.
	//
	// If `true`, the Square Point of Sale app will immediately add the item to the cart with the pre-selected
	// modifiers, and merchants can edit modifiers by drilling down onto the item's details.
	//
	// Third-party clients are encouraged to implement similar behaviors.
	SkipModifierScreen *bool `json:"skip_modifier_screen,omitempty" url:"skip_modifier_screen,omitempty"`
	// List of item options IDs for this item. Used to manage and group item
	// variations in a specified order.
	//
	// Maximum: 6 item options.
	ItemOptions []*CatalogItemOptionForItem `json:"item_options,omitempty" url:"item_options,omitempty"`
	// The IDs of images associated with this `CatalogItem` instance.
	// These images will be shown to customers in Square Online Store.
	// The first image will show up as the icon for this item in POS.
	ImageIds []string `json:"image_ids,omitempty" url:"image_ids,omitempty"`
	// A name to sort the item by. If this name is unspecified, namely, the `sort_name` field is absent, the regular `name` field is used for sorting.
	//
	// It is currently supported for sellers of the Japanese locale only.
	SortName *string `json:"sort_name,omitempty" url:"sort_name,omitempty"`
	// The item's description as expressed in valid HTML elements. The length of this field value, including those of HTML tags,
	// is of Unicode points. With application query filters, the text values of the HTML elements and attributes are searchable. Invalid or
	// unsupported HTML elements or attributes are ignored.
	//
	// Supported HTML elements include:
	//
	// - `a`: Link. Supports linking to website URLs, email address, and telephone numbers.
	// - `b`, `strong`: Bold text
	// - `br`: Line break
	// - `code`: Computer code
	// - `div`: Section
	// - `h1-h6`: Headings
	// - `i`, `em`: Italics
	// - `li`: List element
	// - `ol`: Numbered list
	// - `p`: Paragraph
	// - `ul`: Bullet list
	// - `u`: Underline
	//
	// Supported HTML attributes include:
	//
	// - `align`: Alignment of the text content
	// - `href`: Link destination
	// - `rel`: Relationship between link's target and source
	// - `target`: Place to open the linked document
	DescriptionHtml *string `json:"description_html,omitempty" url:"description_html,omitempty"`
	// A server-generated plaintext version of the `description_html` field, without formatting tags.
	DescriptionPlaintext *string `json:"description_plaintext,omitempty" url:"description_plaintext,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CatalogItem) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CatalogItem) UnmarshalJSON(data []byte) error {
	type unmarshaler CatalogItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CatalogItem(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CatalogItem) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Options to control the properties of a `CatalogModifierList` applied to a `CatalogItem` instance.
type CatalogItemModifierListInfo struct {
	// The ID of the `CatalogModifierList` controlled by this `CatalogModifierListInfo`.
	ModifierListId string `json:"modifier_list_id" url:"modifier_list_id"`
	// A set of `CatalogModifierOverride` objects that override whether a given `CatalogModifier` is enabled by default.
	ModifierOverrides []*CatalogModifierOverride `json:"modifier_overrides,omitempty" url:"modifier_overrides,omitempty"`
	// If 0 or larger, the smallest number of `CatalogModifier`s that must be selected from this `CatalogModifierList`.
	MinSelectedModifiers *int `json:"min_selected_modifiers,omitempty" url:"min_selected_modifiers,omitempty"`
	// If 0 or larger, the largest number of `CatalogModifier`s that can be selected from this `CatalogModifierList`.
	MaxSelectedModifiers *int `json:"max_selected_modifiers,omitempty" url:"max_selected_modifiers,omitempty"`
	// If `true`, enable this `CatalogModifierList`. The default value is `true`.
	Enabled *bool `json:"enabled,omitempty" url:"enabled,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CatalogItemModifierListInfo) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CatalogItemModifierListInfo) UnmarshalJSON(data []byte) error {
	type unmarshaler CatalogItemModifierListInfo
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CatalogItemModifierListInfo(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CatalogItemModifierListInfo) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// A group of variations for a `CatalogItem`.
type CatalogItemOption struct {
	// The item option's display name for the seller. Must be unique across
	// all item options. This is a searchable attribute for use in applicable query filters.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// The item option's display name for the customer. This is a searchable attribute for use in applicable query filters.
	DisplayName *string `json:"display_name,omitempty" url:"display_name,omitempty"`
	// The item option's human-readable description. Displayed in the Square
	// Point of Sale app for the seller and in the Online Store or on receipts for
	// the buyer. This is a searchable attribute for use in applicable query filters.
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	// If true, display colors for entries in `values` when present.
	ShowColors *bool `json:"show_colors,omitempty" url:"show_colors,omitempty"`
	// A list of CatalogObjects containing the
	// `CatalogItemOptionValue`s for this item.
	Values []*CatalogObject `json:"values,omitempty" url:"values,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CatalogItemOption) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CatalogItemOption) UnmarshalJSON(data []byte) error {
	type unmarshaler CatalogItemOption
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CatalogItemOption(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CatalogItemOption) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// An option that can be assigned to an item.
// For example, a t-shirt item may offer a color option or a size option.
type CatalogItemOptionForItem struct {
	// The unique id of the item option, used to form the dimensions of the item option matrix in a specified order.
	ItemOptionId *string `json:"item_option_id,omitempty" url:"item_option_id,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CatalogItemOptionForItem) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CatalogItemOptionForItem) UnmarshalJSON(data []byte) error {
	type unmarshaler CatalogItemOptionForItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CatalogItemOptionForItem(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CatalogItemOptionForItem) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// An enumerated value that can link a
// `CatalogItemVariation` to an item option as one of
// its item option values.
type CatalogItemOptionValue struct {
	// Unique ID of the associated item option.
	ItemOptionId *string `json:"item_option_id,omitempty" url:"item_option_id,omitempty"`
	// Name of this item option value. This is a searchable attribute for use in applicable query filters.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// A human-readable description for the option value. This is a searchable attribute for use in applicable query filters.
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	// The HTML-supported hex color for the item option (e.g., "#ff8d4e85").
	// Only displayed if `show_colors` is enabled on the parent `ItemOption`. When
	// left unset, `color` defaults to white ("#ffffff") when `show_colors` is
	// enabled on the parent `ItemOption`.
	Color *string `json:"color,omitempty" url:"color,omitempty"`
	// Determines where this option value appears in a list of option values.
	Ordinal *int `json:"ordinal,omitempty" url:"ordinal,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CatalogItemOptionValue) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CatalogItemOptionValue) UnmarshalJSON(data []byte) error {
	type unmarshaler CatalogItemOptionValue
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CatalogItemOptionValue(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CatalogItemOptionValue) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// A `CatalogItemOptionValue` links an item variation to an item option as
// an item option value. For example, a t-shirt item may offer a color option and
// a size option. An item option value would represent each variation of t-shirt:
// For example, "Color:Red, Size:Small" or "Color:Blue, Size:Medium".
type CatalogItemOptionValueForItemVariation struct {
	// The unique id of an item option.
	ItemOptionId *string `json:"item_option_id,omitempty" url:"item_option_id,omitempty"`
	// The unique id of the selected value for the item option.
	ItemOptionValueId *string `json:"item_option_value_id,omitempty" url:"item_option_value_id,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CatalogItemOptionValueForItemVariation) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CatalogItemOptionValueForItemVariation) UnmarshalJSON(data []byte) error {
	type unmarshaler CatalogItemOptionValueForItemVariation
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CatalogItemOptionValueForItemVariation(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CatalogItemOptionValueForItemVariation) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// An item variation, representing a product for sale, in the Catalog object model. Each [item](entity:CatalogItem) must have at least one
// item variation and can have at most 250 item variations.
//
// An item variation can be sellable, stockable, or both if it has a unit of measure for its count for the sold number of the variation, the stocked
// number of the variation, or both. For example, when a variation representing wine is stocked and sold by the bottle, the variation is both
// stockable and sellable. But when a variation of the wine is sold by the glass, the sold units cannot be used as a measure of the stocked units. This by-the-glass
// variation is sellable, but not stockable. To accurately keep track of the wine's inventory count at any time, the sellable count must be
// converted to stockable count. Typically, the seller defines this unit conversion. For example, 1 bottle equals 5 glasses. The Square API exposes
// the `stockable_conversion` property on the variation to specify the conversion. Thus, when two glasses of the wine are sold, the sellable count
// decreases by 2, and the stockable count automatically decreases by 0.4 bottle according to the conversion.
type CatalogItemVariation struct {
	// The ID of the `CatalogItem` associated with this item variation.
	ItemId *string `json:"item_id,omitempty" url:"item_id,omitempty"`
	// The item variation's name. This is a searchable attribute for use in applicable query filters, and its value length is of Unicode code points.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// The item variation's SKU, if any. This is a searchable attribute for use in applicable query filters.
	Sku *string `json:"sku,omitempty" url:"sku,omitempty"`
	// The universal product code (UPC) of the item variation, if any. This is a searchable attribute for use in applicable query filters.
	//
	// The value of this attribute should be a number of 12-14 digits long. This restriction is enforced on the Square Seller Dashboard,
	// Square Point of Sale or Retail Point of Sale apps, where this attribute shows in the GTIN field. If a non-compliant UPC value is assigned
	// to this attribute using the API, the value is not editable on the Seller Dashboard, Square Point of Sale or Retail Point of Sale apps
	// unless it is updated to fit the expected format.
	Upc *string `json:"upc,omitempty" url:"upc,omitempty"`
	// The order in which this item variation should be displayed. This value is read-only. On writes, the ordinal
	// for each item variation within a parent `CatalogItem` is set according to the item variations's
	// position. On reads, the value is not guaranteed to be sequential or unique.
	Ordinal *int `json:"ordinal,omitempty" url:"ordinal,omitempty"`
	// Indicates whether the item variation's price is fixed or determined at the time
	// of sale.
	// See [CatalogPricingType](#type-catalogpricingtype) for possible values
	PricingType *CatalogPricingType `json:"pricing_type,omitempty" url:"pricing_type,omitempty"`
	// The item variation's price, if fixed pricing is used.
	PriceMoney *Money `json:"price_money,omitempty" url:"price_money,omitempty"`
	// Per-location price and inventory overrides.
	LocationOverrides []*ItemVariationLocationOverrides `json:"location_overrides,omitempty" url:"location_overrides,omitempty"`
	// If `true`, inventory tracking is active for the variation.
	TrackInventory *bool `json:"track_inventory,omitempty" url:"track_inventory,omitempty"`
	// Indicates whether the item variation displays an alert when its inventory quantity is less than or equal
	// to its `inventory_alert_threshold`.
	// See [InventoryAlertType](#type-inventoryalerttype) for possible values
	InventoryAlertType *InventoryAlertType `json:"inventory_alert_type,omitempty" url:"inventory_alert_type,omitempty"`
	// If the inventory quantity for the variation is less than or equal to this value and `inventory_alert_type`
	// is `LOW_QUANTITY`, the variation displays an alert in the merchant dashboard.
	//
	// This value is always an integer.
	InventoryAlertThreshold *int64 `json:"inventory_alert_threshold,omitempty" url:"inventory_alert_threshold,omitempty"`
	// Arbitrary user metadata to associate with the item variation. This attribute value length is of Unicode code points.
	UserData *string `json:"user_data,omitempty" url:"user_data,omitempty"`
	// If the `CatalogItem` that owns this item variation is of type
	// `APPOINTMENTS_SERVICE`, then this is the duration of the service in milliseconds. For
	// example, a 30 minute appointment would have the value `1800000`, which is equal to
	// 30 (minutes) _ 60 (seconds per minute) _ 1000 (milliseconds per second).
	ServiceDuration *int64 `json:"service_duration,omitempty" url:"service_duration,omitempty"`
	// If the `CatalogItem` that owns this item variation is of type
	// `APPOINTMENTS_SERVICE`, a bool representing whether this service is available for booking.
	AvailableForBooking *bool `json:"available_for_booking,omitempty" url:"available_for_booking,omitempty"`
	// List of item option values associated with this item variation. Listed
	// in the same order as the item options of the parent item.
	ItemOptionValues []*CatalogItemOptionValueForItemVariation `json:"item_option_values,omitempty" url:"item_option_values,omitempty"`
	// ID of the ‘CatalogMeasurementUnit’ that is used to measure the quantity
	// sold of this item variation. If left unset, the item will be sold in
	// whole quantities.
	MeasurementUnitId *string `json:"measurement_unit_id,omitempty" url:"measurement_unit_id,omitempty"`
	// Whether this variation can be sold. The inventory count of a sellable variation indicates
	// the number of units available for sale. When a variation is both stockable and sellable,
	// its sellable inventory count can be smaller than or equal to its stockable count.
	Sellable *bool `json:"sellable,omitempty" url:"sellable,omitempty"`
	// Whether stock is counted directly on this variation (TRUE) or only on its components (FALSE).
	// When a variation is both stockable and sellable, the inventory count of a stockable variation keeps track of the number of units of this variation in stock
	// and is not an indicator of the number of units of the variation that can be sold.
	Stockable *bool `json:"stockable,omitempty" url:"stockable,omitempty"`
	// The IDs of images associated with this `CatalogItemVariation` instance.
	// These images will be shown to customers in Square Online Store.
	ImageIds []string `json:"image_ids,omitempty" url:"image_ids,omitempty"`
	// Tokens of employees that can perform the service represented by this variation. Only valid for
	// variations of type `APPOINTMENTS_SERVICE`.
	TeamMemberIds []string `json:"team_member_ids,omitempty" url:"team_member_ids,omitempty"`
	// The unit conversion rule, as prescribed by the [CatalogStockConversion](entity:CatalogStockConversion) type,
	// that describes how this non-stockable (i.e., sellable/receivable) item variation is converted
	// to/from the stockable item variation sharing the same parent item. With the stock conversion,
	// you can accurately track inventory when an item variation is sold in one unit, but stocked in
	// another unit.
	StockableConversion *CatalogStockConversion `json:"stockable_conversion,omitempty" url:"stockable_conversion,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CatalogItemVariation) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CatalogItemVariation) UnmarshalJSON(data []byte) error {
	type unmarshaler CatalogItemVariation
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CatalogItemVariation(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CatalogItemVariation) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Represents the unit used to measure a `CatalogItemVariation` and
// specifies the precision for decimal quantities.
type CatalogMeasurementUnit struct {
	// Indicates the unit used to measure the quantity of a catalog item variation.
	MeasurementUnit *MeasurementUnit `json:"measurement_unit,omitempty" url:"measurement_unit,omitempty"`
	// An integer between 0 and 5 that represents the maximum number of
	// positions allowed after the decimal in quantities measured with this unit.
	// For example:
	//
	// - if the precision is 0, the quantity can be 1, 2, 3, etc.
	// - if the precision is 1, the quantity can be 0.1, 0.2, etc.
	// - if the precision is 2, the quantity can be 0.01, 0.12, etc.
	//
	// Default: 3
	Precision *int `json:"precision,omitempty" url:"precision,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CatalogMeasurementUnit) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CatalogMeasurementUnit) UnmarshalJSON(data []byte) error {
	type unmarshaler CatalogMeasurementUnit
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CatalogMeasurementUnit(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CatalogMeasurementUnit) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// A modifier applicable to items at the time of sale.
type CatalogModifier struct {
	// The modifier name. This is a searchable attribute for use in applicable query filters, and its value length is of Unicode code points.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// The modifier price.
	PriceMoney *Money `json:"price_money,omitempty" url:"price_money,omitempty"`
	// Determines where this `CatalogModifier` appears in the `CatalogModifierList`.
	Ordinal *int `json:"ordinal,omitempty" url:"ordinal,omitempty"`
	// The ID of the `CatalogModifierList` associated with this modifier.
	ModifierListId *string `json:"modifier_list_id,omitempty" url:"modifier_list_id,omitempty"`
	// The IDs of images associated with this `CatalogModifier` instance.
	// Currently these images are not displayed by Square, but are free to be displayed in 3rd party applications.
	ImageIds []string `json:"image_ids,omitempty" url:"image_ids,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CatalogModifier) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CatalogModifier) UnmarshalJSON(data []byte) error {
	type unmarshaler CatalogModifier
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CatalogModifier(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CatalogModifier) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// A list of modifiers applicable to items at the time of sale.
//
// For example, a "Condiments" modifier list applicable to a "Hot Dog" item
// may contain "Ketchup", "Mustard", and "Relish" modifiers.
// Use the `selection_type` field to specify whether or not multiple selections from
// the modifier list are allowed.
type CatalogModifierList struct {
	// The name for the `CatalogModifierList` instance. This is a searchable attribute for use in applicable query filters, and its value length is of Unicode code points.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// Determines where this modifier list appears in a list of `CatalogModifierList` values.
	Ordinal *int `json:"ordinal,omitempty" url:"ordinal,omitempty"`
	// Indicates whether multiple options from the modifier list
	// can be applied to a single `CatalogItem`.
	// See [CatalogModifierListSelectionType](#type-catalogmodifierlistselectiontype) for possible values
	SelectionType *CatalogModifierListSelectionType `json:"selection_type,omitempty" url:"selection_type,omitempty"`
	// The options included in the `CatalogModifierList`.
	// You must include at least one `CatalogModifier`.
	// Each CatalogObject must have type `MODIFIER` and contain
	// `CatalogModifier` data.
	Modifiers []*CatalogObject `json:"modifiers,omitempty" url:"modifiers,omitempty"`
	// The IDs of images associated with this `CatalogModifierList` instance.
	// Currently these images are not displayed by Square, but are free to be displayed in 3rd party applications.
	ImageIds []string `json:"image_ids,omitempty" url:"image_ids,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CatalogModifierList) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CatalogModifierList) UnmarshalJSON(data []byte) error {
	type unmarshaler CatalogModifierList
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CatalogModifierList(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CatalogModifierList) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Indicates whether a CatalogModifierList supports multiple selections.
type CatalogModifierListSelectionType string

const (
	CatalogModifierListSelectionTypeSingle   CatalogModifierListSelectionType = "SINGLE"
	CatalogModifierListSelectionTypeMultiple CatalogModifierListSelectionType = "MULTIPLE"
)

func NewCatalogModifierListSelectionTypeFromString(s string) (CatalogModifierListSelectionType, error) {
	switch s {
	case "SINGLE":
		return CatalogModifierListSelectionTypeSingle, nil
	case "MULTIPLE":
		return CatalogModifierListSelectionTypeMultiple, nil
	}
	var t CatalogModifierListSelectionType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CatalogModifierListSelectionType) Ptr() *CatalogModifierListSelectionType {
	return &c
}

// Options to control how to override the default behavior of the specified modifier.
type CatalogModifierOverride struct {
	// The ID of the `CatalogModifier` whose default behavior is being overridden.
	ModifierId string `json:"modifier_id" url:"modifier_id"`
	// If `true`, this `CatalogModifier` should be selected by default for this `CatalogItem`.
	OnByDefault *bool `json:"on_by_default,omitempty" url:"on_by_default,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CatalogModifierOverride) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CatalogModifierOverride) UnmarshalJSON(data []byte) error {
	type unmarshaler CatalogModifierOverride
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CatalogModifierOverride(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CatalogModifierOverride) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// The wrapper object for the catalog entries of a given object type.
//
// Depending on the `type` attribute value, a `CatalogObject` instance assumes a type-specific data to yield the corresponding type of catalog object.
//
// For example, if `type=ITEM`, the `CatalogObject` instance must have the ITEM-specific data set on the `item_data` attribute. The resulting `CatalogObject` instance is also a `CatalogItem` instance.
//
// In general, if `type=<OBJECT_TYPE>`, the `CatalogObject` instance must have the `<OBJECT_TYPE>`-specific data set on the `<object_type>_data` attribute. The resulting `CatalogObject` instance is also a `Catalog<ObjectType>` instance.
//
// For a more detailed discussion of the Catalog data model, please see the
// [Design a Catalog](https://developer.squareup.com/docs/catalog-api/design-a-catalog) guide.
type CatalogObject struct {
	// The type of this object. Each object type has expected
	// properties expressed in a structured format within its corresponding `*_data` field below.
	// See [CatalogObjectType](#type-catalogobjecttype) for possible values
	Type CatalogObjectType `json:"type" url:"type"`
	// An identifier to reference this object in the catalog. When a new `CatalogObject`
	// is inserted, the client should set the id to a temporary identifier starting with
	// a "`#`" character. Other objects being inserted or updated within the same request
	// may use this identifier to refer to the new object.
	//
	// When the server receives the new object, it will supply a unique identifier that
	// replaces the temporary identifier for all future references.
	Id string `json:"id" url:"id"`
	// Last modification [timestamp](https://developer.squareup.com/docs/build-basics/working-with-dates) in RFC 3339 format, e.g., `"2016-08-15T23:59:33.123Z"`
	// would indicate the UTC time (denoted by `Z`) of August 15, 2016 at 23:59:33 and 123 milliseconds.
	UpdatedAt *string `json:"updated_at,omitempty" url:"updated_at,omitempty"`
	// The version of the object. When updating an object, the version supplied
	// must match the version in the database, otherwise the write will be rejected as conflicting.
	Version *int64 `json:"version,omitempty" url:"version,omitempty"`
	// If `true`, the object has been deleted from the database. Must be `false` for new objects
	// being inserted. When deleted, the `updated_at` field will equal the deletion time.
	IsDeleted *bool `json:"is_deleted,omitempty" url:"is_deleted,omitempty"`
	// A map (key-value pairs) of application-defined custom attribute values. The value of a key-value pair
	// is a [CatalogCustomAttributeValue](entity:CatalogCustomAttributeValue) object. The key is the `key` attribute
	// value defined in the associated [CatalogCustomAttributeDefinition](entity:CatalogCustomAttributeDefinition)
	// object defined by the application making the request.
	//
	// If the `CatalogCustomAttributeDefinition` object is
	// defined by another application, the `CatalogCustomAttributeDefinition`'s key attribute value is prefixed by
	// the defining application ID. For example, if the `CatalogCustomAttributeDefinition` has a `key` attribute of
	// `"cocoa_brand"` and the defining application ID is `"abcd1234"`, the key in the map is `"abcd1234:cocoa_brand"`
	// if the application making the request is different from the application defining the custom attribute definition.
	// Otherwise, the key used in the map is simply `"cocoa_brand"`.
	//
	// Application-defined custom attributes are set at a global (location-independent) level.
	// Custom attribute values are intended to store additional information about a catalog object
	// or associations with an entity in another system. Do not use custom attributes
	// to store any sensitive information (personally identifiable information, card details, etc.).
	CustomAttributeValues map[string]*CatalogCustomAttributeValue `json:"custom_attribute_values,omitempty" url:"custom_attribute_values,omitempty"`
	// The Connect v1 IDs for this object at each location where it is present, where they
	// differ from the object's Connect V2 ID. The field will only be present for objects that
	// have been created or modified by legacy APIs.
	CatalogV1Ids []*CatalogV1Id `json:"catalog_v1_ids,omitempty" url:"catalog_v1_ids,omitempty"`
	// If `true`, this object is present at all locations (including future locations), except where specified in
	// the `absent_at_location_ids` field. If `false`, this object is not present at any locations (including future locations),
	// except where specified in the `present_at_location_ids` field. If not specified, defaults to `true`.
	PresentAtAllLocations *bool `json:"present_at_all_locations,omitempty" url:"present_at_all_locations,omitempty"`
	// A list of locations where the object is present, even if `present_at_all_locations` is `false`.
	// This can include locations that are deactivated.
	PresentAtLocationIds []string `json:"present_at_location_ids,omitempty" url:"present_at_location_ids,omitempty"`
	// A list of locations where the object is not present, even if `present_at_all_locations` is `true`.
	// This can include locations that are deactivated.
	AbsentAtLocationIds []string `json:"absent_at_location_ids,omitempty" url:"absent_at_location_ids,omitempty"`
	// Identifies the `CatalogImage` attached to this `CatalogObject`.
	ImageId *string `json:"image_id,omitempty" url:"image_id,omitempty"`
	// Structured data for a `CatalogItem`, set for CatalogObjects of type `ITEM`.
	ItemData *CatalogItem `json:"item_data,omitempty" url:"item_data,omitempty"`
	// Structured data for a `CatalogCategory`, set for CatalogObjects of type `CATEGORY`.
	CategoryData *CatalogCategory `json:"category_data,omitempty" url:"category_data,omitempty"`
	// Structured data for a `CatalogItemVariation`, set for CatalogObjects of type `ITEM_VARIATION`.
	ItemVariationData *CatalogItemVariation `json:"item_variation_data,omitempty" url:"item_variation_data,omitempty"`
	// Structured data for a `CatalogTax`, set for CatalogObjects of type `TAX`.
	TaxData *CatalogTax `json:"tax_data,omitempty" url:"tax_data,omitempty"`
	// Structured data for a `CatalogDiscount`, set for CatalogObjects of type `DISCOUNT`.
	DiscountData *CatalogDiscount `json:"discount_data,omitempty" url:"discount_data,omitempty"`
	// Structured data for a `CatalogModifierList`, set for CatalogObjects of type `MODIFIER_LIST`.
	ModifierListData *CatalogModifierList `json:"modifier_list_data,omitempty" url:"modifier_list_data,omitempty"`
	// Structured data for a `CatalogModifier`, set for CatalogObjects of type `MODIFIER`.
	ModifierData *CatalogModifier `json:"modifier_data,omitempty" url:"modifier_data,omitempty"`
	// Structured data for a `CatalogTimePeriod`, set for CatalogObjects of type `TIME_PERIOD`.
	TimePeriodData *CatalogTimePeriod `json:"time_period_data,omitempty" url:"time_period_data,omitempty"`
	// Structured data for a `CatalogProductSet`, set for CatalogObjects of type `PRODUCT_SET`.
	ProductSetData *CatalogProductSet `json:"product_set_data,omitempty" url:"product_set_data,omitempty"`
	// Structured data for a `CatalogPricingRule`, set for CatalogObjects of type `PRICING_RULE`.
	// A `CatalogPricingRule` object often works with a `CatalogProductSet` object or a `CatalogTimePeriod` object.
	PricingRuleData *CatalogPricingRule `json:"pricing_rule_data,omitempty" url:"pricing_rule_data,omitempty"`
	// Structured data for a `CatalogImage`, set for CatalogObjects of type `IMAGE`.
	ImageData *CatalogImage `json:"image_data,omitempty" url:"image_data,omitempty"`
	// Structured data for a `CatalogMeasurementUnit`, set for CatalogObjects of type `MEASUREMENT_UNIT`.
	MeasurementUnitData *CatalogMeasurementUnit `json:"measurement_unit_data,omitempty" url:"measurement_unit_data,omitempty"`
	// Structured data for a `CatalogSubscriptionPlan`, set for CatalogObjects of type `SUBSCRIPTION_PLAN`.
	SubscriptionPlanData *CatalogSubscriptionPlan `json:"subscription_plan_data,omitempty" url:"subscription_plan_data,omitempty"`
	// Structured data for a `CatalogItemOption`, set for CatalogObjects of type `ITEM_OPTION`.
	ItemOptionData *CatalogItemOption `json:"item_option_data,omitempty" url:"item_option_data,omitempty"`
	// Structured data for a `CatalogItemOptionValue`, set for CatalogObjects of type `ITEM_OPTION_VAL`.
	ItemOptionValueData *CatalogItemOptionValue `json:"item_option_value_data,omitempty" url:"item_option_value_data,omitempty"`
	// Structured data for a `CatalogCustomAttributeDefinition`, set for CatalogObjects of type `CUSTOM_ATTRIBUTE_DEFINITION`.
	CustomAttributeDefinitionData *CatalogCustomAttributeDefinition `json:"custom_attribute_definition_data,omitempty" url:"custom_attribute_definition_data,omitempty"`
	// Structured data for a `CatalogQuickAmountsSettings`, set for CatalogObjects of type `QUICK_AMOUNTS_SETTINGS`.
	QuickAmountsSettingsData *CatalogQuickAmountsSettings `json:"quick_amounts_settings_data,omitempty" url:"quick_amounts_settings_data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CatalogObject) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CatalogObject) UnmarshalJSON(data []byte) error {
	type unmarshaler CatalogObject
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CatalogObject(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CatalogObject) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// A reference to a Catalog object at a specific version. In general this is
// used as an entry point into a graph of catalog objects, where the objects exist
// at a specific version.
type CatalogObjectReference struct {
	// The ID of the referenced object.
	ObjectId *string `json:"object_id,omitempty" url:"object_id,omitempty"`
	// The version of the object.
	CatalogVersion *int64 `json:"catalog_version,omitempty" url:"catalog_version,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CatalogObjectReference) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CatalogObjectReference) UnmarshalJSON(data []byte) error {
	type unmarshaler CatalogObjectReference
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CatalogObjectReference(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CatalogObjectReference) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Defines how discounts are automatically applied to a set of items that match the pricing rule
// during the active time period.
type CatalogPricingRule struct {
	// User-defined name for the pricing rule. For example, "Buy one get one
	// free" or "10% off".
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// A list of unique IDs for the catalog time periods when
	// this pricing rule is in effect. If left unset, the pricing rule is always
	// in effect.
	TimePeriodIds []string `json:"time_period_ids,omitempty" url:"time_period_ids,omitempty"`
	// Unique ID for the `CatalogDiscount` to take off
	// the price of all matched items.
	DiscountId *string `json:"discount_id,omitempty" url:"discount_id,omitempty"`
	// Unique ID for the `CatalogProductSet` that will be matched by this rule. A match rule
	// matches within the entire cart, and can match multiple times. This field will always be set.
	MatchProductsId *string `json:"match_products_id,omitempty" url:"match_products_id,omitempty"`
	// **Deprecated**: Please use the `exclude_products_id` field to apply
	// an exclude set instead. Exclude sets allow better control over quantity
	// ranges and offer more flexibility for which matched items receive a discount.
	//
	// `CatalogProductSet` to apply the pricing to.
	// An apply rule matches within the subset of the cart that fits the match rules (the match set).
	// An apply rule can only match once in the match set.
	// If not supplied, the pricing will be applied to all products in the match set.
	// Other products retain their base price, or a price generated by other rules.
	ApplyProductsId *string `json:"apply_products_id,omitempty" url:"apply_products_id,omitempty"`
	// `CatalogProductSet` to exclude from the pricing rule.
	// An exclude rule matches within the subset of the cart that fits the match rules (the match set).
	// An exclude rule can only match once in the match set.
	// If not supplied, the pricing will be applied to all products in the match set.
	// Other products retain their base price, or a price generated by other rules.
	ExcludeProductsId *string `json:"exclude_products_id,omitempty" url:"exclude_products_id,omitempty"`
	// Represents the date the Pricing Rule is valid from. Represented in RFC 3339 full-date format (YYYY-MM-DD).
	ValidFromDate *string `json:"valid_from_date,omitempty" url:"valid_from_date,omitempty"`
	// Represents the local time the pricing rule should be valid from. Represented in RFC 3339 partial-time format
	// (HH:MM:SS). Partial seconds will be truncated.
	ValidFromLocalTime *string `json:"valid_from_local_time,omitempty" url:"valid_from_local_time,omitempty"`
	// Represents the date the Pricing Rule is valid until. Represented in RFC 3339 full-date format (YYYY-MM-DD).
	ValidUntilDate *string `json:"valid_until_date,omitempty" url:"valid_until_date,omitempty"`
	// Represents the local time the pricing rule should be valid until. Represented in RFC 3339 partial-time format
	// (HH:MM:SS). Partial seconds will be truncated.
	ValidUntilLocalTime *string `json:"valid_until_local_time,omitempty" url:"valid_until_local_time,omitempty"`
	// If an `exclude_products_id` was given, controls which subset of matched
	// products is excluded from any discounts.
	//
	// Default value: `LEAST_EXPENSIVE`
	// See [ExcludeStrategy](#type-excludestrategy) for possible values
	ExcludeStrategy *ExcludeStrategy `json:"exclude_strategy,omitempty" url:"exclude_strategy,omitempty"`
	// The minimum order subtotal (before discounts or taxes are applied)
	// that must be met before this rule may be applied.
	MinimumOrderSubtotalMoney *Money `json:"minimum_order_subtotal_money,omitempty" url:"minimum_order_subtotal_money,omitempty"`
	// A list of IDs of customer groups, the members of which are eligible for discounts specified in this pricing rule.
	// Notice that a group ID is generated by the Customers API.
	// If this field is not set, the specified discount applies to matched products sold to anyone whether the buyer
	// has a customer profile created or not. If this `customer_group_ids_any` field is set, the specified discount
	// applies only to matched products sold to customers belonging to the specified customer groups.
	CustomerGroupIdsAny []string `json:"customer_group_ids_any,omitempty" url:"customer_group_ids_any,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CatalogPricingRule) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CatalogPricingRule) UnmarshalJSON(data []byte) error {
	type unmarshaler CatalogPricingRule
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CatalogPricingRule(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CatalogPricingRule) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Indicates whether the price of a CatalogItemVariation should be entered manually at the time of sale.
type CatalogPricingType string

const (
	CatalogPricingTypeFixedPricing    CatalogPricingType = "FIXED_PRICING"
	CatalogPricingTypeVariablePricing CatalogPricingType = "VARIABLE_PRICING"
)

func NewCatalogPricingTypeFromString(s string) (CatalogPricingType, error) {
	switch s {
	case "FIXED_PRICING":
		return CatalogPricingTypeFixedPricing, nil
	case "VARIABLE_PRICING":
		return CatalogPricingTypeVariablePricing, nil
	}
	var t CatalogPricingType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CatalogPricingType) Ptr() *CatalogPricingType {
	return &c
}

// Represents a collection of catalog objects for the purpose of applying a
// `PricingRule`. Including a catalog object will include all of its subtypes.
// For example, including a category in a product set will include all of its
// items and associated item variations in the product set. Including an item in
// a product set will also include its item variations.
type CatalogProductSet struct {
	// User-defined name for the product set. For example, "Clearance Items"
	// or "Winter Sale Items".
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// Unique IDs for any `CatalogObject` included in this product set. Any
	// number of these catalog objects can be in an order for a pricing rule to apply.
	//
	// This can be used with `product_ids_all` in a parent `CatalogProductSet` to
	// match groups of products for a bulk discount, such as a discount for an
	// entree and side combo.
	//
	// Only one of `product_ids_all`, `product_ids_any`, or `all_products` can be set.
	//
	// Max: 500 catalog object IDs.
	ProductIdsAny []string `json:"product_ids_any,omitempty" url:"product_ids_any,omitempty"`
	// Unique IDs for any `CatalogObject` included in this product set.
	// All objects in this set must be included in an order for a pricing rule to apply.
	//
	// Only one of `product_ids_all`, `product_ids_any`, or `all_products` can be set.
	//
	// Max: 500 catalog object IDs.
	ProductIdsAll []string `json:"product_ids_all,omitempty" url:"product_ids_all,omitempty"`
	// If set, there must be exactly this many items from `products_any` or `products_all`
	// in the cart for the discount to apply.
	//
	// Cannot be combined with either `quantity_min` or `quantity_max`.
	QuantityExact *int64 `json:"quantity_exact,omitempty" url:"quantity_exact,omitempty"`
	// If set, there must be at least this many items from `products_any` or `products_all`
	// in a cart for the discount to apply. See `quantity_exact`. Defaults to 0 if
	// `quantity_exact`, `quantity_min` and `quantity_max` are all unspecified.
	QuantityMin *int64 `json:"quantity_min,omitempty" url:"quantity_min,omitempty"`
	// If set, the pricing rule will apply to a maximum of this many items from
	// `products_any` or `products_all`.
	QuantityMax *int64 `json:"quantity_max,omitempty" url:"quantity_max,omitempty"`
	// If set to `true`, the product set will include every item in the catalog.
	// Only one of `product_ids_all`, `product_ids_any`, or `all_products` can be set.
	AllProducts *bool `json:"all_products,omitempty" url:"all_products,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CatalogProductSet) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CatalogProductSet) UnmarshalJSON(data []byte) error {
	type unmarshaler CatalogProductSet
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CatalogProductSet(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CatalogProductSet) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// The query filter to return the search result by exact match of the specified attribute name and value.
type CatalogQueryExact struct {
	// The name of the attribute to be searched. Matching of the attribute name is exact.
	AttributeName string `json:"attribute_name" url:"attribute_name"`
	// The desired value of the search attribute. Matching of the attribute value is case insensitive and can be partial.
	// For example, if a specified value of "sma", objects with the named attribute value of "Small", "small" are both matched.
	AttributeValue string `json:"attribute_value" url:"attribute_value"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CatalogQueryExact) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CatalogQueryExact) UnmarshalJSON(data []byte) error {
	type unmarshaler CatalogQueryExact
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CatalogQueryExact(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CatalogQueryExact) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// The query filter to return the item variations containing the specified item option value IDs.
type CatalogQueryItemVariationsForItemOptionValues struct {
	// A set of `CatalogItemOptionValue` IDs to be used to find associated
	// `CatalogItemVariation`s. All ItemVariations that contain all of the given
	// Item Option Values (in any order) will be returned.
	ItemOptionValueIds []string `json:"item_option_value_ids,omitempty" url:"item_option_value_ids,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CatalogQueryItemVariationsForItemOptionValues) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CatalogQueryItemVariationsForItemOptionValues) UnmarshalJSON(data []byte) error {
	type unmarshaler CatalogQueryItemVariationsForItemOptionValues
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CatalogQueryItemVariationsForItemOptionValues(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CatalogQueryItemVariationsForItemOptionValues) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// The query filter to return the items containing the specified item option IDs.
type CatalogQueryItemsForItemOptions struct {
	// A set of `CatalogItemOption` IDs to be used to find associated
	// `CatalogItem`s. All Items that contain all of the given Item Options (in any order)
	// will be returned.
	ItemOptionIds []string `json:"item_option_ids,omitempty" url:"item_option_ids,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CatalogQueryItemsForItemOptions) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CatalogQueryItemsForItemOptions) UnmarshalJSON(data []byte) error {
	type unmarshaler CatalogQueryItemsForItemOptions
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CatalogQueryItemsForItemOptions(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CatalogQueryItemsForItemOptions) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// The query filter to return the items containing the specified modifier list IDs.
type CatalogQueryItemsForModifierList struct {
	// A set of `CatalogModifierList` IDs to be used to find associated `CatalogItem`s.
	ModifierListIds []string `json:"modifier_list_ids,omitempty" url:"modifier_list_ids,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CatalogQueryItemsForModifierList) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CatalogQueryItemsForModifierList) UnmarshalJSON(data []byte) error {
	type unmarshaler CatalogQueryItemsForModifierList
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CatalogQueryItemsForModifierList(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CatalogQueryItemsForModifierList) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// The query filter to return the items containing the specified tax IDs.
type CatalogQueryItemsForTax struct {
	// A set of `CatalogTax` IDs to be used to find associated `CatalogItem`s.
	TaxIds []string `json:"tax_ids,omitempty" url:"tax_ids,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CatalogQueryItemsForTax) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CatalogQueryItemsForTax) UnmarshalJSON(data []byte) error {
	type unmarshaler CatalogQueryItemsForTax
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CatalogQueryItemsForTax(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CatalogQueryItemsForTax) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// The query filter to return the search result whose named attribute values are prefixed by the specified attribute value.
type CatalogQueryPrefix struct {
	// The name of the attribute to be searched.
	AttributeName string `json:"attribute_name" url:"attribute_name"`
	// The desired prefix of the search attribute value.
	AttributePrefix string `json:"attribute_prefix" url:"attribute_prefix"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CatalogQueryPrefix) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CatalogQueryPrefix) UnmarshalJSON(data []byte) error {
	type unmarshaler CatalogQueryPrefix
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CatalogQueryPrefix(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CatalogQueryPrefix) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// The query filter to return the search result whose named attribute values fall between the specified range.
type CatalogQueryRange struct {
	// The name of the attribute to be searched.
	AttributeName string `json:"attribute_name" url:"attribute_name"`
	// The desired minimum value for the search attribute (inclusive).
	AttributeMinValue *int64 `json:"attribute_min_value,omitempty" url:"attribute_min_value,omitempty"`
	// The desired maximum value for the search attribute (inclusive).
	AttributeMaxValue *int64 `json:"attribute_max_value,omitempty" url:"attribute_max_value,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CatalogQueryRange) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CatalogQueryRange) UnmarshalJSON(data []byte) error {
	type unmarshaler CatalogQueryRange
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CatalogQueryRange(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CatalogQueryRange) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// The query filter to return the search result(s) by exact match of the specified `attribute_name` and any of
// the `attribute_values`.
type CatalogQuerySet struct {
	// The name of the attribute to be searched. Matching of the attribute name is exact.
	AttributeName string `json:"attribute_name" url:"attribute_name"`
	// The desired values of the search attribute. Matching of the attribute values is exact and case insensitive.
	// A maximum of 250 values may be searched in a request.
	AttributeValues []string `json:"attribute_values,omitempty" url:"attribute_values,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CatalogQuerySet) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CatalogQuerySet) UnmarshalJSON(data []byte) error {
	type unmarshaler CatalogQuerySet
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CatalogQuerySet(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CatalogQuerySet) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// The query expression to specify the key to sort search results.
type CatalogQuerySortedAttribute struct {
	// The attribute whose value is used as the sort key.
	AttributeName string `json:"attribute_name" url:"attribute_name"`
	// The first attribute value to be returned by the query. Ascending sorts will return only
	// objects with this value or greater, while descending sorts will return only objects with this value
	// or less. If unset, start at the beginning (for ascending sorts) or end (for descending sorts).
	InitialAttributeValue *string `json:"initial_attribute_value,omitempty" url:"initial_attribute_value,omitempty"`
	// The desired sort order, `"ASC"` (ascending) or `"DESC"` (descending).
	// See [SortOrder](#type-sortorder) for possible values
	SortOrder *SortOrder `json:"sort_order,omitempty" url:"sort_order,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CatalogQuerySortedAttribute) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CatalogQuerySortedAttribute) UnmarshalJSON(data []byte) error {
	type unmarshaler CatalogQuerySortedAttribute
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CatalogQuerySortedAttribute(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CatalogQuerySortedAttribute) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// The query filter to return the search result whose searchable attribute values contain all of the specified keywords or tokens, independent of the token order or case.
type CatalogQueryText struct {
	// A list of 1, 2, or 3 search keywords. Keywords with fewer than 3 characters are ignored.
	Keywords []string `json:"keywords,omitempty" url:"keywords,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CatalogQueryText) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CatalogQueryText) UnmarshalJSON(data []byte) error {
	type unmarshaler CatalogQueryText
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CatalogQueryText(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CatalogQueryText) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Represents a Quick Amount in the Catalog.
type CatalogQuickAmount struct {
	// Represents the type of the Quick Amount.
	// See [CatalogQuickAmountType](#type-catalogquickamounttype) for possible values
	Type CatalogQuickAmountType `json:"type" url:"type"`
	// Represents the actual amount of the Quick Amount with Money type.
	Amount *Money `json:"amount,omitempty" url:"amount,omitempty"`
	// Describes the ranking of the Quick Amount provided by machine learning model, in the range [0, 100].
	// MANUAL type amount will always have score = 100.
	Score *int64 `json:"score,omitempty" url:"score,omitempty"`
	// The order in which this Quick Amount should be displayed.
	Ordinal *int64 `json:"ordinal,omitempty" url:"ordinal,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CatalogQuickAmount) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CatalogQuickAmount) UnmarshalJSON(data []byte) error {
	type unmarshaler CatalogQuickAmount
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CatalogQuickAmount(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CatalogQuickAmount) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Determines the type of a specific Quick Amount.
type CatalogQuickAmountType string

const (
	CatalogQuickAmountTypeQuickAmountTypeDoNotUse CatalogQuickAmountType = "QUICK_AMOUNT_TYPE_DO_NOT_USE"
	CatalogQuickAmountTypeQuickAmountTypeManual   CatalogQuickAmountType = "QUICK_AMOUNT_TYPE_MANUAL"
	CatalogQuickAmountTypeQuickAmountTypeAuto     CatalogQuickAmountType = "QUICK_AMOUNT_TYPE_AUTO"
)

func NewCatalogQuickAmountTypeFromString(s string) (CatalogQuickAmountType, error) {
	switch s {
	case "QUICK_AMOUNT_TYPE_DO_NOT_USE":
		return CatalogQuickAmountTypeQuickAmountTypeDoNotUse, nil
	case "QUICK_AMOUNT_TYPE_MANUAL":
		return CatalogQuickAmountTypeQuickAmountTypeManual, nil
	case "QUICK_AMOUNT_TYPE_AUTO":
		return CatalogQuickAmountTypeQuickAmountTypeAuto, nil
	}
	var t CatalogQuickAmountType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CatalogQuickAmountType) Ptr() *CatalogQuickAmountType {
	return &c
}

// A parent Catalog Object model represents a set of Quick Amounts and the settings control the amounts.
type CatalogQuickAmountsSettings struct {
	// Represents the option seller currently uses on Quick Amounts.
	// See [CatalogQuickAmountsSettingsOption](#type-catalogquickamountssettingsoption) for possible values
	Option CatalogQuickAmountsSettingsOption `json:"option" url:"option"`
	// Represents location's eligibility for auto amounts
	// The boolean should be consistent with whether there are AUTO amounts in the `amounts`.
	EligibleForAutoAmounts *bool `json:"eligible_for_auto_amounts,omitempty" url:"eligible_for_auto_amounts,omitempty"`
	// Represents a set of Quick Amounts at this location.
	Amounts []*CatalogQuickAmount `json:"amounts,omitempty" url:"amounts,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CatalogQuickAmountsSettings) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CatalogQuickAmountsSettings) UnmarshalJSON(data []byte) error {
	type unmarshaler CatalogQuickAmountsSettings
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CatalogQuickAmountsSettings(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CatalogQuickAmountsSettings) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Determines a seller's option on Quick Amounts feature.
type CatalogQuickAmountsSettingsOption string

const (
	CatalogQuickAmountsSettingsOptionQuickAmountsSettingsOptionDoNotUse CatalogQuickAmountsSettingsOption = "QUICK_AMOUNTS_SETTINGS_OPTION_DO_NOT_USE"
	CatalogQuickAmountsSettingsOptionDisabled                           CatalogQuickAmountsSettingsOption = "DISABLED"
	CatalogQuickAmountsSettingsOptionManual                             CatalogQuickAmountsSettingsOption = "MANUAL"
	CatalogQuickAmountsSettingsOptionAuto                               CatalogQuickAmountsSettingsOption = "AUTO"
)

func NewCatalogQuickAmountsSettingsOptionFromString(s string) (CatalogQuickAmountsSettingsOption, error) {
	switch s {
	case "QUICK_AMOUNTS_SETTINGS_OPTION_DO_NOT_USE":
		return CatalogQuickAmountsSettingsOptionQuickAmountsSettingsOptionDoNotUse, nil
	case "DISABLED":
		return CatalogQuickAmountsSettingsOptionDisabled, nil
	case "MANUAL":
		return CatalogQuickAmountsSettingsOptionManual, nil
	case "AUTO":
		return CatalogQuickAmountsSettingsOptionAuto, nil
	}
	var t CatalogQuickAmountsSettingsOption
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CatalogQuickAmountsSettingsOption) Ptr() *CatalogQuickAmountsSettingsOption {
	return &c
}

// Represents the rule of conversion between a stockable [CatalogItemVariation](entity:CatalogItemVariation)
// and a non-stockable sell-by or receive-by `CatalogItemVariation` that
// share the same underlying stock.
type CatalogStockConversion struct {
	// References to the stockable [CatalogItemVariation](entity:CatalogItemVariation)
	// for this stock conversion. Selling, receiving or recounting the non-stockable `CatalogItemVariation`
	// defined with a stock conversion results in adjustments of this stockable `CatalogItemVariation`.
	// This immutable field must reference a stockable `CatalogItemVariation`
	// that shares the parent [CatalogItem](entity:CatalogItem) of the converted `CatalogItemVariation.`
	StockableItemVariationId string `json:"stockable_item_variation_id" url:"stockable_item_variation_id"`
	// The quantity of the stockable item variation (as identified by `stockable_item_variation_id`)
	// equivalent to the non-stockable item variation quantity (as specified in `nonstockable_quantity`)
	// as defined by this stock conversion. It accepts a decimal number in a string format that can take
	// up to 10 digits before the decimal point and up to 5 digits after the decimal point.
	StockableQuantity string `json:"stockable_quantity" url:"stockable_quantity"`
	// The converted equivalent quantity of the non-stockable [CatalogItemVariation](entity:CatalogItemVariation)
	// in its measurement unit. The `stockable_quantity` value and this `nonstockable_quantity` value together
	// define the conversion ratio between stockable item variation and the non-stockable item variation.
	// It accepts a decimal number in a string format that can take up to 10 digits before the decimal point
	// and up to 5 digits after the decimal point.
	NonstockableQuantity string `json:"nonstockable_quantity" url:"nonstockable_quantity"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CatalogStockConversion) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CatalogStockConversion) UnmarshalJSON(data []byte) error {
	type unmarshaler CatalogStockConversion
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CatalogStockConversion(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CatalogStockConversion) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Describes a subscription plan. For more information, see
// [Set Up and Manage a Subscription Plan](https://developer.squareup.com/docs/subscriptions-api/setup-plan).
type CatalogSubscriptionPlan struct {
	// The name of the plan.
	Name string `json:"name" url:"name"`
	// A list of SubscriptionPhase containing the [SubscriptionPhase](entity:SubscriptionPhase) for this plan.
	Phases []*SubscriptionPhase `json:"phases,omitempty" url:"phases,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CatalogSubscriptionPlan) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CatalogSubscriptionPlan) UnmarshalJSON(data []byte) error {
	type unmarshaler CatalogSubscriptionPlan
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CatalogSubscriptionPlan(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CatalogSubscriptionPlan) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// A tax applicable to an item.
type CatalogTax struct {
	// The tax's name. This is a searchable attribute for use in applicable query filters, and its value length is of Unicode code points.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// Whether the tax is calculated based on a payment's subtotal or total.
	// See [TaxCalculationPhase](#type-taxcalculationphase) for possible values
	CalculationPhase *TaxCalculationPhase `json:"calculation_phase,omitempty" url:"calculation_phase,omitempty"`
	// Whether the tax is `ADDITIVE` or `INCLUSIVE`.
	// See [TaxInclusionType](#type-taxinclusiontype) for possible values
	InclusionType *TaxInclusionType `json:"inclusion_type,omitempty" url:"inclusion_type,omitempty"`
	// The percentage of the tax in decimal form, using a `'.'` as the decimal separator and without a `'%'` sign.
	// A value of `7.5` corresponds to 7.5%. For a location-specific tax rate, contact the tax authority of the location or a tax consultant.
	Percentage *string `json:"percentage,omitempty" url:"percentage,omitempty"`
	// If `true`, the fee applies to custom amounts entered into the Square Point of Sale
	// app that are not associated with a particular `CatalogItem`.
	AppliesToCustomAmounts *bool `json:"applies_to_custom_amounts,omitempty" url:"applies_to_custom_amounts,omitempty"`
	// A Boolean flag to indicate whether the tax is displayed as enabled (`true`) in the Square Point of Sale app or not (`false`).
	Enabled *bool `json:"enabled,omitempty" url:"enabled,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CatalogTax) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CatalogTax) UnmarshalJSON(data []byte) error {
	type unmarshaler CatalogTax
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CatalogTax(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CatalogTax) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Represents a time period - either a single period or a repeating period.
type CatalogTimePeriod struct {
	// An iCalendar (RFC 5545) [event](https://tools.ietf.org/html/rfc5545#section-3.6.1), which
	// specifies the name, timing, duration and recurrence of this time period.
	//
	// Example:
	//
	// ```
	// DTSTART:20190707T180000
	// DURATION:P2H
	// RRULE:FREQ=WEEKLY;BYDAY=MO,WE,FR
	// ```
	//
	// Only `SUMMARY`, `DTSTART`, `DURATION` and `RRULE` fields are supported.
	// `DTSTART` must be in local (unzoned) time format. Note that while `BEGIN:VEVENT`
	// and `END:VEVENT` is not required in the request. The response will always
	// include them.
	Event *string `json:"event,omitempty" url:"event,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CatalogTimePeriod) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CatalogTimePeriod) UnmarshalJSON(data []byte) error {
	type unmarshaler CatalogTimePeriod
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CatalogTimePeriod(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CatalogTimePeriod) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// A Square API V1 identifier of an item, including the object ID and its associated location ID.
type CatalogV1Id struct {
	// The ID for an object used in the Square API V1, if the object ID differs from the Square API V2 object ID.
	CatalogV1Id *string `json:"catalog_v1_id,omitempty" url:"catalog_v1_id,omitempty"`
	// The ID of the `Location` this Connect V1 ID is associated with.
	LocationId *string `json:"location_id,omitempty" url:"location_id,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CatalogV1Id) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CatalogV1Id) UnmarshalJSON(data []byte) error {
	type unmarshaler CatalogV1Id
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CatalogV1Id(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CatalogV1Id) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Published when the catalog is updated.
type CatalogVersionUpdatedWebhook struct {
	// The ID of the target merchant associated with the event.
	MerchantId *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The type of event this represents.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// A unique ID for the webhook event.
	EventId *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// Timestamp of when the webhook event was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// Data associated with the event.
	Data *CatalogVersionUpdatedWebhookData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CatalogVersionUpdatedWebhook) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CatalogVersionUpdatedWebhook) UnmarshalJSON(data []byte) error {
	type unmarshaler CatalogVersionUpdatedWebhook
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CatalogVersionUpdatedWebhook(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CatalogVersionUpdatedWebhook) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CatalogVersionUpdatedWebhookCatalogVersion struct {
	// Last modification timestamp in RFC 3339 format.
	UpdatedAt *string `json:"updated_at,omitempty" url:"updated_at,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CatalogVersionUpdatedWebhookCatalogVersion) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CatalogVersionUpdatedWebhookCatalogVersion) UnmarshalJSON(data []byte) error {
	type unmarshaler CatalogVersionUpdatedWebhookCatalogVersion
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CatalogVersionUpdatedWebhookCatalogVersion(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CatalogVersionUpdatedWebhookCatalogVersion) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CatalogVersionUpdatedWebhookData struct {
	// Name of the affected object’s type.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// ID of the affected object.
	Id *string `json:"id,omitempty" url:"id,omitempty"`
	// An object containing fields and values relevant to the event. Is absent if affected object was deleted.
	Object *CatalogVersionUpdatedWebhookObject `json:"object,omitempty" url:"object,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CatalogVersionUpdatedWebhookData) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CatalogVersionUpdatedWebhookData) UnmarshalJSON(data []byte) error {
	type unmarshaler CatalogVersionUpdatedWebhookData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CatalogVersionUpdatedWebhookData(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CatalogVersionUpdatedWebhookData) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CatalogVersionUpdatedWebhookObject struct {
	// The version of the object.
	CatalogVersion *CatalogVersionUpdatedWebhookCatalogVersion `json:"catalog_version,omitempty" url:"catalog_version,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CatalogVersionUpdatedWebhookObject) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CatalogVersionUpdatedWebhookObject) UnmarshalJSON(data []byte) error {
	type unmarshaler CatalogVersionUpdatedWebhookObject
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CatalogVersionUpdatedWebhookObject(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CatalogVersionUpdatedWebhookObject) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Defines the parameters that can be included in the body of
// a request to the [Charge](api-endpoint:Transactions-Charge) endpoint.
//
// Deprecated - recommend using [CreatePayment](api-endpoint:Payments-CreatePayment)
type ChargeRequest struct {
	// A value you specify that uniquely identifies this
	// transaction among transactions you've created.
	//
	// If you're unsure whether a particular transaction succeeded,
	// you can reattempt it with the same idempotency key without
	// worrying about double-charging the buyer.
	//
	// See [Idempotency keys](https://developer.squareup.com/docs/working-with-apis/idempotency) for more information.
	IdempotencyKey string `json:"idempotency_key" url:"idempotency_key"`
	// The amount of money to charge.
	//
	// Note that you specify the amount in the
	// **smallest denomination of the applicable currency**. For example, US dollar
	// amounts are specified in cents. See
	// [Working with monetary amounts](https://developer.squareup.com/docs/build-basics/working-with-monetary-amounts) for details.
	//
	// The value of `currency` must match the currency associated with the business
	// that is charging the card.
	AmountMoney *Money `json:"amount_money,omitempty" url:"amount_money,omitempty"`
	// A payment token generated from the [Card.tokenize()](https://developer.squareup.com/reference/sdks/web/payments/objects/Card#Card.tokenize) that represents the card
	// to charge.
	//
	// The application that provides a payment token to this endpoint must be the
	// _same application_ that generated the payment token with the Web Payments SDK.
	// Otherwise, the nonce is invalid.
	//
	// Do not provide a value for this field if you provide a value for
	// `customer_card_id`.
	CardNonce *string `json:"card_nonce,omitempty" url:"card_nonce,omitempty"`
	// The ID of the customer card on file to charge. Do
	// not provide a value for this field if you provide a value for `card_nonce`.
	//
	// If you provide this value, you _must_ also provide a value for
	// `customer_id`.
	CustomerCardId *string `json:"customer_card_id,omitempty" url:"customer_card_id,omitempty"`
	// If `true`, the request will only perform an Auth on the provided
	// card. You can then later perform either a Capture (with the
	// [CaptureTransaction](api-endpoint:Transactions-CaptureTransaction) endpoint) or a Void
	// (with the [VoidTransaction](api-endpoint:Transactions-VoidTransaction) endpoint).
	//
	// Default value: `false`
	DelayCapture *bool `json:"delay_capture,omitempty" url:"delay_capture,omitempty"`
	// An optional ID you can associate with the transaction for your own
	// purposes (such as to associate the transaction with an entity ID in your
	// own database).
	//
	// This value cannot exceed 40 characters.
	ReferenceId *string `json:"reference_id,omitempty" url:"reference_id,omitempty"`
	// An optional note to associate with the transaction.
	//
	// This value cannot exceed 60 characters.
	Note *string `json:"note,omitempty" url:"note,omitempty"`
	// The ID of the customer to associate this transaction with. This field
	// is required if you provide a value for `customer_card_id`, and optional
	// otherwise.
	CustomerId *string `json:"customer_id,omitempty" url:"customer_id,omitempty"`
	// The buyer's billing address. This value is optional, but this transaction
	// is ineligible for chargeback protection if neither this parameter nor
	// `shipping_address` is provided.
	BillingAddress *Address `json:"billing_address,omitempty" url:"billing_address,omitempty"`
	// The buyer's shipping address, if available. This value is optional,
	// but this transaction is ineligible for chargeback protection if neither this
	// parameter nor `billing_address` is provided.
	ShippingAddress *Address `json:"shipping_address,omitempty" url:"shipping_address,omitempty"`
	// The buyer's email address, if available. This value is optional,
	// but this transaction is ineligible for chargeback protection if it is not
	// provided.
	BuyerEmailAddress *string `json:"buyer_email_address,omitempty" url:"buyer_email_address,omitempty"`
	// The ID of the order to associate with this transaction.
	//
	// If you provide this value, the `amount_money` value of your request must
	// **exactly match** the value of the order's `total_money` field.
	OrderId *string `json:"order_id,omitempty" url:"order_id,omitempty"`
	// The basic primitive of multi-party transaction. The value is optional.
	// The transaction facilitated by you can be split from here.
	//
	// If you provide this value, the `amount_money` value in your additional_recipients
	// must not be more than 90% of the `amount_money` value in the charge request.
	// The `location_id` must be the valid location of the app owner merchant.
	//
	// This field requires the `PAYMENTS_WRITE_ADDITIONAL_RECIPIENTS` OAuth permission.
	//
	// This field is currently not supported in sandbox.
	AdditionalRecipients []*ChargeRequestAdditionalRecipient `json:"additional_recipients,omitempty" url:"additional_recipients,omitempty"`
	// A token generated by SqPaymentForm's verifyBuyer() that represents
	// customer's device info and 3ds challenge result.
	VerificationToken *string `json:"verification_token,omitempty" url:"verification_token,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ChargeRequest) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ChargeRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler ChargeRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ChargeRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ChargeRequest) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Defines the fields that are included in the response body of
// a request to the [Charge](api-endpoint:Transactions-Charge) endpoint.
//
// One of `errors` or `transaction` is present in a given response (never both).
type ChargeResponse struct {
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The created transaction.
	Transaction *Transaction `json:"transaction,omitempty" url:"transaction,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ChargeResponse) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ChargeResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ChargeResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ChargeResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ChargeResponse) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Square Checkout lets merchants accept online payments for supported
// payment types using a checkout workflow hosted on squareup.com.
type Checkout struct {
	// ID generated by Square Checkout when a new checkout is requested.
	Id *string `json:"id,omitempty" url:"id,omitempty"`
	// The URL that the buyer's browser should be redirected to after the
	// checkout is completed.
	CheckoutPageUrl *string `json:"checkout_page_url,omitempty" url:"checkout_page_url,omitempty"`
	// If `true`, Square Checkout will collect shipping information on your
	// behalf and store that information with the transaction information in your
	// Square Dashboard.
	//
	// Default: `false`.
	AskForShippingAddress *bool `json:"ask_for_shipping_address,omitempty" url:"ask_for_shipping_address,omitempty"`
	// The email address to display on the Square Checkout confirmation page
	// and confirmation email that the buyer can use to contact the merchant.
	//
	// If this value is not set, the confirmation page and email will display the
	// primary email address associated with the merchant's Square account.
	//
	// Default: none; only exists if explicitly set.
	MerchantSupportEmail *string `json:"merchant_support_email,omitempty" url:"merchant_support_email,omitempty"`
	// If provided, the buyer's email is pre-populated on the checkout page
	// as an editable text field.
	//
	// Default: none; only exists if explicitly set.
	PrePopulateBuyerEmail *string `json:"pre_populate_buyer_email,omitempty" url:"pre_populate_buyer_email,omitempty"`
	// If provided, the buyer's shipping info is pre-populated on the
	// checkout page as editable text fields.
	//
	// Default: none; only exists if explicitly set.
	PrePopulateShippingAddress *Address `json:"pre_populate_shipping_address,omitempty" url:"pre_populate_shipping_address,omitempty"`
	// The URL to redirect to after checkout is completed with `checkoutId`,
	// Square's `orderId`, `transactionId`, and `referenceId` appended as URL
	// parameters. For example, if the provided redirect_url is
	// `http://www.example.com/order-complete`, a successful transaction redirects
	// the customer to:
	//
	// <pre><code>http://www.example.com/order-complete?checkoutId=xxxxxx&amp;orderId=xxxxxx&amp;referenceId=xxxxxx&amp;transactionId=xxxxxx</code></pre>
	//
	// If you do not provide a redirect URL, Square Checkout will display an order
	// confirmation page on your behalf; however Square strongly recommends that
	// you provide a redirect URL so you can verify the transaction results and
	// finalize the order through your existing/normal confirmation workflow.
	RedirectUrl *string `json:"redirect_url,omitempty" url:"redirect_url,omitempty"`
	// Order to be checked out.
	Order *Order `json:"order,omitempty" url:"order,omitempty"`
	// The time when the checkout was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// Additional recipients (other than the merchant) receiving a portion of this checkout.
	// For example, fees assessed on the purchase by a third party integration.
	AdditionalRecipients []*AdditionalRecipient `json:"additional_recipients,omitempty" url:"additional_recipients,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *Checkout) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *Checkout) UnmarshalJSON(data []byte) error {
	type unmarshaler Checkout
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = Checkout(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *Checkout) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CheckoutOptions struct {
	// Indicates whether the payment allows tipping.
	AllowTipping *bool `json:"allow_tipping,omitempty" url:"allow_tipping,omitempty"`
	// The custom fields requesting information from the buyer.
	CustomFields []*CustomField `json:"custom_fields,omitempty" url:"custom_fields,omitempty"`
	// The ID of the subscription plan for the buyer to pay and subscribe.
	// For more information, see [Subscription Plan Checkout](https://developer.squareup.com/docs/checkout-api/subscription-plan-checkout).
	SubscriptionPlanId *string `json:"subscription_plan_id,omitempty" url:"subscription_plan_id,omitempty"`
	// The confirmation page URL to redirect the buyer to after Square processes the payment.
	RedirectUrl *string `json:"redirect_url,omitempty" url:"redirect_url,omitempty"`
	// The email address that buyers can use to contact the seller.
	MerchantSupportEmail *string `json:"merchant_support_email,omitempty" url:"merchant_support_email,omitempty"`
	// Indicates whether to include the address fields in the payment form.
	AskForShippingAddress *bool `json:"ask_for_shipping_address,omitempty" url:"ask_for_shipping_address,omitempty"`
	// The methods allowed for buyers during checkout.
	AcceptedPaymentMethods *AcceptedPaymentMethods `json:"accepted_payment_methods,omitempty" url:"accepted_payment_methods,omitempty"`
	// The amount of money that the developer is taking as a fee for facilitating the payment on behalf of the seller.
	//
	// The amount cannot be more than 90% of the total amount of the payment.
	//
	// The amount must be specified in the smallest denomination of the applicable currency (for example, US dollar amounts are specified in cents). For more information, see [Working with Monetary Amounts](https://developer.squareup.com/docs/build-basics/common-data-types/working-with-monetary-amounts).
	//
	// The fee currency code must match the currency associated with the seller that is accepting the payment. The application must be from a developer account in the same country and using the same currency code as the seller. For more information about the application fee scenario, see [Take Payments and Collect Fees](https://developer.squareup.com/docs/payments-api/take-payments-and-collect-fees).
	//
	// To set this field, `PAYMENTS_WRITE_ADDITIONAL_RECIPIENTS` OAuth permission is required. For more information, see [Permissions](https://developer.squareup.com/docs/payments-api/collect-fees/additional-considerations#permissions).
	AppFeeMoney *Money `json:"app_fee_money,omitempty" url:"app_fee_money,omitempty"`
	// The fee associated with shipping to be applied to the `Order` as a service charge.
	ShippingFee *ShippingFee `json:"shipping_fee,omitempty" url:"shipping_fee,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CheckoutOptions) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CheckoutOptions) UnmarshalJSON(data []byte) error {
	type unmarshaler CheckoutOptions
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CheckoutOptions(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CheckoutOptions) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CheckoutOptionsPaymentType string

const (
	CheckoutOptionsPaymentTypePaymentTypeDoNotUse       CheckoutOptionsPaymentType = "PAYMENT_TYPE_DO_NOT_USE"
	CheckoutOptionsPaymentTypeCardPresent               CheckoutOptionsPaymentType = "CARD_PRESENT"
	CheckoutOptionsPaymentTypeManualCardEntry           CheckoutOptionsPaymentType = "MANUAL_CARD_ENTRY"
	CheckoutOptionsPaymentTypeFelicaId                  CheckoutOptionsPaymentType = "FELICA_ID"
	CheckoutOptionsPaymentTypeFelicaQuicpay             CheckoutOptionsPaymentType = "FELICA_QUICPAY"
	CheckoutOptionsPaymentTypeFelicaTransportationGroup CheckoutOptionsPaymentType = "FELICA_TRANSPORTATION_GROUP"
	CheckoutOptionsPaymentTypeFelicaAll                 CheckoutOptionsPaymentType = "FELICA_ALL"
	CheckoutOptionsPaymentTypePaypay                    CheckoutOptionsPaymentType = "PAYPAY"
)

func NewCheckoutOptionsPaymentTypeFromString(s string) (CheckoutOptionsPaymentType, error) {
	switch s {
	case "PAYMENT_TYPE_DO_NOT_USE":
		return CheckoutOptionsPaymentTypePaymentTypeDoNotUse, nil
	case "CARD_PRESENT":
		return CheckoutOptionsPaymentTypeCardPresent, nil
	case "MANUAL_CARD_ENTRY":
		return CheckoutOptionsPaymentTypeManualCardEntry, nil
	case "FELICA_ID":
		return CheckoutOptionsPaymentTypeFelicaId, nil
	case "FELICA_QUICPAY":
		return CheckoutOptionsPaymentTypeFelicaQuicpay, nil
	case "FELICA_TRANSPORTATION_GROUP":
		return CheckoutOptionsPaymentTypeFelicaTransportationGroup, nil
	case "FELICA_ALL":
		return CheckoutOptionsPaymentTypeFelicaAll, nil
	case "PAYPAY":
		return CheckoutOptionsPaymentTypePaypay, nil
	}
	var t CheckoutOptionsPaymentType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CheckoutOptionsPaymentType) Ptr() *CheckoutOptionsPaymentType {
	return &c
}

// Additional details about Clearpay payments.
type ClearpayDetails struct {
	// Email address on the buyer's Clearpay account.
	EmailAddress *string `json:"email_address,omitempty" url:"email_address,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClearpayDetails) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClearpayDetails) UnmarshalJSON(data []byte) error {
	type unmarshaler ClearpayDetails
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClearpayDetails(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClearpayDetails) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Latitude and longitude coordinates.
type Coordinates struct {
	// The latitude of the coordinate expressed in degrees.
	Latitude *float64 `json:"latitude,omitempty" url:"latitude,omitempty"`
	// The longitude of the coordinate expressed in degrees.
	Longitude *float64 `json:"longitude,omitempty" url:"longitude,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *Coordinates) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *Coordinates) UnmarshalJSON(data []byte) error {
	type unmarshaler Coordinates
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = Coordinates(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *Coordinates) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Indicates the country associated with another entity, such as a business.
// Values are in [ISO 3166-1-alpha-2 format](http://www.iso.org/iso/home/standards/country_codes.htm).
type Country string

const (
	CountryZz Country = "ZZ"
	CountryAd Country = "AD"
	CountryAe Country = "AE"
	CountryAf Country = "AF"
	CountryAg Country = "AG"
	CountryAi Country = "AI"
	CountryAl Country = "AL"
	CountryAm Country = "AM"
	CountryAo Country = "AO"
	CountryAq Country = "AQ"
	CountryAr Country = "AR"
	CountryAs Country = "AS"
	CountryAt Country = "AT"
	CountryAu Country = "AU"
	CountryAw Country = "AW"
	CountryAx Country = "AX"
	CountryAz Country = "AZ"
	CountryBa Country = "BA"
	CountryBb Country = "BB"
	CountryBd Country = "BD"
	CountryBe Country = "BE"
	CountryBf Country = "BF"
	CountryBg Country = "BG"
	CountryBh Country = "BH"
	CountryBi Country = "BI"
	CountryBj Country = "BJ"
	CountryBl Country = "BL"
	CountryBm Country = "BM"
	CountryBn Country = "BN"
	CountryBo Country = "BO"
	CountryBq Country = "BQ"
	CountryBr Country = "BR"
	CountryBs Country = "BS"
	CountryBt Country = "BT"
	CountryBv Country = "BV"
	CountryBw Country = "BW"
	CountryBy Country = "BY"
	CountryBz Country = "BZ"
	CountryCa Country = "CA"
	CountryCc Country = "CC"
	CountryCd Country = "CD"
	CountryCf Country = "CF"
	CountryCg Country = "CG"
	CountryCh Country = "CH"
	CountryCi Country = "CI"
	CountryCk Country = "CK"
	CountryCl Country = "CL"
	CountryCm Country = "CM"
	CountryCn Country = "CN"
	CountryCo Country = "CO"
	CountryCr Country = "CR"
	CountryCu Country = "CU"
	CountryCv Country = "CV"
	CountryCw Country = "CW"
	CountryCx Country = "CX"
	CountryCy Country = "CY"
	CountryCz Country = "CZ"
	CountryDe Country = "DE"
	CountryDj Country = "DJ"
	CountryDk Country = "DK"
	CountryDm Country = "DM"
	CountryDo Country = "DO"
	CountryDz Country = "DZ"
	CountryEc Country = "EC"
	CountryEe Country = "EE"
	CountryEg Country = "EG"
	CountryEh Country = "EH"
	CountryEr Country = "ER"
	CountryEs Country = "ES"
	CountryEt Country = "ET"
	CountryFi Country = "FI"
	CountryFj Country = "FJ"
	CountryFk Country = "FK"
	CountryFm Country = "FM"
	CountryFo Country = "FO"
	CountryFr Country = "FR"
	CountryGa Country = "GA"
	CountryGb Country = "GB"
	CountryGd Country = "GD"
	CountryGe Country = "GE"
	CountryGf Country = "GF"
	CountryGg Country = "GG"
	CountryGh Country = "GH"
	CountryGi Country = "GI"
	CountryGl Country = "GL"
	CountryGm Country = "GM"
	CountryGn Country = "GN"
	CountryGp Country = "GP"
	CountryGq Country = "GQ"
	CountryGr Country = "GR"
	CountryGs Country = "GS"
	CountryGt Country = "GT"
	CountryGu Country = "GU"
	CountryGw Country = "GW"
	CountryGy Country = "GY"
	CountryHk Country = "HK"
	CountryHm Country = "HM"
	CountryHn Country = "HN"
	CountryHr Country = "HR"
	CountryHt Country = "HT"
	CountryHu Country = "HU"
	CountryId Country = "ID"
	CountryIe Country = "IE"
	CountryIl Country = "IL"
	CountryIm Country = "IM"
	CountryIn Country = "IN"
	CountryIo Country = "IO"
	CountryIq Country = "IQ"
	CountryIr Country = "IR"
	CountryIs Country = "IS"
	CountryIt Country = "IT"
	CountryJe Country = "JE"
	CountryJm Country = "JM"
	CountryJo Country = "JO"
	CountryJp Country = "JP"
	CountryKe Country = "KE"
	CountryKg Country = "KG"
	CountryKh Country = "KH"
	CountryKi Country = "KI"
	CountryKm Country = "KM"
	CountryKn Country = "KN"
	CountryKp Country = "KP"
	CountryKr Country = "KR"
	CountryKw Country = "KW"
	CountryKy Country = "KY"
	CountryKz Country = "KZ"
	CountryLa Country = "LA"
	CountryLb Country = "LB"
	CountryLc Country = "LC"
	CountryLi Country = "LI"
	CountryLk Country = "LK"
	CountryLr Country = "LR"
	CountryLs Country = "LS"
	CountryLt Country = "LT"
	CountryLu Country = "LU"
	CountryLv Country = "LV"
	CountryLy Country = "LY"
	CountryMa Country = "MA"
	CountryMc Country = "MC"
	CountryMd Country = "MD"
	CountryMe Country = "ME"
	CountryMf Country = "MF"
	CountryMg Country = "MG"
	CountryMh Country = "MH"
	CountryMk Country = "MK"
	CountryMl Country = "ML"
	CountryMm Country = "MM"
	CountryMn Country = "MN"
	CountryMo Country = "MO"
	CountryMp Country = "MP"
	CountryMq Country = "MQ"
	CountryMr Country = "MR"
	CountryMs Country = "MS"
	CountryMt Country = "MT"
	CountryMu Country = "MU"
	CountryMv Country = "MV"
	CountryMw Country = "MW"
	CountryMx Country = "MX"
	CountryMy Country = "MY"
	CountryMz Country = "MZ"
	CountryNa Country = "NA"
	CountryNc Country = "NC"
	CountryNe Country = "NE"
	CountryNf Country = "NF"
	CountryNg Country = "NG"
	CountryNi Country = "NI"
	CountryNl Country = "NL"
	CountryNo Country = "NO"
	CountryNp Country = "NP"
	CountryNr Country = "NR"
	CountryNu Country = "NU"
	CountryNz Country = "NZ"
	CountryOm Country = "OM"
	CountryPa Country = "PA"
	CountryPe Country = "PE"
	CountryPf Country = "PF"
	CountryPg Country = "PG"
	CountryPh Country = "PH"
	CountryPk Country = "PK"
	CountryPl Country = "PL"
	CountryPm Country = "PM"
	CountryPn Country = "PN"
	CountryPr Country = "PR"
	CountryPs Country = "PS"
	CountryPt Country = "PT"
	CountryPw Country = "PW"
	CountryPy Country = "PY"
	CountryQa Country = "QA"
	CountryRe Country = "RE"
	CountryRo Country = "RO"
	CountryRs Country = "RS"
	CountryRu Country = "RU"
	CountryRw Country = "RW"
	CountrySa Country = "SA"
	CountrySb Country = "SB"
	CountrySc Country = "SC"
	CountrySd Country = "SD"
	CountrySe Country = "SE"
	CountrySg Country = "SG"
	CountrySh Country = "SH"
	CountrySi Country = "SI"
	CountrySj Country = "SJ"
	CountrySk Country = "SK"
	CountrySl Country = "SL"
	CountrySm Country = "SM"
	CountrySn Country = "SN"
	CountrySo Country = "SO"
	CountrySr Country = "SR"
	CountrySs Country = "SS"
	CountrySt Country = "ST"
	CountrySv Country = "SV"
	CountrySx Country = "SX"
	CountrySy Country = "SY"
	CountrySz Country = "SZ"
	CountryTc Country = "TC"
	CountryTd Country = "TD"
	CountryTf Country = "TF"
	CountryTg Country = "TG"
	CountryTh Country = "TH"
	CountryTj Country = "TJ"
	CountryTk Country = "TK"
	CountryTl Country = "TL"
	CountryTm Country = "TM"
	CountryTn Country = "TN"
	CountryTo Country = "TO"
	CountryTr Country = "TR"
	CountryTt Country = "TT"
	CountryTv Country = "TV"
	CountryTw Country = "TW"
	CountryTz Country = "TZ"
	CountryUa Country = "UA"
	CountryUg Country = "UG"
	CountryUm Country = "UM"
	CountryUs Country = "US"
	CountryUy Country = "UY"
	CountryUz Country = "UZ"
	CountryVa Country = "VA"
	CountryVc Country = "VC"
	CountryVe Country = "VE"
	CountryVg Country = "VG"
	CountryVi Country = "VI"
	CountryVn Country = "VN"
	CountryVu Country = "VU"
	CountryWf Country = "WF"
	CountryWs Country = "WS"
	CountryYe Country = "YE"
	CountryYt Country = "YT"
	CountryZa Country = "ZA"
	CountryZm Country = "ZM"
	CountryZw Country = "ZW"
)

func NewCountryFromString(s string) (Country, error) {
	switch s {
	case "ZZ":
		return CountryZz, nil
	case "AD":
		return CountryAd, nil
	case "AE":
		return CountryAe, nil
	case "AF":
		return CountryAf, nil
	case "AG":
		return CountryAg, nil
	case "AI":
		return CountryAi, nil
	case "AL":
		return CountryAl, nil
	case "AM":
		return CountryAm, nil
	case "AO":
		return CountryAo, nil
	case "AQ":
		return CountryAq, nil
	case "AR":
		return CountryAr, nil
	case "AS":
		return CountryAs, nil
	case "AT":
		return CountryAt, nil
	case "AU":
		return CountryAu, nil
	case "AW":
		return CountryAw, nil
	case "AX":
		return CountryAx, nil
	case "AZ":
		return CountryAz, nil
	case "BA":
		return CountryBa, nil
	case "BB":
		return CountryBb, nil
	case "BD":
		return CountryBd, nil
	case "BE":
		return CountryBe, nil
	case "BF":
		return CountryBf, nil
	case "BG":
		return CountryBg, nil
	case "BH":
		return CountryBh, nil
	case "BI":
		return CountryBi, nil
	case "BJ":
		return CountryBj, nil
	case "BL":
		return CountryBl, nil
	case "BM":
		return CountryBm, nil
	case "BN":
		return CountryBn, nil
	case "BO":
		return CountryBo, nil
	case "BQ":
		return CountryBq, nil
	case "BR":
		return CountryBr, nil
	case "BS":
		return CountryBs, nil
	case "BT":
		return CountryBt, nil
	case "BV":
		return CountryBv, nil
	case "BW":
		return CountryBw, nil
	case "BY":
		return CountryBy, nil
	case "BZ":
		return CountryBz, nil
	case "CA":
		return CountryCa, nil
	case "CC":
		return CountryCc, nil
	case "CD":
		return CountryCd, nil
	case "CF":
		return CountryCf, nil
	case "CG":
		return CountryCg, nil
	case "CH":
		return CountryCh, nil
	case "CI":
		return CountryCi, nil
	case "CK":
		return CountryCk, nil
	case "CL":
		return CountryCl, nil
	case "CM":
		return CountryCm, nil
	case "CN":
		return CountryCn, nil
	case "CO":
		return CountryCo, nil
	case "CR":
		return CountryCr, nil
	case "CU":
		return CountryCu, nil
	case "CV":
		return CountryCv, nil
	case "CW":
		return CountryCw, nil
	case "CX":
		return CountryCx, nil
	case "CY":
		return CountryCy, nil
	case "CZ":
		return CountryCz, nil
	case "DE":
		return CountryDe, nil
	case "DJ":
		return CountryDj, nil
	case "DK":
		return CountryDk, nil
	case "DM":
		return CountryDm, nil
	case "DO":
		return CountryDo, nil
	case "DZ":
		return CountryDz, nil
	case "EC":
		return CountryEc, nil
	case "EE":
		return CountryEe, nil
	case "EG":
		return CountryEg, nil
	case "EH":
		return CountryEh, nil
	case "ER":
		return CountryEr, nil
	case "ES":
		return CountryEs, nil
	case "ET":
		return CountryEt, nil
	case "FI":
		return CountryFi, nil
	case "FJ":
		return CountryFj, nil
	case "FK":
		return CountryFk, nil
	case "FM":
		return CountryFm, nil
	case "FO":
		return CountryFo, nil
	case "FR":
		return CountryFr, nil
	case "GA":
		return CountryGa, nil
	case "GB":
		return CountryGb, nil
	case "GD":
		return CountryGd, nil
	case "GE":
		return CountryGe, nil
	case "GF":
		return CountryGf, nil
	case "GG":
		return CountryGg, nil
	case "GH":
		return CountryGh, nil
	case "GI":
		return CountryGi, nil
	case "GL":
		return CountryGl, nil
	case "GM":
		return CountryGm, nil
	case "GN":
		return CountryGn, nil
	case "GP":
		return CountryGp, nil
	case "GQ":
		return CountryGq, nil
	case "GR":
		return CountryGr, nil
	case "GS":
		return CountryGs, nil
	case "GT":
		return CountryGt, nil
	case "GU":
		return CountryGu, nil
	case "GW":
		return CountryGw, nil
	case "GY":
		return CountryGy, nil
	case "HK":
		return CountryHk, nil
	case "HM":
		return CountryHm, nil
	case "HN":
		return CountryHn, nil
	case "HR":
		return CountryHr, nil
	case "HT":
		return CountryHt, nil
	case "HU":
		return CountryHu, nil
	case "ID":
		return CountryId, nil
	case "IE":
		return CountryIe, nil
	case "IL":
		return CountryIl, nil
	case "IM":
		return CountryIm, nil
	case "IN":
		return CountryIn, nil
	case "IO":
		return CountryIo, nil
	case "IQ":
		return CountryIq, nil
	case "IR":
		return CountryIr, nil
	case "IS":
		return CountryIs, nil
	case "IT":
		return CountryIt, nil
	case "JE":
		return CountryJe, nil
	case "JM":
		return CountryJm, nil
	case "JO":
		return CountryJo, nil
	case "JP":
		return CountryJp, nil
	case "KE":
		return CountryKe, nil
	case "KG":
		return CountryKg, nil
	case "KH":
		return CountryKh, nil
	case "KI":
		return CountryKi, nil
	case "KM":
		return CountryKm, nil
	case "KN":
		return CountryKn, nil
	case "KP":
		return CountryKp, nil
	case "KR":
		return CountryKr, nil
	case "KW":
		return CountryKw, nil
	case "KY":
		return CountryKy, nil
	case "KZ":
		return CountryKz, nil
	case "LA":
		return CountryLa, nil
	case "LB":
		return CountryLb, nil
	case "LC":
		return CountryLc, nil
	case "LI":
		return CountryLi, nil
	case "LK":
		return CountryLk, nil
	case "LR":
		return CountryLr, nil
	case "LS":
		return CountryLs, nil
	case "LT":
		return CountryLt, nil
	case "LU":
		return CountryLu, nil
	case "LV":
		return CountryLv, nil
	case "LY":
		return CountryLy, nil
	case "MA":
		return CountryMa, nil
	case "MC":
		return CountryMc, nil
	case "MD":
		return CountryMd, nil
	case "ME":
		return CountryMe, nil
	case "MF":
		return CountryMf, nil
	case "MG":
		return CountryMg, nil
	case "MH":
		return CountryMh, nil
	case "MK":
		return CountryMk, nil
	case "ML":
		return CountryMl, nil
	case "MM":
		return CountryMm, nil
	case "MN":
		return CountryMn, nil
	case "MO":
		return CountryMo, nil
	case "MP":
		return CountryMp, nil
	case "MQ":
		return CountryMq, nil
	case "MR":
		return CountryMr, nil
	case "MS":
		return CountryMs, nil
	case "MT":
		return CountryMt, nil
	case "MU":
		return CountryMu, nil
	case "MV":
		return CountryMv, nil
	case "MW":
		return CountryMw, nil
	case "MX":
		return CountryMx, nil
	case "MY":
		return CountryMy, nil
	case "MZ":
		return CountryMz, nil
	case "NA":
		return CountryNa, nil
	case "NC":
		return CountryNc, nil
	case "NE":
		return CountryNe, nil
	case "NF":
		return CountryNf, nil
	case "NG":
		return CountryNg, nil
	case "NI":
		return CountryNi, nil
	case "NL":
		return CountryNl, nil
	case "NO":
		return CountryNo, nil
	case "NP":
		return CountryNp, nil
	case "NR":
		return CountryNr, nil
	case "NU":
		return CountryNu, nil
	case "NZ":
		return CountryNz, nil
	case "OM":
		return CountryOm, nil
	case "PA":
		return CountryPa, nil
	case "PE":
		return CountryPe, nil
	case "PF":
		return CountryPf, nil
	case "PG":
		return CountryPg, nil
	case "PH":
		return CountryPh, nil
	case "PK":
		return CountryPk, nil
	case "PL":
		return CountryPl, nil
	case "PM":
		return CountryPm, nil
	case "PN":
		return CountryPn, nil
	case "PR":
		return CountryPr, nil
	case "PS":
		return CountryPs, nil
	case "PT":
		return CountryPt, nil
	case "PW":
		return CountryPw, nil
	case "PY":
		return CountryPy, nil
	case "QA":
		return CountryQa, nil
	case "RE":
		return CountryRe, nil
	case "RO":
		return CountryRo, nil
	case "RS":
		return CountryRs, nil
	case "RU":
		return CountryRu, nil
	case "RW":
		return CountryRw, nil
	case "SA":
		return CountrySa, nil
	case "SB":
		return CountrySb, nil
	case "SC":
		return CountrySc, nil
	case "SD":
		return CountrySd, nil
	case "SE":
		return CountrySe, nil
	case "SG":
		return CountrySg, nil
	case "SH":
		return CountrySh, nil
	case "SI":
		return CountrySi, nil
	case "SJ":
		return CountrySj, nil
	case "SK":
		return CountrySk, nil
	case "SL":
		return CountrySl, nil
	case "SM":
		return CountrySm, nil
	case "SN":
		return CountrySn, nil
	case "SO":
		return CountrySo, nil
	case "SR":
		return CountrySr, nil
	case "SS":
		return CountrySs, nil
	case "ST":
		return CountrySt, nil
	case "SV":
		return CountrySv, nil
	case "SX":
		return CountrySx, nil
	case "SY":
		return CountrySy, nil
	case "SZ":
		return CountrySz, nil
	case "TC":
		return CountryTc, nil
	case "TD":
		return CountryTd, nil
	case "TF":
		return CountryTf, nil
	case "TG":
		return CountryTg, nil
	case "TH":
		return CountryTh, nil
	case "TJ":
		return CountryTj, nil
	case "TK":
		return CountryTk, nil
	case "TL":
		return CountryTl, nil
	case "TM":
		return CountryTm, nil
	case "TN":
		return CountryTn, nil
	case "TO":
		return CountryTo, nil
	case "TR":
		return CountryTr, nil
	case "TT":
		return CountryTt, nil
	case "TV":
		return CountryTv, nil
	case "TW":
		return CountryTw, nil
	case "TZ":
		return CountryTz, nil
	case "UA":
		return CountryUa, nil
	case "UG":
		return CountryUg, nil
	case "UM":
		return CountryUm, nil
	case "US":
		return CountryUs, nil
	case "UY":
		return CountryUy, nil
	case "UZ":
		return CountryUz, nil
	case "VA":
		return CountryVa, nil
	case "VC":
		return CountryVc, nil
	case "VE":
		return CountryVe, nil
	case "VG":
		return CountryVg, nil
	case "VI":
		return CountryVi, nil
	case "VN":
		return CountryVn, nil
	case "VU":
		return CountryVu, nil
	case "WF":
		return CountryWf, nil
	case "WS":
		return CountryWs, nil
	case "YE":
		return CountryYe, nil
	case "YT":
		return CountryYt, nil
	case "ZA":
		return CountryZa, nil
	case "ZM":
		return CountryZm, nil
	case "ZW":
		return CountryZw, nil
	}
	var t Country
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c Country) Ptr() *Country {
	return &c
}

type CreateCatalogImageResponse struct {
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The newly created `CatalogImage` including a Square-generated
	// URL for the encapsulated image file.
	Image *CatalogObject `json:"image,omitempty" url:"image,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CreateCatalogImageResponse) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateCatalogImageResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler CreateCatalogImageResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CreateCatalogImageResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateCatalogImageResponse) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Defines the fields that are included in the response body of
// a request to the `CreateCustomerCard` endpoint.
//
// Either `errors` or `card` is present in a given response (never both).
type CreateCustomerCardResponse struct {
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The created card on file.
	Card *Card `json:"card,omitempty" url:"card,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CreateCustomerCardResponse) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateCustomerCardResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler CreateCustomerCardResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CreateCustomerCardResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateCustomerCardResponse) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Defines the fields that are included in the response body of
// a request to the [CreateCustomerGroup](api-endpoint:CustomerGroups-CreateCustomerGroup) endpoint.
//
// Either `errors` or `group` is present in a given response (never both).
type CreateCustomerGroupResponse struct {
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The successfully created customer group.
	Group *CustomerGroup `json:"group,omitempty" url:"group,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CreateCustomerGroupResponse) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateCustomerGroupResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler CreateCustomerGroupResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CreateCustomerGroupResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateCustomerGroupResponse) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreateDeviceCodeResponse struct {
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The created DeviceCode object containing the device code string.
	DeviceCode *DeviceCode `json:"device_code,omitempty" url:"device_code,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CreateDeviceCodeResponse) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateDeviceCodeResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler CreateDeviceCodeResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CreateDeviceCodeResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateDeviceCodeResponse) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// A response that contains a `GiftCardActivity` that was created.
// The response might contain a set of `Error` objects if the request resulted in errors.
type CreateGiftCardActivityResponse struct {
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The gift card activity that was created.
	GiftCardActivity *GiftCardActivity `json:"gift_card_activity,omitempty" url:"gift_card_activity,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CreateGiftCardActivityResponse) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateGiftCardActivityResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler CreateGiftCardActivityResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CreateGiftCardActivityResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateGiftCardActivityResponse) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// A response that includes loyalty account created.
type CreateLoyaltyAccountResponse struct {
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The newly created loyalty account.
	LoyaltyAccount *LoyaltyAccount `json:"loyalty_account,omitempty" url:"loyalty_account,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CreateLoyaltyAccountResponse) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateLoyaltyAccountResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler CreateLoyaltyAccountResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CreateLoyaltyAccountResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateLoyaltyAccountResponse) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Represents a [CreateLoyaltyPromotion](api-endpoint:Loyalty-CreateLoyaltyPromotion) response.
// Either `loyalty_promotion` or `errors` is present in the response.
type CreateLoyaltyPromotionResponse struct {
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The new loyalty promotion.
	LoyaltyPromotion *LoyaltyPromotion `json:"loyalty_promotion,omitempty" url:"loyalty_promotion,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CreateLoyaltyPromotionResponse) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateLoyaltyPromotionResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler CreateLoyaltyPromotionResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CreateLoyaltyPromotionResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateLoyaltyPromotionResponse) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// A response that includes the loyalty reward created.
type CreateLoyaltyRewardResponse struct {
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The loyalty reward created.
	Reward *LoyaltyReward `json:"reward,omitempty" url:"reward,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CreateLoyaltyRewardResponse) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateLoyaltyRewardResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler CreateLoyaltyRewardResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CreateLoyaltyRewardResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateLoyaltyRewardResponse) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreateOrderRequest struct {
	// The order to create. If this field is set, the only other top-level field that can be
	// set is the `idempotency_key`.
	Order *Order `json:"order,omitempty" url:"order,omitempty"`
	// A value you specify that uniquely identifies this
	// order among orders you have created.
	//
	// If you are unsure whether a particular order was created successfully,
	// you can try it again with the same idempotency key without
	// worrying about creating duplicate orders.
	//
	// For more information, see [Idempotency](https://developer.squareup.com/docs/basics/api101/idempotency).
	IdempotencyKey *string `json:"idempotency_key,omitempty" url:"idempotency_key,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CreateOrderRequest) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateOrderRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler CreateOrderRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CreateOrderRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateOrderRequest) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreatePaymentLinkResponse struct {
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The created payment link.
	PaymentLink *PaymentLink `json:"payment_link,omitempty" url:"payment_link,omitempty"`
	// The list of related objects.
	RelatedResources *PaymentLinkRelatedResources `json:"related_resources,omitempty" url:"related_resources,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CreatePaymentLinkResponse) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreatePaymentLinkResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler CreatePaymentLinkResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CreatePaymentLinkResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreatePaymentLinkResponse) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Defines the body parameters that can be included in
// a request to the [CreateRefund](api-endpoint:Transactions-CreateRefund) endpoint.
//
// Deprecated - recommend using [RefundPayment](api-endpoint:Refunds-RefundPayment)
type CreateRefundRequest struct {
	// A value you specify that uniquely identifies this
	// refund among refunds you've created for the tender.
	//
	// If you're unsure whether a particular refund succeeded,
	// you can reattempt it with the same idempotency key without
	// worrying about duplicating the refund.
	//
	// See [Idempotency keys](https://developer.squareup.com/docs/working-with-apis/idempotency) for more information.
	IdempotencyKey string `json:"idempotency_key" url:"idempotency_key"`
	// The ID of the tender to refund.
	//
	// A [`Transaction`](entity:Transaction) has one or more `tenders` (i.e., methods
	// of payment) associated with it, and you refund each tender separately with
	// the Connect API.
	TenderId string `json:"tender_id" url:"tender_id"`
	// A description of the reason for the refund.
	//
	// Default value: `Refund via API`
	Reason *string `json:"reason,omitempty" url:"reason,omitempty"`
	// The amount of money to refund.
	//
	// Note that you specify the amount in the
	// **smallest denomination of the applicable currency**. For example, US dollar
	// amounts are specified in cents. See
	// [Working with monetary amounts](https://developer.squareup.com/docs/build-basics/working-with-monetary-amounts) for details.
	//
	// This amount cannot exceed the amount that was originally charged to the
	// tender that corresponds to `tender_id`.
	AmountMoney *Money `json:"amount_money,omitempty" url:"amount_money,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CreateRefundRequest) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateRefundRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler CreateRefundRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CreateRefundRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateRefundRequest) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Defines the fields that are included in the response body of
// a request to the [CreateRefund](api-endpoint:Transactions-CreateRefund) endpoint.
//
// One of `errors` or `refund` is present in a given response (never both).
type CreateRefundResponse struct {
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The created refund.
	Refund *Refund `json:"refund,omitempty" url:"refund,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CreateRefundResponse) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateRefundResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler CreateRefundResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CreateRefundResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateRefundResponse) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// The response to a request to create a `Shift`. The response contains
// the created `Shift` object and might contain a set of `Error` objects if
// the request resulted in errors.
type CreateShiftResponse struct {
	// The `Shift` that was created on the request.
	Shift *Shift `json:"shift,omitempty" url:"shift,omitempty"`
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CreateShiftResponse) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateShiftResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler CreateShiftResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CreateShiftResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateShiftResponse) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreateTerminalActionResponse struct {
	// Information on errors encountered during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The created `TerminalAction`
	Action *TerminalAction `json:"action,omitempty" url:"action,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CreateTerminalActionResponse) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateTerminalActionResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler CreateTerminalActionResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CreateTerminalActionResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateTerminalActionResponse) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreateTerminalCheckoutResponse struct {
	// Information about errors encountered during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The created `TerminalCheckout`.
	Checkout *TerminalCheckout `json:"checkout,omitempty" url:"checkout,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CreateTerminalCheckoutResponse) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateTerminalCheckoutResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler CreateTerminalCheckoutResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CreateTerminalCheckoutResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateTerminalCheckoutResponse) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreateTerminalRefundResponse struct {
	// Information about errors encountered during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The created `TerminalRefund`.
	Refund *TerminalRefund `json:"refund,omitempty" url:"refund,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CreateTerminalRefundResponse) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateTerminalRefundResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler CreateTerminalRefundResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CreateTerminalRefundResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateTerminalRefundResponse) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Defines the fields that are included in the response body of
// a request to the [CreateWebhookSubscription](api-endpoint:WebhookSubscriptions-CreateWebhookSubscription) endpoint.
//
// Note: if there are errors processing the request, the [Subscription](entity:WebhookSubscription) will not be
// present.
type CreateWebhookSubscriptionResponse struct {
	// Information on errors encountered during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The new [Subscription](entity:WebhookSubscription).
	Subscription *WebhookSubscription `json:"subscription,omitempty" url:"subscription,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CreateWebhookSubscriptionResponse) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateWebhookSubscriptionResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler CreateWebhookSubscriptionResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CreateWebhookSubscriptionResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateWebhookSubscriptionResponse) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Indicates the associated currency for an amount of money. Values correspond
// to [ISO 4217](https://wikipedia.org/wiki/ISO_4217).
type Currency string

const (
	CurrencyUnknownCurrency Currency = "UNKNOWN_CURRENCY"
	CurrencyAed             Currency = "AED"
	CurrencyAfn             Currency = "AFN"
	CurrencyAll             Currency = "ALL"
	CurrencyAmd             Currency = "AMD"
	CurrencyAng             Currency = "ANG"
	CurrencyAoa             Currency = "AOA"
	CurrencyArs             Currency = "ARS"
	CurrencyAud             Currency = "AUD"
	CurrencyAwg             Currency = "AWG"
	CurrencyAzn             Currency = "AZN"
	CurrencyBam             Currency = "BAM"
	CurrencyBbd             Currency = "BBD"
	CurrencyBdt             Currency = "BDT"
	CurrencyBgn             Currency = "BGN"
	CurrencyBhd             Currency = "BHD"
	CurrencyBif             Currency = "BIF"
	CurrencyBmd             Currency = "BMD"
	CurrencyBnd             Currency = "BND"
	CurrencyBob             Currency = "BOB"
	CurrencyBov             Currency = "BOV"
	CurrencyBrl             Currency = "BRL"
	CurrencyBsd             Currency = "BSD"
	CurrencyBtn             Currency = "BTN"
	CurrencyBwp             Currency = "BWP"
	CurrencyByr             Currency = "BYR"
	CurrencyBzd             Currency = "BZD"
	CurrencyCad             Currency = "CAD"
	CurrencyCdf             Currency = "CDF"
	CurrencyChe             Currency = "CHE"
	CurrencyChf             Currency = "CHF"
	CurrencyChw             Currency = "CHW"
	CurrencyClf             Currency = "CLF"
	CurrencyClp             Currency = "CLP"
	CurrencyCny             Currency = "CNY"
	CurrencyCop             Currency = "COP"
	CurrencyCou             Currency = "COU"
	CurrencyCrc             Currency = "CRC"
	CurrencyCuc             Currency = "CUC"
	CurrencyCup             Currency = "CUP"
	CurrencyCve             Currency = "CVE"
	CurrencyCzk             Currency = "CZK"
	CurrencyDjf             Currency = "DJF"
	CurrencyDkk             Currency = "DKK"
	CurrencyDop             Currency = "DOP"
	CurrencyDzd             Currency = "DZD"
	CurrencyEgp             Currency = "EGP"
	CurrencyErn             Currency = "ERN"
	CurrencyEtb             Currency = "ETB"
	CurrencyEur             Currency = "EUR"
	CurrencyFjd             Currency = "FJD"
	CurrencyFkp             Currency = "FKP"
	CurrencyGbp             Currency = "GBP"
	CurrencyGel             Currency = "GEL"
	CurrencyGhs             Currency = "GHS"
	CurrencyGip             Currency = "GIP"
	CurrencyGmd             Currency = "GMD"
	CurrencyGnf             Currency = "GNF"
	CurrencyGtq             Currency = "GTQ"
	CurrencyGyd             Currency = "GYD"
	CurrencyHkd             Currency = "HKD"
	CurrencyHnl             Currency = "HNL"
	CurrencyHrk             Currency = "HRK"
	CurrencyHtg             Currency = "HTG"
	CurrencyHuf             Currency = "HUF"
	CurrencyIdr             Currency = "IDR"
	CurrencyIls             Currency = "ILS"
	CurrencyInr             Currency = "INR"
	CurrencyIqd             Currency = "IQD"
	CurrencyIrr             Currency = "IRR"
	CurrencyIsk             Currency = "ISK"
	CurrencyJmd             Currency = "JMD"
	CurrencyJod             Currency = "JOD"
	CurrencyJpy             Currency = "JPY"
	CurrencyKes             Currency = "KES"
	CurrencyKgs             Currency = "KGS"
	CurrencyKhr             Currency = "KHR"
	CurrencyKmf             Currency = "KMF"
	CurrencyKpw             Currency = "KPW"
	CurrencyKrw             Currency = "KRW"
	CurrencyKwd             Currency = "KWD"
	CurrencyKyd             Currency = "KYD"
	CurrencyKzt             Currency = "KZT"
	CurrencyLak             Currency = "LAK"
	CurrencyLbp             Currency = "LBP"
	CurrencyLkr             Currency = "LKR"
	CurrencyLrd             Currency = "LRD"
	CurrencyLsl             Currency = "LSL"
	CurrencyLtl             Currency = "LTL"
	CurrencyLvl             Currency = "LVL"
	CurrencyLyd             Currency = "LYD"
	CurrencyMad             Currency = "MAD"
	CurrencyMdl             Currency = "MDL"
	CurrencyMga             Currency = "MGA"
	CurrencyMkd             Currency = "MKD"
	CurrencyMmk             Currency = "MMK"
	CurrencyMnt             Currency = "MNT"
	CurrencyMop             Currency = "MOP"
	CurrencyMro             Currency = "MRO"
	CurrencyMur             Currency = "MUR"
	CurrencyMvr             Currency = "MVR"
	CurrencyMwk             Currency = "MWK"
	CurrencyMxn             Currency = "MXN"
	CurrencyMxv             Currency = "MXV"
	CurrencyMyr             Currency = "MYR"
	CurrencyMzn             Currency = "MZN"
	CurrencyNad             Currency = "NAD"
	CurrencyNgn             Currency = "NGN"
	CurrencyNio             Currency = "NIO"
	CurrencyNok             Currency = "NOK"
	CurrencyNpr             Currency = "NPR"
	CurrencyNzd             Currency = "NZD"
	CurrencyOmr             Currency = "OMR"
	CurrencyPab             Currency = "PAB"
	CurrencyPen             Currency = "PEN"
	CurrencyPgk             Currency = "PGK"
	CurrencyPhp             Currency = "PHP"
	CurrencyPkr             Currency = "PKR"
	CurrencyPln             Currency = "PLN"
	CurrencyPyg             Currency = "PYG"
	CurrencyQar             Currency = "QAR"
	CurrencyRon             Currency = "RON"
	CurrencyRsd             Currency = "RSD"
	CurrencyRub             Currency = "RUB"
	CurrencyRwf             Currency = "RWF"
	CurrencySar             Currency = "SAR"
	CurrencySbd             Currency = "SBD"
	CurrencyScr             Currency = "SCR"
	CurrencySdg             Currency = "SDG"
	CurrencySek             Currency = "SEK"
	CurrencySgd             Currency = "SGD"
	CurrencyShp             Currency = "SHP"
	CurrencySll             Currency = "SLL"
	CurrencySos             Currency = "SOS"
	CurrencySrd             Currency = "SRD"
	CurrencySsp             Currency = "SSP"
	CurrencyStd             Currency = "STD"
	CurrencySvc             Currency = "SVC"
	CurrencySyp             Currency = "SYP"
	CurrencySzl             Currency = "SZL"
	CurrencyThb             Currency = "THB"
	CurrencyTjs             Currency = "TJS"
	CurrencyTmt             Currency = "TMT"
	CurrencyTnd             Currency = "TND"
	CurrencyTop             Currency = "TOP"
	CurrencyTry             Currency = "TRY"
	CurrencyTtd             Currency = "TTD"
	CurrencyTwd             Currency = "TWD"
	CurrencyTzs             Currency = "TZS"
	CurrencyUah             Currency = "UAH"
	CurrencyUgx             Currency = "UGX"
	CurrencyUsd             Currency = "USD"
	CurrencyUsn             Currency = "USN"
	CurrencyUss             Currency = "USS"
	CurrencyUyi             Currency = "UYI"
	CurrencyUyu             Currency = "UYU"
	CurrencyUzs             Currency = "UZS"
	CurrencyVef             Currency = "VEF"
	CurrencyVnd             Currency = "VND"
	CurrencyVuv             Currency = "VUV"
	CurrencyWst             Currency = "WST"
	CurrencyXaf             Currency = "XAF"
	CurrencyXag             Currency = "XAG"
	CurrencyXau             Currency = "XAU"
	CurrencyXba             Currency = "XBA"
	CurrencyXbb             Currency = "XBB"
	CurrencyXbc             Currency = "XBC"
	CurrencyXbd             Currency = "XBD"
	CurrencyXcd             Currency = "XCD"
	CurrencyXdr             Currency = "XDR"
	CurrencyXof             Currency = "XOF"
	CurrencyXpd             Currency = "XPD"
	CurrencyXpf             Currency = "XPF"
	CurrencyXpt             Currency = "XPT"
	CurrencyXts             Currency = "XTS"
	CurrencyXxx             Currency = "XXX"
	CurrencyYer             Currency = "YER"
	CurrencyZar             Currency = "ZAR"
	CurrencyZmk             Currency = "ZMK"
	CurrencyZmw             Currency = "ZMW"
	CurrencyBtc             Currency = "BTC"
)

func NewCurrencyFromString(s string) (Currency, error) {
	switch s {
	case "UNKNOWN_CURRENCY":
		return CurrencyUnknownCurrency, nil
	case "AED":
		return CurrencyAed, nil
	case "AFN":
		return CurrencyAfn, nil
	case "ALL":
		return CurrencyAll, nil
	case "AMD":
		return CurrencyAmd, nil
	case "ANG":
		return CurrencyAng, nil
	case "AOA":
		return CurrencyAoa, nil
	case "ARS":
		return CurrencyArs, nil
	case "AUD":
		return CurrencyAud, nil
	case "AWG":
		return CurrencyAwg, nil
	case "AZN":
		return CurrencyAzn, nil
	case "BAM":
		return CurrencyBam, nil
	case "BBD":
		return CurrencyBbd, nil
	case "BDT":
		return CurrencyBdt, nil
	case "BGN":
		return CurrencyBgn, nil
	case "BHD":
		return CurrencyBhd, nil
	case "BIF":
		return CurrencyBif, nil
	case "BMD":
		return CurrencyBmd, nil
	case "BND":
		return CurrencyBnd, nil
	case "BOB":
		return CurrencyBob, nil
	case "BOV":
		return CurrencyBov, nil
	case "BRL":
		return CurrencyBrl, nil
	case "BSD":
		return CurrencyBsd, nil
	case "BTN":
		return CurrencyBtn, nil
	case "BWP":
		return CurrencyBwp, nil
	case "BYR":
		return CurrencyByr, nil
	case "BZD":
		return CurrencyBzd, nil
	case "CAD":
		return CurrencyCad, nil
	case "CDF":
		return CurrencyCdf, nil
	case "CHE":
		return CurrencyChe, nil
	case "CHF":
		return CurrencyChf, nil
	case "CHW":
		return CurrencyChw, nil
	case "CLF":
		return CurrencyClf, nil
	case "CLP":
		return CurrencyClp, nil
	case "CNY":
		return CurrencyCny, nil
	case "COP":
		return CurrencyCop, nil
	case "COU":
		return CurrencyCou, nil
	case "CRC":
		return CurrencyCrc, nil
	case "CUC":
		return CurrencyCuc, nil
	case "CUP":
		return CurrencyCup, nil
	case "CVE":
		return CurrencyCve, nil
	case "CZK":
		return CurrencyCzk, nil
	case "DJF":
		return CurrencyDjf, nil
	case "DKK":
		return CurrencyDkk, nil
	case "DOP":
		return CurrencyDop, nil
	case "DZD":
		return CurrencyDzd, nil
	case "EGP":
		return CurrencyEgp, nil
	case "ERN":
		return CurrencyErn, nil
	case "ETB":
		return CurrencyEtb, nil
	case "EUR":
		return CurrencyEur, nil
	case "FJD":
		return CurrencyFjd, nil
	case "FKP":
		return CurrencyFkp, nil
	case "GBP":
		return CurrencyGbp, nil
	case "GEL":
		return CurrencyGel, nil
	case "GHS":
		return CurrencyGhs, nil
	case "GIP":
		return CurrencyGip, nil
	case "GMD":
		return CurrencyGmd, nil
	case "GNF":
		return CurrencyGnf, nil
	case "GTQ":
		return CurrencyGtq, nil
	case "GYD":
		return CurrencyGyd, nil
	case "HKD":
		return CurrencyHkd, nil
	case "HNL":
		return CurrencyHnl, nil
	case "HRK":
		return CurrencyHrk, nil
	case "HTG":
		return CurrencyHtg, nil
	case "HUF":
		return CurrencyHuf, nil
	case "IDR":
		return CurrencyIdr, nil
	case "ILS":
		return CurrencyIls, nil
	case "INR":
		return CurrencyInr, nil
	case "IQD":
		return CurrencyIqd, nil
	case "IRR":
		return CurrencyIrr, nil
	case "ISK":
		return CurrencyIsk, nil
	case "JMD":
		return CurrencyJmd, nil
	case "JOD":
		return CurrencyJod, nil
	case "JPY":
		return CurrencyJpy, nil
	case "KES":
		return CurrencyKes, nil
	case "KGS":
		return CurrencyKgs, nil
	case "KHR":
		return CurrencyKhr, nil
	case "KMF":
		return CurrencyKmf, nil
	case "KPW":
		return CurrencyKpw, nil
	case "KRW":
		return CurrencyKrw, nil
	case "KWD":
		return CurrencyKwd, nil
	case "KYD":
		return CurrencyKyd, nil
	case "KZT":
		return CurrencyKzt, nil
	case "LAK":
		return CurrencyLak, nil
	case "LBP":
		return CurrencyLbp, nil
	case "LKR":
		return CurrencyLkr, nil
	case "LRD":
		return CurrencyLrd, nil
	case "LSL":
		return CurrencyLsl, nil
	case "LTL":
		return CurrencyLtl, nil
	case "LVL":
		return CurrencyLvl, nil
	case "LYD":
		return CurrencyLyd, nil
	case "MAD":
		return CurrencyMad, nil
	case "MDL":
		return CurrencyMdl, nil
	case "MGA":
		return CurrencyMga, nil
	case "MKD":
		return CurrencyMkd, nil
	case "MMK":
		return CurrencyMmk, nil
	case "MNT":
		return CurrencyMnt, nil
	case "MOP":
		return CurrencyMop, nil
	case "MRO":
		return CurrencyMro, nil
	case "MUR":
		return CurrencyMur, nil
	case "MVR":
		return CurrencyMvr, nil
	case "MWK":
		return CurrencyMwk, nil
	case "MXN":
		return CurrencyMxn, nil
	case "MXV":
		return CurrencyMxv, nil
	case "MYR":
		return CurrencyMyr, nil
	case "MZN":
		return CurrencyMzn, nil
	case "NAD":
		return CurrencyNad, nil
	case "NGN":
		return CurrencyNgn, nil
	case "NIO":
		return CurrencyNio, nil
	case "NOK":
		return CurrencyNok, nil
	case "NPR":
		return CurrencyNpr, nil
	case "NZD":
		return CurrencyNzd, nil
	case "OMR":
		return CurrencyOmr, nil
	case "PAB":
		return CurrencyPab, nil
	case "PEN":
		return CurrencyPen, nil
	case "PGK":
		return CurrencyPgk, nil
	case "PHP":
		return CurrencyPhp, nil
	case "PKR":
		return CurrencyPkr, nil
	case "PLN":
		return CurrencyPln, nil
	case "PYG":
		return CurrencyPyg, nil
	case "QAR":
		return CurrencyQar, nil
	case "RON":
		return CurrencyRon, nil
	case "RSD":
		return CurrencyRsd, nil
	case "RUB":
		return CurrencyRub, nil
	case "RWF":
		return CurrencyRwf, nil
	case "SAR":
		return CurrencySar, nil
	case "SBD":
		return CurrencySbd, nil
	case "SCR":
		return CurrencyScr, nil
	case "SDG":
		return CurrencySdg, nil
	case "SEK":
		return CurrencySek, nil
	case "SGD":
		return CurrencySgd, nil
	case "SHP":
		return CurrencyShp, nil
	case "SLL":
		return CurrencySll, nil
	case "SOS":
		return CurrencySos, nil
	case "SRD":
		return CurrencySrd, nil
	case "SSP":
		return CurrencySsp, nil
	case "STD":
		return CurrencyStd, nil
	case "SVC":
		return CurrencySvc, nil
	case "SYP":
		return CurrencySyp, nil
	case "SZL":
		return CurrencySzl, nil
	case "THB":
		return CurrencyThb, nil
	case "TJS":
		return CurrencyTjs, nil
	case "TMT":
		return CurrencyTmt, nil
	case "TND":
		return CurrencyTnd, nil
	case "TOP":
		return CurrencyTop, nil
	case "TRY":
		return CurrencyTry, nil
	case "TTD":
		return CurrencyTtd, nil
	case "TWD":
		return CurrencyTwd, nil
	case "TZS":
		return CurrencyTzs, nil
	case "UAH":
		return CurrencyUah, nil
	case "UGX":
		return CurrencyUgx, nil
	case "USD":
		return CurrencyUsd, nil
	case "USN":
		return CurrencyUsn, nil
	case "USS":
		return CurrencyUss, nil
	case "UYI":
		return CurrencyUyi, nil
	case "UYU":
		return CurrencyUyu, nil
	case "UZS":
		return CurrencyUzs, nil
	case "VEF":
		return CurrencyVef, nil
	case "VND":
		return CurrencyVnd, nil
	case "VUV":
		return CurrencyVuv, nil
	case "WST":
		return CurrencyWst, nil
	case "XAF":
		return CurrencyXaf, nil
	case "XAG":
		return CurrencyXag, nil
	case "XAU":
		return CurrencyXau, nil
	case "XBA":
		return CurrencyXba, nil
	case "XBB":
		return CurrencyXbb, nil
	case "XBC":
		return CurrencyXbc, nil
	case "XBD":
		return CurrencyXbd, nil
	case "XCD":
		return CurrencyXcd, nil
	case "XDR":
		return CurrencyXdr, nil
	case "XOF":
		return CurrencyXof, nil
	case "XPD":
		return CurrencyXpd, nil
	case "XPF":
		return CurrencyXpf, nil
	case "XPT":
		return CurrencyXpt, nil
	case "XTS":
		return CurrencyXts, nil
	case "XXX":
		return CurrencyXxx, nil
	case "YER":
		return CurrencyYer, nil
	case "ZAR":
		return CurrencyZar, nil
	case "ZMK":
		return CurrencyZmk, nil
	case "ZMW":
		return CurrencyZmw, nil
	case "BTC":
		return CurrencyBtc, nil
	}
	var t Currency
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c Currency) Ptr() *Currency {
	return &c
}

// A custom attribute value. Each custom attribute value has a corresponding
// `CustomAttributeDefinition` object.
type CustomAttribute struct {
	// The identifier
	// of the custom attribute definition and its corresponding custom attributes. This value
	// can be a simple key, which is the key that is provided when the custom attribute definition
	// is created, or a qualified key, if the requesting
	// application is not the definition owner. The qualified key consists of the application ID
	// of the custom attribute definition owner
	// followed by the simple key that was provided when the definition was created. It has the
	// format application_id:simple key.
	//
	// The value for a simple key can contain up to 60 alphanumeric characters, periods (.),
	// underscores (\_), and hyphens (-).
	Key   *string     `json:"key,omitempty" url:"key,omitempty"`
	Value interface{} `json:"value,omitempty" url:"value,omitempty"`
	// Read only. The current version of the custom attribute. This field is incremented when the custom attribute is changed.
	// When updating an existing custom attribute value, you can provide this field
	// and specify the current version of the custom attribute to enable
	// [optimistic concurrency](https://developer.squareup.com/docs/build-basics/common-api-patterns/optimistic-concurrency).
	// This field can also be used to enforce strong consistency for reads. For more information about strong consistency for reads,
	// see [Custom Attributes Overview](https://developer.squareup.com/docs/devtools/customattributes/overview).
	Version *int `json:"version,omitempty" url:"version,omitempty"`
	// A copy of the `visibility` field value for the associated custom attribute definition.
	// See [CustomAttributeDefinitionVisibility](#type-customattributedefinitionvisibility) for possible values
	Visibility *CustomAttributeDefinitionVisibility `json:"visibility,omitempty" url:"visibility,omitempty"`
	// A copy of the associated custom attribute definition object. This field is only set when
	// the optional field is specified on the request.
	Definition *CustomAttributeDefinition `json:"definition,omitempty" url:"definition,omitempty"`
	// The timestamp that indicates when the custom attribute was created or was most recently
	// updated, in RFC 3339 format.
	UpdatedAt *string `json:"updated_at,omitempty" url:"updated_at,omitempty"`
	// The timestamp that indicates when the custom attribute was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CustomAttribute) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CustomAttribute) UnmarshalJSON(data []byte) error {
	type unmarshaler CustomAttribute
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CustomAttribute(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CustomAttribute) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// The level of permission that a seller or other applications requires to
// view this custom attribute definition.
// The `Visibility` field controls who can read and write the custom attribute values
// and custom attribute definition.
type CustomAttributeDefinitionVisibility string

const (
	CustomAttributeDefinitionVisibilityVisibilityDoNotUse        CustomAttributeDefinitionVisibility = "VISIBILITY_DO_NOT_USE"
	CustomAttributeDefinitionVisibilityVisibilityHidden          CustomAttributeDefinitionVisibility = "VISIBILITY_HIDDEN"
	CustomAttributeDefinitionVisibilityVisibilityReadOnly        CustomAttributeDefinitionVisibility = "VISIBILITY_READ_ONLY"
	CustomAttributeDefinitionVisibilityVisibilityReadWriteValues CustomAttributeDefinitionVisibility = "VISIBILITY_READ_WRITE_VALUES"
)

func NewCustomAttributeDefinitionVisibilityFromString(s string) (CustomAttributeDefinitionVisibility, error) {
	switch s {
	case "VISIBILITY_DO_NOT_USE":
		return CustomAttributeDefinitionVisibilityVisibilityDoNotUse, nil
	case "VISIBILITY_HIDDEN":
		return CustomAttributeDefinitionVisibilityVisibilityHidden, nil
	case "VISIBILITY_READ_ONLY":
		return CustomAttributeDefinitionVisibilityVisibilityReadOnly, nil
	case "VISIBILITY_READ_WRITE_VALUES":
		return CustomAttributeDefinitionVisibilityVisibilityReadWriteValues, nil
	}
	var t CustomAttributeDefinitionVisibility
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CustomAttributeDefinitionVisibility) Ptr() *CustomAttributeDefinitionVisibility {
	return &c
}

// Represents an object in the CustomAttributeDefintion event notification
// payload that contains the affected custom attribute definition.
type CustomAttributeDefinitionWebhookData struct {
	// The type of the event data object. The value is `"custom_attribute_definition"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// The ID of the event data object.
	Id *string `json:"id,omitempty" url:"id,omitempty"`
	// An object containing the custom attribute definition.
	Object *CustomAttributeDefinitionWebhookDataObject `json:"object,omitempty" url:"object,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CustomAttributeDefinitionWebhookData) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CustomAttributeDefinitionWebhookData) UnmarshalJSON(data []byte) error {
	type unmarshaler CustomAttributeDefinitionWebhookData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CustomAttributeDefinitionWebhookData(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CustomAttributeDefinitionWebhookData) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CustomAttributeDefinitionWebhookDataObject struct {
	// The custom attribute definition.
	CustomAttributeDefinition *CustomAttributeDefinition `json:"custom_attribute_definition,omitempty" url:"custom_attribute_definition,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CustomAttributeDefinitionWebhookDataObject) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CustomAttributeDefinitionWebhookDataObject) UnmarshalJSON(data []byte) error {
	type unmarshaler CustomAttributeDefinitionWebhookDataObject
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CustomAttributeDefinitionWebhookDataObject(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CustomAttributeDefinitionWebhookDataObject) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CustomAttributeWebhookData struct {
	// The type of the event data object. The value is `"custom_attribute"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// The ID of the event data object.
	Id *string `json:"id,omitempty" url:"id,omitempty"`
	// An object containing the custom attribute.
	Object *CustomAttributeWebhookDataObject `json:"object,omitempty" url:"object,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CustomAttributeWebhookData) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CustomAttributeWebhookData) UnmarshalJSON(data []byte) error {
	type unmarshaler CustomAttributeWebhookData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CustomAttributeWebhookData(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CustomAttributeWebhookData) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CustomAttributeWebhookDataObject struct {
	// The custom attribute.
	CustomAttribute *CustomAttribute `json:"custom_attribute,omitempty" url:"custom_attribute,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CustomAttributeWebhookDataObject) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CustomAttributeWebhookDataObject) UnmarshalJSON(data []byte) error {
	type unmarshaler CustomAttributeWebhookDataObject
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CustomAttributeWebhookDataObject(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CustomAttributeWebhookDataObject) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Describes a custom form field to add to the checkout page to collect more information from buyers during checkout.
// For more information,
// see [Specify checkout options](https://developer.squareup.com/docs/checkout-api/optional-checkout-configurations#specify-checkout-options-1).
type CustomField struct {
	// The title of the custom field.
	Title string `json:"title" url:"title"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CustomField) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CustomField) UnmarshalJSON(data []byte) error {
	type unmarshaler CustomField
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CustomField(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CustomField) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Represents a Square customer profile in the Customer Directory of a Square seller.
type Customer struct {
	// A unique Square-assigned ID for the customer profile.
	//
	// If you need this ID for an API request, use the ID returned when you created the customer profile or call the [SearchCustomers](api-endpoint:Customers-SearchCustomers)
	// or [ListCustomers](api-endpoint:Customers-ListCustomers) endpoint.
	Id *string `json:"id,omitempty" url:"id,omitempty"`
	// The timestamp when the customer profile was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The timestamp when the customer profile was last updated, in RFC 3339 format.
	UpdatedAt *string `json:"updated_at,omitempty" url:"updated_at,omitempty"`
	// Payment details of the credit, debit, and gift cards stored on file for the customer profile.
	//
	// DEPRECATED at version 2021-06-16. Replaced by calling [ListCards](api-endpoint:Cards-ListCards) (for credit and debit cards on file)
	// or [ListGiftCards](api-endpoint:GiftCards-ListGiftCards) (for gift cards on file) and including the `customer_id` query parameter.
	// For more information, see [Migration notes](https://developer.squareup.com/docs/customers-api/what-it-does#migrate-customer-cards).
	Cards []*Card `json:"cards,omitempty" url:"cards,omitempty"`
	// The given name (that is, the first name) associated with the customer profile.
	GivenName *string `json:"given_name,omitempty" url:"given_name,omitempty"`
	// The family name (that is, the last name) associated with the customer profile.
	FamilyName *string `json:"family_name,omitempty" url:"family_name,omitempty"`
	// A nickname for the customer profile.
	Nickname *string `json:"nickname,omitempty" url:"nickname,omitempty"`
	// A business name associated with the customer profile.
	CompanyName *string `json:"company_name,omitempty" url:"company_name,omitempty"`
	// The email address associated with the customer profile.
	EmailAddress *string `json:"email_address,omitempty" url:"email_address,omitempty"`
	// The physical address associated with the customer profile.
	Address *Address `json:"address,omitempty" url:"address,omitempty"`
	// The phone number associated with the customer profile. A phone number can contain 9–16 digits, with an optional `+` prefix.
	PhoneNumber *string `json:"phone_number,omitempty" url:"phone_number,omitempty"`
	// The birthday associated with the customer profile, in RFC 3339 format. The year is optional. The timezone and time are not allowed.
	// For example, `0000-09-21T00:00:00-00:00` represents a birthday on September 21 and `1998-09-21T00:00:00-00:00` represents a birthday on September 21, 1998.
	Birthday *string `json:"birthday,omitempty" url:"birthday,omitempty"`
	// An optional second ID used to associate the customer profile with an
	// entity in another system.
	ReferenceId *string `json:"reference_id,omitempty" url:"reference_id,omitempty"`
	// A custom note associated with the customer profile.
	Note *string `json:"note,omitempty" url:"note,omitempty"`
	// Represents general customer preferences.
	Preferences *CustomerPreferences `json:"preferences,omitempty" url:"preferences,omitempty"`
	// The customer groups and segments the customer belongs to. This deprecated field has been replaced with the dedicated `group_ids` for customer groups and the dedicated `segment_ids` field for customer segments. You can retrieve information about a given customer group and segment respectively using the Customer Groups API and Customer Segments API.
	Groups []*CustomerGroupInfo `json:"groups,omitempty" url:"groups,omitempty"`
	// The method used to create the customer profile.
	// See [CustomerCreationSource](#type-customercreationsource) for possible values
	CreationSource *CustomerCreationSource `json:"creation_source,omitempty" url:"creation_source,omitempty"`
	// The IDs of customer groups the customer belongs to.
	GroupIds []string `json:"group_ids,omitempty" url:"group_ids,omitempty"`
	// The IDs of segments the customer belongs to.
	SegmentIds []string `json:"segment_ids,omitempty" url:"segment_ids,omitempty"`
	// The Square-assigned version number of the customer profile. The version number is incremented each time an update is committed to the customer profile, except for changes to customer segment membership and cards on file.
	Version *int64 `json:"version,omitempty" url:"version,omitempty"`
	// The tax ID associated with the customer profile. This field is present only for customers of sellers in EU countries or the United Kingdom.
	// For more information, see [Customer tax IDs](https://developer.squareup.com/docs/customers-api/what-it-does#customer-tax-ids).
	TaxIds *CustomerTaxIds `json:"tax_ids,omitempty" url:"tax_ids,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *Customer) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *Customer) UnmarshalJSON(data []byte) error {
	type unmarshaler Customer
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = Customer(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *Customer) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// The customer address filter. This filter is used in a [CustomerCustomAttributeFilterValue](entity:CustomerCustomAttributeFilterValue) filter when
// searching by an `Address`-type custom attribute.
type CustomerAddressFilter struct {
	// The postal code to search for. Only an `exact` match is supported.
	PostalCode *CustomerTextFilter `json:"postal_code,omitempty" url:"postal_code,omitempty"`
	// The country code to search for.
	// See [Country](#type-country) for possible values
	Country *Country `json:"country,omitempty" url:"country,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CustomerAddressFilter) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CustomerAddressFilter) UnmarshalJSON(data []byte) error {
	type unmarshaler CustomerAddressFilter
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CustomerAddressFilter(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CustomerAddressFilter) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Published when a [customer](entity:Customer) is created. For more information, see [Use Customer Webhooks](https://developer.squareup.com/docs/customers-api/use-the-api/customer-webhooks).
//
// The `customer` object in the event notification does not include the following fields: `cards` (deprecated) and `segment_ids`.
type CustomerCreatedWebhook struct {
	// The ID of the seller associated with the event.
	MerchantId *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The type of event. For this object, the value is `customer.created`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// The unique ID of the event, which is used for [idempotency support](https://developer.squareup.com/docs/webhooks/step4manage#webhooks-best-practices).
	EventId *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// The timestamp of when the event was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The data associated with the event.
	Data *CustomerCreatedWebhookData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CustomerCreatedWebhook) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CustomerCreatedWebhook) UnmarshalJSON(data []byte) error {
	type unmarshaler CustomerCreatedWebhook
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CustomerCreatedWebhook(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CustomerCreatedWebhook) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// The data associated with the webhook event.
type CustomerCreatedWebhookData struct {
	// The type of object affected by the event. For this event, the value is `customer`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// The ID of the new customer.
	Id *string `json:"id,omitempty" url:"id,omitempty"`
	// An object that contains the new customer.
	Object *CustomerCreatedWebhookObject `json:"object,omitempty" url:"object,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CustomerCreatedWebhookData) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CustomerCreatedWebhookData) UnmarshalJSON(data []byte) error {
	type unmarshaler CustomerCreatedWebhookData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CustomerCreatedWebhookData(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CustomerCreatedWebhookData) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Information about the change that triggered the event.
type CustomerCreatedWebhookEventContext struct {
	// Information about the merge operation associated with the event.
	Merge *CustomerCreatedWebhookEventContextMerge `json:"merge,omitempty" url:"merge,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CustomerCreatedWebhookEventContext) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CustomerCreatedWebhookEventContext) UnmarshalJSON(data []byte) error {
	type unmarshaler CustomerCreatedWebhookEventContext
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CustomerCreatedWebhookEventContext(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CustomerCreatedWebhookEventContext) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Information about a merge operation, which creates a new customer using aggregated properties from two or more existing customers.
type CustomerCreatedWebhookEventContextMerge struct {
	// The IDs of the existing customers that were merged and then deleted.
	FromCustomerIds []string `json:"from_customer_ids,omitempty" url:"from_customer_ids,omitempty"`
	// The ID of the new customer created by the merge.
	ToCustomerId *string `json:"to_customer_id,omitempty" url:"to_customer_id,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CustomerCreatedWebhookEventContextMerge) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CustomerCreatedWebhookEventContextMerge) UnmarshalJSON(data []byte) error {
	type unmarshaler CustomerCreatedWebhookEventContextMerge
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CustomerCreatedWebhookEventContextMerge(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CustomerCreatedWebhookEventContextMerge) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// An object that contains the customer associated with the webhook event.
type CustomerCreatedWebhookObject struct {
	// The new customer.
	Customer *Customer `json:"customer,omitempty" url:"customer,omitempty"`
	// Information about the change that triggered the event. This field is returned only if the customer is created by a merge operation.
	EventContext *CustomerCreatedWebhookEventContext `json:"event_context,omitempty" url:"event_context,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CustomerCreatedWebhookObject) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CustomerCreatedWebhookObject) UnmarshalJSON(data []byte) error {
	type unmarshaler CustomerCreatedWebhookObject
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CustomerCreatedWebhookObject(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CustomerCreatedWebhookObject) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Indicates the method used to create the customer profile.
type CustomerCreationSource string

const (
	CustomerCreationSourceOther            CustomerCreationSource = "OTHER"
	CustomerCreationSourceAppointments     CustomerCreationSource = "APPOINTMENTS"
	CustomerCreationSourceCoupon           CustomerCreationSource = "COUPON"
	CustomerCreationSourceDeletionRecovery CustomerCreationSource = "DELETION_RECOVERY"
	CustomerCreationSourceDirectory        CustomerCreationSource = "DIRECTORY"
	CustomerCreationSourceEgifting         CustomerCreationSource = "EGIFTING"
	CustomerCreationSourceEmailCollection  CustomerCreationSource = "EMAIL_COLLECTION"
	CustomerCreationSourceFeedback         CustomerCreationSource = "FEEDBACK"
	CustomerCreationSourceImport           CustomerCreationSource = "IMPORT"
	CustomerCreationSourceInvoices         CustomerCreationSource = "INVOICES"
	CustomerCreationSourceLoyalty          CustomerCreationSource = "LOYALTY"
	CustomerCreationSourceMarketing        CustomerCreationSource = "MARKETING"
	CustomerCreationSourceMerge            CustomerCreationSource = "MERGE"
	CustomerCreationSourceOnlineStore      CustomerCreationSource = "ONLINE_STORE"
	CustomerCreationSourceInstantProfile   CustomerCreationSource = "INSTANT_PROFILE"
	CustomerCreationSourceTerminal         CustomerCreationSource = "TERMINAL"
	CustomerCreationSourceThirdParty       CustomerCreationSource = "THIRD_PARTY"
	CustomerCreationSourceThirdPartyImport CustomerCreationSource = "THIRD_PARTY_IMPORT"
	CustomerCreationSourceUnmergeRecovery  CustomerCreationSource = "UNMERGE_RECOVERY"
)

func NewCustomerCreationSourceFromString(s string) (CustomerCreationSource, error) {
	switch s {
	case "OTHER":
		return CustomerCreationSourceOther, nil
	case "APPOINTMENTS":
		return CustomerCreationSourceAppointments, nil
	case "COUPON":
		return CustomerCreationSourceCoupon, nil
	case "DELETION_RECOVERY":
		return CustomerCreationSourceDeletionRecovery, nil
	case "DIRECTORY":
		return CustomerCreationSourceDirectory, nil
	case "EGIFTING":
		return CustomerCreationSourceEgifting, nil
	case "EMAIL_COLLECTION":
		return CustomerCreationSourceEmailCollection, nil
	case "FEEDBACK":
		return CustomerCreationSourceFeedback, nil
	case "IMPORT":
		return CustomerCreationSourceImport, nil
	case "INVOICES":
		return CustomerCreationSourceInvoices, nil
	case "LOYALTY":
		return CustomerCreationSourceLoyalty, nil
	case "MARKETING":
		return CustomerCreationSourceMarketing, nil
	case "MERGE":
		return CustomerCreationSourceMerge, nil
	case "ONLINE_STORE":
		return CustomerCreationSourceOnlineStore, nil
	case "INSTANT_PROFILE":
		return CustomerCreationSourceInstantProfile, nil
	case "TERMINAL":
		return CustomerCreationSourceTerminal, nil
	case "THIRD_PARTY":
		return CustomerCreationSourceThirdParty, nil
	case "THIRD_PARTY_IMPORT":
		return CustomerCreationSourceThirdPartyImport, nil
	case "UNMERGE_RECOVERY":
		return CustomerCreationSourceUnmergeRecovery, nil
	}
	var t CustomerCreationSource
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CustomerCreationSource) Ptr() *CustomerCreationSource {
	return &c
}

// The creation source filter.
//
// If one or more creation sources are set, customer profiles are included in,
// or excluded from, the result if they match at least one of the filter criteria.
type CustomerCreationSourceFilter struct {
	// The list of creation sources used as filtering criteria.
	// See [CustomerCreationSource](#type-customercreationsource) for possible values
	Values []CustomerCreationSource `json:"values,omitempty" url:"values,omitempty"`
	// Indicates whether a customer profile matching the filter criteria
	// should be included in the result or excluded from the result.
	//
	// Default: `INCLUDE`.
	// See [CustomerInclusionExclusion](#type-customerinclusionexclusion) for possible values
	Rule *CustomerInclusionExclusion `json:"rule,omitempty" url:"rule,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CustomerCreationSourceFilter) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CustomerCreationSourceFilter) UnmarshalJSON(data []byte) error {
	type unmarshaler CustomerCreationSourceFilter
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CustomerCreationSourceFilter(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CustomerCreationSourceFilter) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Published when a customer [custom attribute definition](entity:CustomAttributeDefinition)
// that is visible to all applications is created. A notification is sent when any application creates a custom
// attribute definition whose `visibility` is `VISIBILITY_READ_ONLY` or `VISIBILITY_READ_WRITE_VALUES`.
//
// This event is replaced by
// [customer.custom_attribute_definition.visible.created](webhook:customer.custom_attribute_definition.visible.created),
// which applies to custom attribute definitions that are visible to the subscribing application.
type CustomerCustomAttributeDefinitionCreatedPublicWebhook struct {
	// The ID of the seller associated with the event that triggered the event notification.
	MerchantId *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The type of this event. The value is `"customer.custom_attribute_definition.public.created"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// A unique ID for the event notification.
	EventId *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// The timestamp that indicates when the event notification was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The data associated with the event that triggered the event notification.
	Data *CustomAttributeDefinitionWebhookData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CustomerCustomAttributeDefinitionCreatedPublicWebhook) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CustomerCustomAttributeDefinitionCreatedPublicWebhook) UnmarshalJSON(data []byte) error {
	type unmarshaler CustomerCustomAttributeDefinitionCreatedPublicWebhook
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CustomerCustomAttributeDefinitionCreatedPublicWebhook(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CustomerCustomAttributeDefinitionCreatedPublicWebhook) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Published when a customer [custom attribute definition](entity:CustomAttributeDefinition)
// is created by the subscribing application.
//
// This event is replaced by
// [customer.custom_attribute_definition.owned.created](webhook:customer.custom_attribute_definition.owned.created).
type CustomerCustomAttributeDefinitionCreatedWebhook struct {
	// The ID of the seller associated with the event that triggered the event notification.
	MerchantId *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The type of this event. The value is `"customer.custom_attribute_definition.created"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// A unique ID for the event notification.
	EventId *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// The timestamp that indicates when the event notification was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The data associated with the event that triggered the event notification.
	Data *CustomAttributeDefinitionWebhookData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CustomerCustomAttributeDefinitionCreatedWebhook) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CustomerCustomAttributeDefinitionCreatedWebhook) UnmarshalJSON(data []byte) error {
	type unmarshaler CustomerCustomAttributeDefinitionCreatedWebhook
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CustomerCustomAttributeDefinitionCreatedWebhook(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CustomerCustomAttributeDefinitionCreatedWebhook) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Published when a customer [custom attribute definition](entity:CustomAttributeDefinition)
// that is visible to all applications is deleted. A notification is sent when any application deletes a custom
// attribute definition whose `visibility` is `VISIBILITY_READ_ONLY` or `VISIBILITY_READ_WRITE_VALUES`.
//
// This event is replaced by
// [customer.custom_attribute_definition.visible.deleted](webhook:customer.custom_attribute_definition.visible.deleted),
// which applies to custom attribute definitions that are visible to the subscribing application.
type CustomerCustomAttributeDefinitionDeletedPublicWebhook struct {
	// The ID of the seller associated with the event that triggered the event notification.
	MerchantId *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The type of this event. The value is `"customer.custom_attribute_definition.public.deleted"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// A unique ID for the event notification.
	EventId *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// The timestamp that indicates when the event notification was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The data associated with the event that triggered the event notification.
	Data *CustomAttributeDefinitionWebhookData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CustomerCustomAttributeDefinitionDeletedPublicWebhook) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CustomerCustomAttributeDefinitionDeletedPublicWebhook) UnmarshalJSON(data []byte) error {
	type unmarshaler CustomerCustomAttributeDefinitionDeletedPublicWebhook
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CustomerCustomAttributeDefinitionDeletedPublicWebhook(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CustomerCustomAttributeDefinitionDeletedPublicWebhook) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Published when a customer [custom attribute definition](entity:CustomAttributeDefinition)
// created by the subscribing application is deleted. A custom attribute definition can only be deleted by
// the application that created it.
//
// This event is replaced by
// [customer.custom_attribute_definition.owned.deleted](webhook:customer.custom_attribute_definition.owned.deleted).
type CustomerCustomAttributeDefinitionDeletedWebhook struct {
	// The ID of the seller associated with the event that triggered the event notification.
	MerchantId *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The type of this event. The value is `"customer.custom_attribute_definition.deleted"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// A unique ID for the event notification.
	EventId *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// The timestamp that indicates when the event notification was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The data associated with the event that triggered the event notification.
	Data *CustomAttributeDefinitionWebhookData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CustomerCustomAttributeDefinitionDeletedWebhook) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CustomerCustomAttributeDefinitionDeletedWebhook) UnmarshalJSON(data []byte) error {
	type unmarshaler CustomerCustomAttributeDefinitionDeletedWebhook
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CustomerCustomAttributeDefinitionDeletedWebhook(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CustomerCustomAttributeDefinitionDeletedWebhook) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Published when a customer [custom attribute definition](entity:CustomAttributeDefinition)
// is created by the subscribing application.
type CustomerCustomAttributeDefinitionOwnedCreatedWebhook struct {
	// The ID of the seller associated with the event that triggered the event notification.
	MerchantId *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The type of this event. The value is `"customer.custom_attribute_definition.owned.created"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// A unique ID for the event notification.
	EventId *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// The timestamp that indicates when the event notification was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The data associated with the event that triggered the event notification.
	Data *CustomAttributeDefinitionWebhookData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CustomerCustomAttributeDefinitionOwnedCreatedWebhook) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CustomerCustomAttributeDefinitionOwnedCreatedWebhook) UnmarshalJSON(data []byte) error {
	type unmarshaler CustomerCustomAttributeDefinitionOwnedCreatedWebhook
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CustomerCustomAttributeDefinitionOwnedCreatedWebhook(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CustomerCustomAttributeDefinitionOwnedCreatedWebhook) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Published when a customer [custom attribute definition](entity:CustomAttributeDefinition)
// created by the subscribing application is deleted. A custom attribute definition can only be deleted by
// the application that created it.
type CustomerCustomAttributeDefinitionOwnedDeletedWebhook struct {
	// The ID of the seller associated with the event that triggered the event notification.
	MerchantId *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The type of this event. The value is `"customer.custom_attribute_definition.owned.deleted"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// A unique ID for the event notification.
	EventId *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// The timestamp that indicates when the event notification was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The data associated with the event that triggered the event notification.
	Data *CustomAttributeDefinitionWebhookData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CustomerCustomAttributeDefinitionOwnedDeletedWebhook) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CustomerCustomAttributeDefinitionOwnedDeletedWebhook) UnmarshalJSON(data []byte) error {
	type unmarshaler CustomerCustomAttributeDefinitionOwnedDeletedWebhook
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CustomerCustomAttributeDefinitionOwnedDeletedWebhook(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CustomerCustomAttributeDefinitionOwnedDeletedWebhook) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Published when a customer [custom attribute definition](entity:CustomAttributeDefinition)
// created by the subscribing application is updated. A custom attribute definition can only be updated by
// the application that created it.
type CustomerCustomAttributeDefinitionOwnedUpdatedWebhook struct {
	// The ID of the seller associated with the event that triggered the event notification.
	MerchantId *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The type of this event. The value is `"customer.custom_attribute_definition.owned.updated"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// A unique ID for the event notification.
	EventId *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// The timestamp that indicates when the event notification was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The data associated with the event that triggered the event notification.
	Data *CustomAttributeDefinitionWebhookData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CustomerCustomAttributeDefinitionOwnedUpdatedWebhook) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CustomerCustomAttributeDefinitionOwnedUpdatedWebhook) UnmarshalJSON(data []byte) error {
	type unmarshaler CustomerCustomAttributeDefinitionOwnedUpdatedWebhook
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CustomerCustomAttributeDefinitionOwnedUpdatedWebhook(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CustomerCustomAttributeDefinitionOwnedUpdatedWebhook) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Published when a customer [custom attribute definition](entity:CustomAttributeDefinition)
// that is visible to all applications is updated. A notification is sent when any application updates a custom
// attribute definition whose `visibility` is `VISIBILITY_READ_ONLY` or `VISIBILITY_READ_WRITE_VALUES`.
//
// This event is replaced by
// [customer.custom_attribute_definition.visible.updated](webhook:customer.custom_attribute_definition.visible.updated),
// which applies to custom attribute definitions that are visible to the subscribing application.
type CustomerCustomAttributeDefinitionUpdatedPublicWebhook struct {
	// The ID of the seller associated with the event that triggered the event notification.
	MerchantId *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The type of this event. The value is `"customer.custom_attribute_definition.public.updated"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// A unique ID for the event notification.
	EventId *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// The timestamp that indicates when the event notification was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The data associated with the event that triggered the event notification.
	Data *CustomAttributeDefinitionWebhookData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CustomerCustomAttributeDefinitionUpdatedPublicWebhook) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CustomerCustomAttributeDefinitionUpdatedPublicWebhook) UnmarshalJSON(data []byte) error {
	type unmarshaler CustomerCustomAttributeDefinitionUpdatedPublicWebhook
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CustomerCustomAttributeDefinitionUpdatedPublicWebhook(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CustomerCustomAttributeDefinitionUpdatedPublicWebhook) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Published when a customer [custom attribute definition](entity:CustomAttributeDefinition)
// created by the subscribing application is updated. A custom attribute definition can only be updated by
// the application that created it.
//
// This event is replaced by
// [customer.custom_attribute_definition.owned.updated](webhook:customer.custom_attribute_definition.owned.updated).
type CustomerCustomAttributeDefinitionUpdatedWebhook struct {
	// The ID of the seller associated with the event that triggered the event notification.
	MerchantId *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The type of this event. The value is `"customer.custom_attribute_definition.updated"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// A unique ID for the event notification.
	EventId *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// The timestamp that indicates when the event notification was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The data associated with the event that triggered the event notification.
	Data *CustomAttributeDefinitionWebhookData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CustomerCustomAttributeDefinitionUpdatedWebhook) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CustomerCustomAttributeDefinitionUpdatedWebhook) UnmarshalJSON(data []byte) error {
	type unmarshaler CustomerCustomAttributeDefinitionUpdatedWebhook
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CustomerCustomAttributeDefinitionUpdatedWebhook(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CustomerCustomAttributeDefinitionUpdatedWebhook) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Published when a customer [custom attribute definition](entity:CustomAttributeDefinition)
// that is visible to the subscribing application is created. A notification is sent when your application
// creates a custom attribute definition or another application creates a custom attribute definition whose
// `visibility` is `VISIBILITY_READ_ONLY` or `VISIBILITY_READ_WRITE_VALUES`.
type CustomerCustomAttributeDefinitionVisibleCreatedWebhook struct {
	// The ID of the seller associated with the event that triggered the event notification.
	MerchantId *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The type of this event. The value is `"customer.custom_attribute_definition.visible.created"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// A unique ID for the event notification.
	EventId *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// The timestamp that indicates when the event notification was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The data associated with the event that triggered the event notification.
	Data *CustomAttributeDefinitionWebhookData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CustomerCustomAttributeDefinitionVisibleCreatedWebhook) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CustomerCustomAttributeDefinitionVisibleCreatedWebhook) UnmarshalJSON(data []byte) error {
	type unmarshaler CustomerCustomAttributeDefinitionVisibleCreatedWebhook
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CustomerCustomAttributeDefinitionVisibleCreatedWebhook(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CustomerCustomAttributeDefinitionVisibleCreatedWebhook) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Published when a customer [custom attribute definition](entity:CustomAttributeDefinition)
// that is visible to the subscribing application is deleted. A custom attribute definition can only be deleted
// by the application that created it. A notification is sent when your application deletes a custom attribute
// definition or when another application deletes a custom attribute definition whose `visibility` is
// `VISIBILITY_READ_ONLY` or `VISIBILITY_READ_WRITE_VALUES`.
type CustomerCustomAttributeDefinitionVisibleDeletedWebhook struct {
	// The ID of the seller associated with the event that triggered the event notification.
	MerchantId *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The type of this event. The value is `"customer.custom_attribute_definition.visible.deleted"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// A unique ID for the event notification.
	EventId *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// The timestamp that indicates when the event notification was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The data associated with the event that triggered the event notification.
	Data *CustomAttributeDefinitionWebhookData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CustomerCustomAttributeDefinitionVisibleDeletedWebhook) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CustomerCustomAttributeDefinitionVisibleDeletedWebhook) UnmarshalJSON(data []byte) error {
	type unmarshaler CustomerCustomAttributeDefinitionVisibleDeletedWebhook
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CustomerCustomAttributeDefinitionVisibleDeletedWebhook(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CustomerCustomAttributeDefinitionVisibleDeletedWebhook) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Published when a customer [custom attribute definition](entity:CustomAttributeDefinition)
// that is visible to the subscribing application is updated. A custom attribute definition can only be updated
// by the application that created it. A notification is sent when your application updates a custom
// attribute definition or when another application updates a custom attribute definition whose `visibility` is
// `VISIBILITY_READ_ONLY` or `VISIBILITY_READ_WRITE_VALUES`.
type CustomerCustomAttributeDefinitionVisibleUpdatedWebhook struct {
	// The ID of the seller associated with the event that triggered the event notification.
	MerchantId *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The type of this event. The value is `"customer.custom_attribute_definition.visible.updated"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// A unique ID for the event notification.
	EventId *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// The timestamp that indicates when the event notification was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The data associated with the event that triggered the event notification.
	Data *CustomAttributeDefinitionWebhookData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CustomerCustomAttributeDefinitionVisibleUpdatedWebhook) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CustomerCustomAttributeDefinitionVisibleUpdatedWebhook) UnmarshalJSON(data []byte) error {
	type unmarshaler CustomerCustomAttributeDefinitionVisibleUpdatedWebhook
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CustomerCustomAttributeDefinitionVisibleUpdatedWebhook(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CustomerCustomAttributeDefinitionVisibleUpdatedWebhook) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Published when a customer [custom attribute](entity:CustomAttribute) that is visible
// to all applications is deleted. A notification is sent when any application deletes a custom attribute
// whose `visibility` is `VISIBILITY_READ_ONLY` or `VISIBILITY_READ_WRITE_VALUES`.
//
// This event is replaced by
// [customer.custom_attribute.visible.deleted](webhook:customer.custom_attribute.visible.deleted),
// which applies to custom attributes that are visible to the subscribing application.
type CustomerCustomAttributeDeletedPublicWebhook struct {
	// The ID of the seller associated with the event that triggered the event notification.
	MerchantId *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The type of this event. The value is `"customer.custom_attribute.public.deleted"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// A unique ID for the event notification.
	EventId *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// The timestamp that indicates when the event notification was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The data associated with the event that triggered the event notification.
	Data *CustomAttributeWebhookData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CustomerCustomAttributeDeletedPublicWebhook) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CustomerCustomAttributeDeletedPublicWebhook) UnmarshalJSON(data []byte) error {
	type unmarshaler CustomerCustomAttributeDeletedPublicWebhook
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CustomerCustomAttributeDeletedPublicWebhook(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CustomerCustomAttributeDeletedPublicWebhook) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Published when a customer [custom attribute](entity:CustomAttribute) owned by the
// subscribing application is deleted. Custom attributes are owned by the application that created the
// corresponding [custom attribute definition](entity:CustomAttributeDefinition). Custom attributes whose
// `visibility` is `VISIBILITY_READ_WRITE_VALUES` can be deleted by any application.
//
// This event is replaced by
// [customer.custom_attribute.owned.deleted](webhook:customer.custom_attribute.owned.deleted).
type CustomerCustomAttributeDeletedWebhook struct {
	// The ID of the seller associated with the event that triggered the event notification.
	MerchantId *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The type of this event. The value is `"customer.custom_attribute.deleted"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// A unique ID for the event notification.
	EventId *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// The timestamp that indicates when the event notification was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The data associated with the event that triggered the event notification.
	Data *CustomAttributeWebhookData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CustomerCustomAttributeDeletedWebhook) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CustomerCustomAttributeDeletedWebhook) UnmarshalJSON(data []byte) error {
	type unmarshaler CustomerCustomAttributeDeletedWebhook
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CustomerCustomAttributeDeletedWebhook(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CustomerCustomAttributeDeletedWebhook) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// The custom attribute filter. Use this filter in a set of [custom attribute filters](entity:CustomerCustomAttributeFilters) to search
// based on the value or last updated date of a customer-related [custom attribute](entity:CustomAttribute).
type CustomerCustomAttributeFilter struct {
	// The `key` of the [custom attribute](entity:CustomAttribute) to filter by. The key is the identifier of the custom attribute
	// (and the corresponding custom attribute definition) and can be retrieved using the [Customer Custom Attributes API](api:CustomerCustomAttributes).
	Key string `json:"key" url:"key"`
	// A filter that corresponds to the data type of the target custom attribute. For example, provide the `phone` filter to
	// search based on the value of a `PhoneNumber`-type custom attribute. The data type is specified by the schema field of the custom attribute definition,
	// which can be retrieved using the [Customer Custom Attributes API](api:CustomerCustomAttributes).
	//
	// You must provide this `filter` field, the `updated_at` field, or both.
	Filter *CustomerCustomAttributeFilterValue `json:"filter,omitempty" url:"filter,omitempty"`
	// The date range for when the custom attribute was last updated. The date range can include `start_at`, `end_at`, or
	// both. Range boundaries are inclusive. Dates are specified as RFC 3339 timestamps.
	//
	// You must provide this `updated_at` field, the `filter` field, or both.
	UpdatedAt *TimeRange `json:"updated_at,omitempty" url:"updated_at,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CustomerCustomAttributeFilter) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CustomerCustomAttributeFilter) UnmarshalJSON(data []byte) error {
	type unmarshaler CustomerCustomAttributeFilter
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CustomerCustomAttributeFilter(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CustomerCustomAttributeFilter) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// A type-specific filter used in a [custom attribute filter](entity:CustomerCustomAttributeFilter) to search based on the value
// of a customer-related [custom attribute](entity:CustomAttribute).
type CustomerCustomAttributeFilterValue struct {
	// A filter for a query based on the value of an `Email`-type custom attribute. This filter is case-insensitive and can
	// include `exact` or `fuzzy`, but not both.
	//
	// For an `exact` match, provide the complete email address.
	//
	// For a `fuzzy` match, provide a query expression containing one or more query tokens to match against the email address. Square removes
	// any punctuation (including periods (.), underscores (\_), and the @ symbol) and tokenizes the email addresses on spaces. A match is found
	// if a tokenized email address contains all the tokens in the search query, irrespective of the token order. For example, `Steven gmail`
	// matches steven.jones@gmail.com and mygmail@stevensbakery.com.
	Email *CustomerTextFilter `json:"email,omitempty" url:"email,omitempty"`
	// A filter for a query based on the value of a `PhoneNumber`-type custom attribute. This filter is case-insensitive and
	// can include `exact` or `fuzzy`, but not both.
	//
	// For an `exact` match, provide the complete phone number. This is always an E.164-compliant phone number that starts
	// with the + sign followed by the country code and subscriber number. For example, the format for a US phone number is +12061112222.
	//
	// For a `fuzzy` match, provide a query expression containing one or more query tokens to match against the phone number.
	// Square removes any punctuation and tokenizes the expression on spaces. A match is found if a tokenized phone number contains
	// all the tokens in the search query, irrespective of the token order. For example, `415 123 45` is tokenized to `415`, `123`, and `45`,
	// which matches +14151234567 and +12345674158, but does not match +1234156780. Similarly, the expression `415` matches
	// +14151234567, +12345674158, and +1234156780.
	Phone *CustomerTextFilter `json:"phone,omitempty" url:"phone,omitempty"`
	// A filter for a query based on the value of a `String`-type custom attribute. This filter is case-insensitive and
	// can include `exact` or `fuzzy`, but not both.
	//
	// For an `exact` match, provide the complete string.
	//
	// For a `fuzzy` match, provide a query expression containing one or more query tokens in any order that contain complete words
	// to match against the string. Square tokenizes the expression using a grammar-based tokenizer. For example, the expressions `quick brown`,
	// `brown quick`, and `quick fox` match "The quick brown fox jumps over the lazy dog". However, `quick foxes` and `qui` do not match.
	Text *CustomerTextFilter `json:"text,omitempty" url:"text,omitempty"`
	// A filter for a query based on the display name for a `Selection`-type custom attribute value. This filter is case-sensitive
	// and can contain `any`, `all`, or both. The `none` condition is not supported.
	//
	// Provide the display name of each item that you want to search for. To find the display names for the selection, use the
	// [Customer Custom Attributes API](api:CustomerCustomAttributes) to retrieve the corresponding custom attribute definition
	// and then check the `schema.items.names` field. For more information, see
	// [Search based on selection](https://developer.squareup.com/docs/customers-api/use-the-api/search-customers#custom-attribute-value-filter-selection).
	//
	// Note that when a `Selection`-type custom attribute is assigned to a customer profile, the custom attribute value is a list of one
	// or more UUIDs (sourced from the `schema.items.enum` field) that map to the item names. These UUIDs are unique per seller.
	Selection *FilterValue `json:"selection,omitempty" url:"selection,omitempty"`
	// A filter for a query based on the value of a `Date`-type custom attribute.
	//
	// Provide a date range for this filter using `start_at`, `end_at`, or both. Range boundaries are inclusive. Dates can be specified
	// in `YYYY-MM-DD` format or as RFC 3339 timestamps.
	Date *TimeRange `json:"date,omitempty" url:"date,omitempty"`
	// A filter for a query based on the value of a `Number`-type custom attribute, which can be an integer or a decimal with up to
	// 5 digits of precision.
	//
	// Provide a numerical range for this filter using `start_at`, `end_at`, or both. Range boundaries are inclusive. Numbers are specified
	// as decimals or integers. The absolute value of range boundaries must not exceed `(2^63-1)/10^5`, or 92233720368547.
	Number *FloatNumberRange `json:"number,omitempty" url:"number,omitempty"`
	// A filter for a query based on the value of a `Boolean`-type custom attribute.
	Boolean *bool `json:"boolean,omitempty" url:"boolean,omitempty"`
	// A filter for a query based on the value of an `Address`-type custom attribute. The filter can include `postal_code`, `country`, or both.
	Address *CustomerAddressFilter `json:"address,omitempty" url:"address,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CustomerCustomAttributeFilterValue) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CustomerCustomAttributeFilterValue) UnmarshalJSON(data []byte) error {
	type unmarshaler CustomerCustomAttributeFilterValue
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CustomerCustomAttributeFilterValue(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CustomerCustomAttributeFilterValue) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// The custom attribute filters in a set of [customer filters](entity:CustomerFilter) used in a search query. Use this filter
// to search based on [custom attributes](entity:CustomAttribute) that are assigned to customer profiles. For more information, see
// [Search by custom attribute](https://developer.squareup.com/docs/customers-api/use-the-api/search-customers#search-by-custom-attribute).
type CustomerCustomAttributeFilters struct {
	// The custom attribute filters. Each filter must specify `key` and include the `filter` field with a type-specific filter,
	// the `updated_at` field, or both. The provided keys must be unique within the list of custom attribute filters.
	Filters []*CustomerCustomAttributeFilter `json:"filters,omitempty" url:"filters,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CustomerCustomAttributeFilters) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CustomerCustomAttributeFilters) UnmarshalJSON(data []byte) error {
	type unmarshaler CustomerCustomAttributeFilters
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CustomerCustomAttributeFilters(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CustomerCustomAttributeFilters) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Published when a customer [custom attribute](entity:CustomAttribute) owned by the
// subscribing application is deleted. Custom attributes are owned by the application that created the
// corresponding [custom attribute definition](entity:CustomAttributeDefinition). Custom attributes whose
// `visibility` is `VISIBILITY_READ_WRITE_VALUES` can be deleted by any application.
type CustomerCustomAttributeOwnedDeletedWebhook struct {
	// The ID of the seller associated with the event that triggered the event notification.
	MerchantId *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The type of this event. The value is `"customer.custom_attribute.owned.deleted"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// A unique ID for the event notification.
	EventId *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// The timestamp that indicates when the event notification was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The data associated with the event that triggered the event notification.
	Data *CustomAttributeWebhookData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CustomerCustomAttributeOwnedDeletedWebhook) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CustomerCustomAttributeOwnedDeletedWebhook) UnmarshalJSON(data []byte) error {
	type unmarshaler CustomerCustomAttributeOwnedDeletedWebhook
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CustomerCustomAttributeOwnedDeletedWebhook(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CustomerCustomAttributeOwnedDeletedWebhook) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Published when a customer [custom attribute](entity:CustomAttribute) owned by the
// subscribing application is created or updated. Custom attributes are owned by the application that created
// the corresponding [custom attribute definition](entity:CustomAttributeDefinition). Custom attributes whose
// `visibility` is `VISIBILITY_READ_WRITE_VALUES` can be created or updated by any application.
type CustomerCustomAttributeOwnedUpdatedWebhook struct {
	// The ID of the seller associated with the event that triggered the event notification.
	MerchantId *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The type of this event. The value is `"customer.custom_attribute.owned.updated"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// A unique ID for the event notification.
	EventId *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// The timestamp that indicates when the event notification was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The data associated with the event that triggered the event notification.
	Data *CustomAttributeWebhookData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CustomerCustomAttributeOwnedUpdatedWebhook) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CustomerCustomAttributeOwnedUpdatedWebhook) UnmarshalJSON(data []byte) error {
	type unmarshaler CustomerCustomAttributeOwnedUpdatedWebhook
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CustomerCustomAttributeOwnedUpdatedWebhook(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CustomerCustomAttributeOwnedUpdatedWebhook) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Published when a customer [custom attribute](entity:CustomAttribute) that is visible
// to all applications is created or updated. A notification is sent when any application creates or updates
// a custom attribute whose `visibility` is `VISIBILITY_READ_ONLY` or `VISIBILITY_READ_WRITE_VALUES`.
//
// This event is replaced by
// [customer.custom_attribute.visible.updated](webhook:customer.custom_attribute.visible.updated),
// which applies to custom attributes that are visible to the subscribing application.
type CustomerCustomAttributeUpdatedPublicWebhook struct {
	// The ID of the seller associated with the event that triggered the event notification.
	MerchantId *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The type of this event. The value is `"customer.custom_attribute.public.updated"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// A unique ID for the event notification.
	EventId *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// The timestamp that indicates when the event notification was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The data associated with the event that triggered the event notification.
	Data *CustomAttributeWebhookData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CustomerCustomAttributeUpdatedPublicWebhook) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CustomerCustomAttributeUpdatedPublicWebhook) UnmarshalJSON(data []byte) error {
	type unmarshaler CustomerCustomAttributeUpdatedPublicWebhook
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CustomerCustomAttributeUpdatedPublicWebhook(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CustomerCustomAttributeUpdatedPublicWebhook) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Published when a customer [custom attribute](entity:CustomAttribute) owned by the
// subscribing application is created or updated. Custom attributes are owned by the application that created
// the corresponding [custom attribute definition](entity:CustomAttributeDefinition). Custom attributes whose
// `visibility` is `VISIBILITY_READ_WRITE_VALUES` can be created or updated by any application.
//
// This event is replaced by
// [customer.custom_attribute.owned.updated](webhook:customer.custom_attribute.owned.updated).
type CustomerCustomAttributeUpdatedWebhook struct {
	// The ID of the seller associated with the event that triggered the event notification.
	MerchantId *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The type of this event. The value is `"customer.custom_attribute.updated"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// A unique ID for the event notification.
	EventId *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// The timestamp that indicates when the event notification was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The data associated with the event that triggered the event notification.
	Data *CustomAttributeWebhookData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CustomerCustomAttributeUpdatedWebhook) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CustomerCustomAttributeUpdatedWebhook) UnmarshalJSON(data []byte) error {
	type unmarshaler CustomerCustomAttributeUpdatedWebhook
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CustomerCustomAttributeUpdatedWebhook(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CustomerCustomAttributeUpdatedWebhook) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Published when a customer [custom attribute](entity:CustomAttribute) that is visible to the
// subscribing application is deleted. A notification is sent when:
//
//   - Your application deletes a custom attribute owned by your application, regardless of the `visibility` setting.
//   - Any application deletes a custom attribute whose `visibility` is `VISIBILITY_READ_ONLY`
//     or `VISIBILITY_READ_WRITE_VALUES`.
//
// Custom attributes set to `VISIBILITY_READ_WRITE_VALUES` can be deleted by any application, but those set to
// `VISIBILITY_READ_ONLY` or `VISIBILITY_HIDDEN` can only be deleted by the owner. Custom attributes are owned
// by the application that created the corresponding [custom attribute definition](entity:CustomAttributeDefinition).
type CustomerCustomAttributeVisibleDeletedWebhook struct {
	// The ID of the seller associated with the event that triggered the event notification.
	MerchantId *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The type of this event. The value is `"customer.custom_attribute.visible.deleted"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// A unique ID for the event notification.
	EventId *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// The timestamp that indicates when the event notification was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The data associated with the event that triggered the event notification.
	Data *CustomAttributeWebhookData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CustomerCustomAttributeVisibleDeletedWebhook) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CustomerCustomAttributeVisibleDeletedWebhook) UnmarshalJSON(data []byte) error {
	type unmarshaler CustomerCustomAttributeVisibleDeletedWebhook
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CustomerCustomAttributeVisibleDeletedWebhook(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CustomerCustomAttributeVisibleDeletedWebhook) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Published when a customer [custom attribute](entity:CustomAttribute) that is visible to the
// subscribing application is created or updated. A notification is sent when:
//
//   - Your application creates or updates a custom attribute owned by your application, regardless of the `visibility` setting.
//   - Any application creates or updates a custom attribute whose `visibility` is `VISIBILITY_READ_ONLY`
//     or `VISIBILITY_READ_WRITE_VALUES`.
//
// Custom attributes set to `VISIBILITY_READ_WRITE_VALUES` can be created or updated by any application, but those set to
// `VISIBILITY_READ_ONLY` or `VISIBILITY_HIDDEN` can only be created or updated by the owner. Custom attributes are owned
// by the application that created the corresponding [custom attribute definition](entity:CustomAttributeDefinition).
type CustomerCustomAttributeVisibleUpdatedWebhook struct {
	// The ID of the seller associated with the event that triggered the event notification.
	MerchantId *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The type of this event. The value is `"customer.custom_attribute.visible.updated"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// A unique ID for the event notification.
	EventId *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// The timestamp that indicates when the event notification was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The data associated with the event that triggered the event notification.
	Data *CustomAttributeWebhookData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CustomerCustomAttributeVisibleUpdatedWebhook) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CustomerCustomAttributeVisibleUpdatedWebhook) UnmarshalJSON(data []byte) error {
	type unmarshaler CustomerCustomAttributeVisibleUpdatedWebhook
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CustomerCustomAttributeVisibleUpdatedWebhook(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CustomerCustomAttributeVisibleUpdatedWebhook) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Published when a [customer](entity:Customer) is deleted. For more information, see [Use Customer Webhooks](https://developer.squareup.com/docs/customers-api/use-the-api/customer-webhooks).
//
// The `customer` object in the event notification does not include the following fields: `cards` (deprecated), `group_ids`, and `segment_ids`.
type CustomerDeletedWebhook struct {
	// The ID of the seller associated with the event.
	MerchantId *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The type of event. For this object, the value is `customer.deleted`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// The unique ID of the event, which is used for [idempotency support](https://developer.squareup.com/docs/webhooks/step4manage#webhooks-best-practices).
	EventId *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// The timestamp of when the event was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The data associated with the event.
	Data *CustomerDeletedWebhookData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CustomerDeletedWebhook) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CustomerDeletedWebhook) UnmarshalJSON(data []byte) error {
	type unmarshaler CustomerDeletedWebhook
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CustomerDeletedWebhook(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CustomerDeletedWebhook) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// The data associated with the webhook event.
type CustomerDeletedWebhookData struct {
	// The type of object affected by the event. For this event, the value is `customer`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// The ID of the deleted customer.
	Id *string `json:"id,omitempty" url:"id,omitempty"`
	// An object that contains the deleted customer.
	Object *CustomerDeletedWebhookObject `json:"object,omitempty" url:"object,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CustomerDeletedWebhookData) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CustomerDeletedWebhookData) UnmarshalJSON(data []byte) error {
	type unmarshaler CustomerDeletedWebhookData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CustomerDeletedWebhookData(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CustomerDeletedWebhookData) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Information about the change that triggered the event.
type CustomerDeletedWebhookEventContext struct {
	// Information about the merge operation associated with the event.
	Merge *CustomerDeletedWebhookEventContextMerge `json:"merge,omitempty" url:"merge,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CustomerDeletedWebhookEventContext) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CustomerDeletedWebhookEventContext) UnmarshalJSON(data []byte) error {
	type unmarshaler CustomerDeletedWebhookEventContext
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CustomerDeletedWebhookEventContext(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CustomerDeletedWebhookEventContext) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Information about a merge operation, which creates a new customer using aggregated properties from two or more existing customers.
type CustomerDeletedWebhookEventContextMerge struct {
	// The IDs of the existing customers that were merged and then deleted.
	FromCustomerIds []string `json:"from_customer_ids,omitempty" url:"from_customer_ids,omitempty"`
	// The ID of the new customer created by the merge.
	ToCustomerId *string `json:"to_customer_id,omitempty" url:"to_customer_id,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CustomerDeletedWebhookEventContextMerge) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CustomerDeletedWebhookEventContextMerge) UnmarshalJSON(data []byte) error {
	type unmarshaler CustomerDeletedWebhookEventContextMerge
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CustomerDeletedWebhookEventContextMerge(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CustomerDeletedWebhookEventContextMerge) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// An object that contains the customer associated with the webhook event.
type CustomerDeletedWebhookObject struct {
	// The deleted customer.
	Customer *Customer `json:"customer,omitempty" url:"customer,omitempty"`
	// Information about the change that triggered the event. This field is returned only if the customer is deleted by a merge operation.
	EventContext *CustomerDeletedWebhookEventContext `json:"event_context,omitempty" url:"event_context,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CustomerDeletedWebhookObject) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CustomerDeletedWebhookObject) UnmarshalJSON(data []byte) error {
	type unmarshaler CustomerDeletedWebhookObject
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CustomerDeletedWebhookObject(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CustomerDeletedWebhookObject) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Represents a set of `CustomerQuery` filters used to limit the set of
// customers returned by the [SearchCustomers](api-endpoint:Customers-SearchCustomers) endpoint.
type CustomerFilter struct {
	// A filter to select customers based on their creation source.
	CreationSource *CustomerCreationSourceFilter `json:"creation_source,omitempty" url:"creation_source,omitempty"`
	// A filter to select customers based on when they were created.
	CreatedAt *TimeRange `json:"created_at,omitempty" url:"created_at,omitempty"`
	// A filter to select customers based on when they were last updated.
	UpdatedAt *TimeRange `json:"updated_at,omitempty" url:"updated_at,omitempty"`
	// A filter to [select customers by their email address](https://developer.squareup.com/docs/customers-api/use-the-api/search-customers#search-by-email-address)
	// visible to the seller.
	// This filter is case-insensitive.
	//
	// For [exact matching](https://developer.squareup.com/docs/customers-api/use-the-api/search-customers#exact-search-by-email-address), this
	// filter causes the search to return customer profiles
	// whose `email_address` field value are identical to the email address provided
	// in the query.
	//
	// For [fuzzy matching](https://developer.squareup.com/docs/customers-api/use-the-api/search-customers#fuzzy-search-by-email-address),
	// this filter causes the search to return customer profiles
	// whose `email_address` field value has a token-wise partial match against the filtering
	// expression in the query. For example, with `Steven gmail` provided in a search
	// query, the search returns customers whose email address is `steven.johnson@gmail.com`
	// or `mygmail@stevensbakery.com`. Square removes any punctuation (including periods (.),
	// underscores (\_), and the @ symbol) and tokenizes the email addresses on spaces. A match is
	// found if a tokenized email address contains all the tokens in the search query,
	// irrespective of the token order.
	EmailAddress *CustomerTextFilter `json:"email_address,omitempty" url:"email_address,omitempty"`
	// A filter to [select customers by their phone numbers](https://developer.squareup.com/docs/customers-api/use-the-api/search-customers#search-by-phone-number)
	// visible to the seller.
	// This filter is case-insensitive.
	//
	// For [exact matching](https://developer.squareup.com/docs/customers-api/use-the-api/search-customers#exact-search-by-phone-number),
	// this filter causes the search to return customers whose phone number
	// matches the specified query expression. The number in the query must be of an E.164-compliant
	// form. In particular, it must include the leading `+` sign followed by a country code and then a
	// subscriber number. The standard E.614 form of a US phone number is `+12061112222` of
	// the domestic version or `+0012061112222` of the international version. The E.164-compliant
	// variations include `+1 (206) 111-2222` or `+001 (206) 111-2222`, respectively. To match
	// the query expression, stored customer phone numbers are converted to the standard
	// E.164 form of the national and internationalized versions.
	//
	// For [fuzzy matching](https://developer.squareup.com/docs/customers-api/use-the-api/search-customers#fuzzy-search-by-phone-number),
	// this filter causes the search to return customers whose phone number matches partially
	// the token or tokens provided in the query expression. For example, with `415` provided in a search query,
	// the search returns customers with the phone numbers `+1-415-212-1200`, `+1-212-415-1234`, and `+1 (551) 234-1567`.
	// Similarly, a search query of `415 123` returns customers with the phone numbers `+1-212-415-1234` and
	// `+1 (551) 234-1567` but not `+1-212-415-1200`. A match is found if a tokenized phone number contains all
	// the tokens in the search query, irrespective of the token order.
	PhoneNumber *CustomerTextFilter `json:"phone_number,omitempty" url:"phone_number,omitempty"`
	// A filter to [select customers by their reference IDs](https://developer.squareup.com/docs/customers-api/use-the-api/search-customers#search-by-reference-id).
	// This filter is case-insensitive.
	//
	// [Exact matching](https://developer.squareup.com/docs/customers-api/use-the-api/search-customers#exact-search-by-reference-id)
	// of a customer's reference ID against a query's reference ID is evaluated as an
	// exact match between two strings, character by character in the given order.
	//
	// [Fuzzy matching](https://developer.squareup.com/docs/customers-api/use-the-api/search-customers#fuzzy-search-by-reference-id)
	// of stored reference IDs against queried reference IDs works
	// exactly the same as fuzzy matching on email addresses. Non-alphanumeric characters
	// are replaced by spaces to tokenize stored and queried reference IDs. A match is found
	// if a tokenized stored reference ID contains all tokens specified in any order in the query. For example,
	// a query of `NYC M` matches customer profiles with the `reference_id` value of `NYC_M_35_JOHNSON`
	// and `NYC_27_MURRAY`.
	ReferenceId *CustomerTextFilter `json:"reference_id,omitempty" url:"reference_id,omitempty"`
	// A filter to select customers based on their group membership.
	//
	// The `group_ids` is a JSON object of the following general format:
	//
	// ```
	// "group_ids": {
	// "any":  ["{group_a_id}", "{group_b_id}", ...],
	// "all":  ["{group_1_id}", "{group_2_id}", ...],
	// "none": ["{group_i_id}", "{group_ii_id}", ...]
	// }
	// ```
	//
	// You can use any combination of these `group_ids` fields (also known as `FilterValue` properties)
	// to specify how customers are selected based on their group membership.
	// With the `any` option, the search returns customers in Groups `a` or `b` or ... of the list.
	// With the `all` option, the search returns customers in Groups `1` and `2` and ... of the list.
	// With the `none` option, the search returns customers not in Groups `i` and not in `ii` and not in ... of the list.
	//
	// If any of the search conditions are not met, including when an invalid or non-existent group ID is provided, the result is an empty list.
	//
	// You can use the `group_ids` search filter with other available filters.
	//
	// You cannot use the `group_ids` filter to select customers based on segment membership.
	GroupIds *FilterValue `json:"group_ids,omitempty" url:"group_ids,omitempty"`
	// A filter to select customers based on one or more custom attributes.
	// This filter can contain up to 10 custom attribute filters. Each custom attribute filter specifies filtering criteria for a target custom
	// attribute. If multiple custom attribute filters are provided, they are combined as an `AND` operation.
	//
	// To be valid for a search, the custom attributes must be visible to the requesting application. For more information, including example queries,
	// see [Search by custom attribute](https://developer.squareup.com/docs/customers-api/use-the-api/search-customers#search-by-custom-attribute).
	//
	// Square returns matching customer profiles, which do not contain custom attributes. To retrieve customer-related custom attributes,
	// use the [Customer Custom Attributes API](api:CustomerCustomAttributes). For example, you can call
	// [RetrieveCustomerCustomAttribute](api-endpoint:CustomerCustomAttributes-RetrieveCustomerCustomAttribute) using a customer ID from the result set.
	CustomAttribute *CustomerCustomAttributeFilters `json:"custom_attribute,omitempty" url:"custom_attribute,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CustomerFilter) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CustomerFilter) UnmarshalJSON(data []byte) error {
	type unmarshaler CustomerFilter
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CustomerFilter(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CustomerFilter) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Represents a group of customer profiles.
//
// Customer groups can be created, be modified, and have their membership defined using
// the Customers API or within the Customer Directory in the Square Seller Dashboard or Point of Sale.
type CustomerGroup struct {
	// A unique Square-generated ID for the customer group.
	Id *string `json:"id,omitempty" url:"id,omitempty"`
	// The name of the customer group.
	Name string `json:"name" url:"name"`
	// The timestamp when the customer group was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The timestamp when the customer group was last updated, in RFC 3339 format.
	UpdatedAt *string `json:"updated_at,omitempty" url:"updated_at,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CustomerGroup) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CustomerGroup) UnmarshalJSON(data []byte) error {
	type unmarshaler CustomerGroup
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CustomerGroup(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CustomerGroup) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Contains some brief information about a Customer Group with its identifier included.
type CustomerGroupInfo struct {
	// The ID of the Customer Group.
	Id string `json:"id" url:"id"`
	// The name of the Customer Group.
	Name string `json:"name" url:"name"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CustomerGroupInfo) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CustomerGroupInfo) UnmarshalJSON(data []byte) error {
	type unmarshaler CustomerGroupInfo
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CustomerGroupInfo(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CustomerGroupInfo) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Indicates whether customers should be included in, or excluded from,
// the result set when they match the filtering criteria.
type CustomerInclusionExclusion string

const (
	CustomerInclusionExclusionInclude CustomerInclusionExclusion = "INCLUDE"
	CustomerInclusionExclusionExclude CustomerInclusionExclusion = "EXCLUDE"
)

func NewCustomerInclusionExclusionFromString(s string) (CustomerInclusionExclusion, error) {
	switch s {
	case "INCLUDE":
		return CustomerInclusionExclusionInclude, nil
	case "EXCLUDE":
		return CustomerInclusionExclusionExclude, nil
	}
	var t CustomerInclusionExclusion
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CustomerInclusionExclusion) Ptr() *CustomerInclusionExclusion {
	return &c
}

// Represents communication preferences for the customer profile.
type CustomerPreferences struct {
	// Indicates whether the customer has unsubscribed from marketing campaign emails. A value of `true` means that the customer chose to opt out of email marketing from the current Square seller or from all Square sellers. This value is read-only from the Customers API.
	EmailUnsubscribed *bool `json:"email_unsubscribed,omitempty" url:"email_unsubscribed,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CustomerPreferences) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CustomerPreferences) UnmarshalJSON(data []byte) error {
	type unmarshaler CustomerPreferences
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CustomerPreferences(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CustomerPreferences) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Represents a group of customer profiles that match one or more predefined filter criteria.
//
// Segments (also known as Smart Groups) are defined and created within the Customer Directory in the
// Square Seller Dashboard or Point of Sale.
type CustomerSegment struct {
	// A unique Square-generated ID for the segment.
	Id *string `json:"id,omitempty" url:"id,omitempty"`
	// The name of the segment.
	Name string `json:"name" url:"name"`
	// The timestamp when the segment was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The timestamp when the segment was last updated, in RFC 3339 format.
	UpdatedAt *string `json:"updated_at,omitempty" url:"updated_at,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CustomerSegment) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CustomerSegment) UnmarshalJSON(data []byte) error {
	type unmarshaler CustomerSegment
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CustomerSegment(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CustomerSegment) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Specifies how searched customers profiles are sorted, including the sort key and sort order.
type CustomerSort struct {
	// Use one or more customer attributes as the sort key to sort searched customer profiles.
	// For example, use the creation date (`created_at`) of customers or default attributes as the sort key.
	//
	// Default: `DEFAULT`.
	// See [CustomerSortField](#type-customersortfield) for possible values
	Field *CustomerSortField `json:"field,omitempty" url:"field,omitempty"`
	// Indicates the order in which results should be sorted based on the
	// sort field value. Strings use standard alphabetic comparison
	// to determine order. Strings representing numbers are sorted as strings.
	//
	// Default: `ASC`.
	// See [SortOrder](#type-sortorder) for possible values
	Order *SortOrder `json:"order,omitempty" url:"order,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CustomerSort) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CustomerSort) UnmarshalJSON(data []byte) error {
	type unmarshaler CustomerSort
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CustomerSort(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CustomerSort) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// A filter to select customers based on exact or fuzzy matching of
// customer attributes against a specified query. Depending on the customer attributes,
// the filter can be case-sensitive. This filter can be exact or fuzzy, but it cannot be both.
type CustomerTextFilter struct {
	// Use the exact filter to select customers whose attributes match exactly the specified query.
	Exact *string `json:"exact,omitempty" url:"exact,omitempty"`
	// Use the fuzzy filter to select customers whose attributes match the specified query
	// in a fuzzy manner. When the fuzzy option is used, search queries are tokenized, and then
	// each query token must be matched somewhere in the searched attribute. For single token queries,
	// this is effectively the same behavior as a partial match operation.
	Fuzzy *string `json:"fuzzy,omitempty" url:"fuzzy,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CustomerTextFilter) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CustomerTextFilter) UnmarshalJSON(data []byte) error {
	type unmarshaler CustomerTextFilter
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CustomerTextFilter(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CustomerTextFilter) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Published when a [customer](entity:Customer) is updated. For more information, see [Use Customer Webhooks](https://developer.squareup.com/docs/customers-api/use-the-api/customer-webhooks).
//
// Updates to the following customer fields do not invoke a `customer.updated` event: `cards` (deprecated) and `segment_ids`. In addition, the `customer` object in the event notification does not include these fields.
type CustomerUpdatedWebhook struct {
	// The ID of the seller associated with the event.
	MerchantId *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The type of event. For this object, the value is `customer.updated`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// The unique ID of the event, which is used for [idempotency support](https://developer.squareup.com/docs/webhooks/step4manage#webhooks-best-practices).
	EventId *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// The timestamp of when the event was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The data associated with the event.
	Data *CustomerUpdatedWebhookData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CustomerUpdatedWebhook) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CustomerUpdatedWebhook) UnmarshalJSON(data []byte) error {
	type unmarshaler CustomerUpdatedWebhook
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CustomerUpdatedWebhook(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CustomerUpdatedWebhook) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// The data associated with the webhook event.
type CustomerUpdatedWebhookData struct {
	// The type of object affected by the event. For this event, the value is `customer`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// The ID of the updated customer.
	Id *string `json:"id,omitempty" url:"id,omitempty"`
	// An object that contains the updated customer.
	Object *CustomerUpdatedWebhookObject `json:"object,omitempty" url:"object,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CustomerUpdatedWebhookData) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CustomerUpdatedWebhookData) UnmarshalJSON(data []byte) error {
	type unmarshaler CustomerUpdatedWebhookData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CustomerUpdatedWebhookData(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CustomerUpdatedWebhookData) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// An object that contains the customer associated with the webhook event.
type CustomerUpdatedWebhookObject struct {
	// The updated customer.
	Customer *Customer `json:"customer,omitempty" url:"customer,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CustomerUpdatedWebhookObject) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CustomerUpdatedWebhookObject) UnmarshalJSON(data []byte) error {
	type unmarshaler CustomerUpdatedWebhookObject
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CustomerUpdatedWebhookObject(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CustomerUpdatedWebhookObject) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// A range defined by two dates. Used for filtering a query for Connect v2
// objects that have date properties.
type DateRange struct {
	// A string in `YYYY-MM-DD` format, such as `2017-10-31`, per the ISO 8601
	// extended format for calendar dates.
	// The beginning of a date range (inclusive).
	StartDate *string `json:"start_date,omitempty" url:"start_date,omitempty"`
	// A string in `YYYY-MM-DD` format, such as `2017-10-31`, per the ISO 8601
	// extended format for calendar dates.
	// The end of a date range (inclusive).
	EndDate *string `json:"end_date,omitempty" url:"end_date,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (d *DateRange) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DateRange) UnmarshalJSON(data []byte) error {
	type unmarshaler DateRange
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DateRange(value)

	extraProperties, err := core.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties

	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DateRange) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// Indicates the specific day of the week.
type DayOfWeek string

const (
	DayOfWeekSun DayOfWeek = "SUN"
	DayOfWeekMon DayOfWeek = "MON"
	DayOfWeekTue DayOfWeek = "TUE"
	DayOfWeekWed DayOfWeek = "WED"
	DayOfWeekThu DayOfWeek = "THU"
	DayOfWeekFri DayOfWeek = "FRI"
	DayOfWeekSat DayOfWeek = "SAT"
)

func NewDayOfWeekFromString(s string) (DayOfWeek, error) {
	switch s {
	case "SUN":
		return DayOfWeekSun, nil
	case "MON":
		return DayOfWeekMon, nil
	case "TUE":
		return DayOfWeekTue, nil
	case "WED":
		return DayOfWeekWed, nil
	case "THU":
		return DayOfWeekThu, nil
	case "FRI":
		return DayOfWeekFri, nil
	case "SAT":
		return DayOfWeekSat, nil
	}
	var t DayOfWeek
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (d DayOfWeek) Ptr() *DayOfWeek {
	return &d
}

// A request to delete a `BreakType`.
type DeleteBreakTypeRequest struct {
	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (d *DeleteBreakTypeRequest) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DeleteBreakTypeRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteBreakTypeRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteBreakTypeRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties

	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteBreakTypeRequest) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// The response to a request to delete a `BreakType`. The response might contain a set
// of `Error` objects if the request resulted in errors.
type DeleteBreakTypeResponse struct {
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (d *DeleteBreakTypeResponse) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DeleteBreakTypeResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteBreakTypeResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteBreakTypeResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties

	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteBreakTypeResponse) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteCatalogObjectRequest struct {
	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (d *DeleteCatalogObjectRequest) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DeleteCatalogObjectRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteCatalogObjectRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteCatalogObjectRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties

	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteCatalogObjectRequest) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteCatalogObjectResponse struct {
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The IDs of all catalog objects deleted by this request.
	// Multiple IDs may be returned when associated objects are also deleted, for example
	// a catalog item variation will be deleted (and its ID included in this field)
	// when its parent catalog item is deleted.
	DeletedObjectIds []string `json:"deleted_object_ids,omitempty" url:"deleted_object_ids,omitempty"`
	// The database [timestamp](https://developer.squareup.com/docs/build-basics/working-with-dates)
	// of this deletion in RFC 3339 format, e.g., `2016-09-04T23:59:33.123Z`.
	DeletedAt *string `json:"deleted_at,omitempty" url:"deleted_at,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (d *DeleteCatalogObjectResponse) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DeleteCatalogObjectResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteCatalogObjectResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteCatalogObjectResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties

	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteCatalogObjectResponse) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// Defines the fields that are included in requests to the
// `DeleteCustomerCard` endpoint.
type DeleteCustomerCardRequest struct {
	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (d *DeleteCustomerCardRequest) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DeleteCustomerCardRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteCustomerCardRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteCustomerCardRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties

	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteCustomerCardRequest) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// Defines the fields that are included in the response body of
// a request to the `DeleteCustomerCard` endpoint.
type DeleteCustomerCardResponse struct {
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (d *DeleteCustomerCardResponse) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DeleteCustomerCardResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteCustomerCardResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteCustomerCardResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties

	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteCustomerCardResponse) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// Represents a [DeleteCustomerCustomAttributeDefinition](api-endpoint:CustomerCustomAttributes-DeleteCustomerCustomAttributeDefinition) request.
type DeleteCustomerCustomAttributeDefinitionRequest struct {
	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (d *DeleteCustomerCustomAttributeDefinitionRequest) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DeleteCustomerCustomAttributeDefinitionRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteCustomerCustomAttributeDefinitionRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteCustomerCustomAttributeDefinitionRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties

	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteCustomerCustomAttributeDefinitionRequest) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// Represents a [DeleteCustomerCustomAttribute](api-endpoint:CustomerCustomAttributes-DeleteCustomerCustomAttribute) request.
type DeleteCustomerCustomAttributeRequest struct {
	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (d *DeleteCustomerCustomAttributeRequest) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DeleteCustomerCustomAttributeRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteCustomerCustomAttributeRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteCustomerCustomAttributeRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties

	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteCustomerCustomAttributeRequest) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// Represents a [DeleteCustomerCustomAttribute](api-endpoint:CustomerCustomAttributes-DeleteCustomerCustomAttribute) response.
// Either an empty object `{}` (for a successful deletion) or `errors` is present in the response.
type DeleteCustomerCustomAttributeResponse struct {
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (d *DeleteCustomerCustomAttributeResponse) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DeleteCustomerCustomAttributeResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteCustomerCustomAttributeResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteCustomerCustomAttributeResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties

	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteCustomerCustomAttributeResponse) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// Defines the fields that can be included in a request to the
// [DeleteCustomerGroup](api-endpoint:CustomerGroups-DeleteCustomerGroup) endpoint.
type DeleteCustomerGroupRequest struct {
	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (d *DeleteCustomerGroupRequest) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DeleteCustomerGroupRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteCustomerGroupRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteCustomerGroupRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties

	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteCustomerGroupRequest) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// Defines the fields that are included in the response body of
// a request to the [DeleteCustomerGroup](api-endpoint:CustomerGroups-DeleteCustomerGroup) endpoint.
type DeleteCustomerGroupResponse struct {
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (d *DeleteCustomerGroupResponse) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DeleteCustomerGroupResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteCustomerGroupResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteCustomerGroupResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties

	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteCustomerGroupResponse) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// Defines the parameters for a `DeleteDisputeEvidence` request.
type DeleteDisputeEvidenceRequest struct {
	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (d *DeleteDisputeEvidenceRequest) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DeleteDisputeEvidenceRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteDisputeEvidenceRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteDisputeEvidenceRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties

	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteDisputeEvidenceRequest) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// Defines the fields in a `DeleteDisputeEvidence` response.
type DeleteDisputeEvidenceResponse struct {
	// Information about errors encountered during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (d *DeleteDisputeEvidenceResponse) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DeleteDisputeEvidenceResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteDisputeEvidenceResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteDisputeEvidenceResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties

	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteDisputeEvidenceResponse) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// A request to delete a loyalty reward.
type DeleteLoyaltyRewardRequest struct {
	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (d *DeleteLoyaltyRewardRequest) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DeleteLoyaltyRewardRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteLoyaltyRewardRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteLoyaltyRewardRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties

	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteLoyaltyRewardRequest) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// A response returned by the API call.
type DeleteLoyaltyRewardResponse struct {
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (d *DeleteLoyaltyRewardResponse) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DeleteLoyaltyRewardResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteLoyaltyRewardResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteLoyaltyRewardResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties

	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteLoyaltyRewardResponse) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeletePaymentLinkRequest struct {
	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (d *DeletePaymentLinkRequest) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DeletePaymentLinkRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler DeletePaymentLinkRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeletePaymentLinkRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties

	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeletePaymentLinkRequest) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeletePaymentLinkResponse struct {
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The ID of the link that is deleted.
	Id *string `json:"id,omitempty" url:"id,omitempty"`
	// The ID of the order that is canceled. When a payment link is deleted, Square updates the
	// the `state` (of the order that the checkout link created) to CANCELED.
	CancelledOrderId *string `json:"cancelled_order_id,omitempty" url:"cancelled_order_id,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (d *DeletePaymentLinkResponse) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DeletePaymentLinkResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeletePaymentLinkResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeletePaymentLinkResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties

	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeletePaymentLinkResponse) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// A request to delete a `Shift`.
type DeleteShiftRequest struct {
	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (d *DeleteShiftRequest) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DeleteShiftRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteShiftRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteShiftRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties

	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteShiftRequest) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// The response to a request to delete a `Shift`. The response might contain a set of
// `Error` objects if the request resulted in errors.
type DeleteShiftResponse struct {
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (d *DeleteShiftResponse) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DeleteShiftResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteShiftResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteShiftResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties

	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteShiftResponse) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// Represents a `DeleteSnippet` request.
type DeleteSnippetRequest struct {
	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (d *DeleteSnippetRequest) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DeleteSnippetRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteSnippetRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteSnippetRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties

	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteSnippetRequest) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// Defines input parameters in a call to the
// [DeleteSubscriptionAction](api-endpoint:Subscriptions-DeleteSubscriptionAction)
// endpoint.
type DeleteSubscriptionActionRequest struct {
	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (d *DeleteSubscriptionActionRequest) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DeleteSubscriptionActionRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteSubscriptionActionRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteSubscriptionActionRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties

	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteSubscriptionActionRequest) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// Deletes a [Subscription](entity:WebhookSubscription).
type DeleteWebhookSubscriptionRequest struct {
	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (d *DeleteWebhookSubscriptionRequest) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DeleteWebhookSubscriptionRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteWebhookSubscriptionRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteWebhookSubscriptionRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties

	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteWebhookSubscriptionRequest) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// Defines the fields that are included in the response body of
// a request to the [DeleteWebhookSubscription](api-endpoint:WebhookSubscriptions-DeleteWebhookSubscription) endpoint.
type DeleteWebhookSubscriptionResponse struct {
	// Information on errors encountered during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (d *DeleteWebhookSubscriptionResponse) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DeleteWebhookSubscriptionResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteWebhookSubscriptionResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteWebhookSubscriptionResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties

	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteWebhookSubscriptionResponse) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// Defines the parameters for a `DeprecatedCreateDisputeEvidenceFile` request.
type DeprecatedCreateDisputeEvidenceFileRequest struct {
	// The Unique ID. For more information, see [Idempotency](https://developer.squareup.com/docs/working-with-apis/idempotency).
	IdempotencyKey string `json:"idempotency_key" url:"idempotency_key"`
	// The type of evidence you are uploading.
	// See [DisputeEvidenceType](#type-disputeevidencetype) for possible values
	EvidenceType *DisputeEvidenceType `json:"evidence_type,omitempty" url:"evidence_type,omitempty"`
	// The MIME type of the uploaded file.
	// The type can be image/heic, image/heif, image/jpeg, application/pdf, image/png, or image/tiff.
	ContentType *string `json:"content_type,omitempty" url:"content_type,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (d *DeprecatedCreateDisputeEvidenceFileRequest) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DeprecatedCreateDisputeEvidenceFileRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler DeprecatedCreateDisputeEvidenceFileRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeprecatedCreateDisputeEvidenceFileRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties

	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeprecatedCreateDisputeEvidenceFileRequest) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// Defines the fields in a `DeprecatedCreateDisputeEvidenceFile` response.
type DeprecatedCreateDisputeEvidenceFileResponse struct {
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The metadata of the newly uploaded dispute evidence.
	Evidence *DisputeEvidence `json:"evidence,omitempty" url:"evidence,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (d *DeprecatedCreateDisputeEvidenceFileResponse) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DeprecatedCreateDisputeEvidenceFileResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeprecatedCreateDisputeEvidenceFileResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeprecatedCreateDisputeEvidenceFileResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties

	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeprecatedCreateDisputeEvidenceFileResponse) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// Defines the parameters for a `DeprecatedCreateDisputeEvidenceText` request.
type DeprecatedCreateDisputeEvidenceTextRequest struct {
	// The Unique ID. For more information, see [Idempotency](https://developer.squareup.com/docs/working-with-apis/idempotency).
	IdempotencyKey string `json:"idempotency_key" url:"idempotency_key"`
	// The type of evidence you are uploading.
	// See [DisputeEvidenceType](#type-disputeevidencetype) for possible values
	EvidenceType *DisputeEvidenceType `json:"evidence_type,omitempty" url:"evidence_type,omitempty"`
	// The evidence string.
	EvidenceText string `json:"evidence_text" url:"evidence_text"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (d *DeprecatedCreateDisputeEvidenceTextRequest) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DeprecatedCreateDisputeEvidenceTextRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler DeprecatedCreateDisputeEvidenceTextRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeprecatedCreateDisputeEvidenceTextRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties

	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeprecatedCreateDisputeEvidenceTextRequest) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// Defines the fields in a `DeprecatedCreateDisputeEvidenceText` response.
type DeprecatedCreateDisputeEvidenceTextResponse struct {
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The newly uploaded dispute evidence metadata.
	Evidence *DisputeEvidence `json:"evidence,omitempty" url:"evidence,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (d *DeprecatedCreateDisputeEvidenceTextResponse) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DeprecatedCreateDisputeEvidenceTextResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeprecatedCreateDisputeEvidenceTextResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeprecatedCreateDisputeEvidenceTextResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties

	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeprecatedCreateDisputeEvidenceTextResponse) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// Information about the destination against which the payout was made.
type Destination struct {
	// Type of the destination such as a bank account or debit card.
	// See [DestinationType](#type-destinationtype) for possible values
	Type *DestinationType `json:"type,omitempty" url:"type,omitempty"`
	// Square issued unique ID (also known as the instrument ID) associated with this destination.
	Id *string `json:"id,omitempty" url:"id,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (d *Destination) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *Destination) UnmarshalJSON(data []byte) error {
	type unmarshaler Destination
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = Destination(value)

	extraProperties, err := core.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties

	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *Destination) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// List of possible destinations against which a payout can be made.
type DestinationType string

const (
	DestinationTypeUnknownDestinationTypeDoNotUse DestinationType = "UNKNOWN_DESTINATION_TYPE_DO_NOT_USE"
	DestinationTypeBankAccount                    DestinationType = "BANK_ACCOUNT"
	DestinationTypeCard                           DestinationType = "CARD"
	DestinationTypeSquareBalance                  DestinationType = "SQUARE_BALANCE"
	DestinationTypeSquareStoredBalance            DestinationType = "SQUARE_STORED_BALANCE"
)

func NewDestinationTypeFromString(s string) (DestinationType, error) {
	switch s {
	case "UNKNOWN_DESTINATION_TYPE_DO_NOT_USE":
		return DestinationTypeUnknownDestinationTypeDoNotUse, nil
	case "BANK_ACCOUNT":
		return DestinationTypeBankAccount, nil
	case "CARD":
		return DestinationTypeCard, nil
	case "SQUARE_BALANCE":
		return DestinationTypeSquareBalance, nil
	case "SQUARE_STORED_BALANCE":
		return DestinationTypeSquareStoredBalance, nil
	}
	var t DestinationType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (d DestinationType) Ptr() *DestinationType {
	return &d
}

type Device struct {
	// The device's Square-issued ID.
	Id *string `json:"id,omitempty" url:"id,omitempty"`
	// The device's merchant-specified name.
	Name *string `json:"name,omitempty" url:"name,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (d *Device) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *Device) UnmarshalJSON(data []byte) error {
	type unmarshaler Device
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = Device(value)

	extraProperties, err := core.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties

	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *Device) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeviceCheckoutOptions struct {
	// The unique ID of the device intended for this `TerminalCheckout`.
	// A list of `DeviceCode` objects can be retrieved from the /v2/devices/codes endpoint.
	// Match a `DeviceCode.device_id` value with `device_id` to get the associated device code.
	DeviceId string `json:"device_id" url:"device_id"`
	// Instructs the device to skip the receipt screen. Defaults to false.
	SkipReceiptScreen *bool `json:"skip_receipt_screen,omitempty" url:"skip_receipt_screen,omitempty"`
	// Indicates that signature collection is desired during checkout. Defaults to false.
	CollectSignature *bool `json:"collect_signature,omitempty" url:"collect_signature,omitempty"`
	// Tip-specific settings.
	TipSettings *TipSettings `json:"tip_settings,omitempty" url:"tip_settings,omitempty"`
	// Show the itemization screen prior to taking a payment. This field is only meaningful when the
	// checkout includes an order ID. Defaults to true.
	ShowItemizedCart *bool `json:"show_itemized_cart,omitempty" url:"show_itemized_cart,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (d *DeviceCheckoutOptions) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DeviceCheckoutOptions) UnmarshalJSON(data []byte) error {
	type unmarshaler DeviceCheckoutOptions
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeviceCheckoutOptions(value)

	extraProperties, err := core.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties

	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeviceCheckoutOptions) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeviceCode struct {
	// The unique id for this device code.
	Id *string `json:"id,omitempty" url:"id,omitempty"`
	// An optional user-defined name for the device code.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// The unique code that can be used to login.
	Code *string `json:"code,omitempty" url:"code,omitempty"`
	// The unique id of the device that used this code. Populated when the device is paired up.
	DeviceId *string `json:"device_id,omitempty" url:"device_id,omitempty"`
	// The targeting product type of the device code.
	ProductType ProductType `json:"product_type" url:"product_type"`
	// The location assigned to this code.
	LocationId *string `json:"location_id,omitempty" url:"location_id,omitempty"`
	// The pairing status of the device code.
	// See [DeviceCodeStatus](#type-devicecodestatus) for possible values
	Status *DeviceCodeStatus `json:"status,omitempty" url:"status,omitempty"`
	// When this DeviceCode will expire and no longer login. Timestamp in RFC 3339 format.
	PairBy *string `json:"pair_by,omitempty" url:"pair_by,omitempty"`
	// When this DeviceCode was created. Timestamp in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// When this DeviceCode's status was last changed. Timestamp in RFC 3339 format.
	StatusChangedAt *string `json:"status_changed_at,omitempty" url:"status_changed_at,omitempty"`
	// When this DeviceCode was paired. Timestamp in RFC 3339 format.
	PairedAt *string `json:"paired_at,omitempty" url:"paired_at,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (d *DeviceCode) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DeviceCode) UnmarshalJSON(data []byte) error {
	type unmarshaler DeviceCode
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeviceCode(value)

	extraProperties, err := core.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties

	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeviceCode) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// Published when a Square Terminal has been paired with a
// Terminal API client and the device_id of the paired Square Terminal is
// available.
type DeviceCodePairedWebhook struct {
	// The ID of the target merchant associated with the event.
	MerchantId *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The ID of the target location associated with the event.
	LocationId *string `json:"location_id,omitempty" url:"location_id,omitempty"`
	// The type of event this represents, `"device.code.paired"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// A unique ID for the webhook event.
	EventId *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// RFC 3339 timestamp of when the webhook event was created.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// Data associated with the event.
	Data *DeviceCodePairedWebhookData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (d *DeviceCodePairedWebhook) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DeviceCodePairedWebhook) UnmarshalJSON(data []byte) error {
	type unmarshaler DeviceCodePairedWebhook
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeviceCodePairedWebhook(value)

	extraProperties, err := core.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties

	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeviceCodePairedWebhook) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeviceCodePairedWebhookData struct {
	// Name of the paired object’s type, `"device.code"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// ID of the paired device code.
	Id *string `json:"id,omitempty" url:"id,omitempty"`
	// An object containing the paired device code.
	Object *DeviceCodePairedWebhookObject `json:"object,omitempty" url:"object,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (d *DeviceCodePairedWebhookData) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DeviceCodePairedWebhookData) UnmarshalJSON(data []byte) error {
	type unmarshaler DeviceCodePairedWebhookData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeviceCodePairedWebhookData(value)

	extraProperties, err := core.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties

	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeviceCodePairedWebhookData) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeviceCodePairedWebhookObject struct {
	// The created terminal checkout
	DeviceCode *DeviceCode `json:"device_code,omitempty" url:"device_code,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (d *DeviceCodePairedWebhookObject) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DeviceCodePairedWebhookObject) UnmarshalJSON(data []byte) error {
	type unmarshaler DeviceCodePairedWebhookObject
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeviceCodePairedWebhookObject(value)

	extraProperties, err := core.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties

	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeviceCodePairedWebhookObject) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// DeviceCode.Status enum.
type DeviceCodeStatus string

const (
	DeviceCodeStatusUnknown  DeviceCodeStatus = "UNKNOWN"
	DeviceCodeStatusUnpaired DeviceCodeStatus = "UNPAIRED"
	DeviceCodeStatusPaired   DeviceCodeStatus = "PAIRED"
	DeviceCodeStatusExpired  DeviceCodeStatus = "EXPIRED"
)

func NewDeviceCodeStatusFromString(s string) (DeviceCodeStatus, error) {
	switch s {
	case "UNKNOWN":
		return DeviceCodeStatusUnknown, nil
	case "UNPAIRED":
		return DeviceCodeStatusUnpaired, nil
	case "PAIRED":
		return DeviceCodeStatusPaired, nil
	case "EXPIRED":
		return DeviceCodeStatusExpired, nil
	}
	var t DeviceCodeStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (d DeviceCodeStatus) Ptr() *DeviceCodeStatus {
	return &d
}

// Details about the device that took the payment.
type DeviceDetails struct {
	// The Square-issued ID of the device.
	DeviceId *string `json:"device_id,omitempty" url:"device_id,omitempty"`
	// The Square-issued installation ID for the device.
	DeviceInstallationId *string `json:"device_installation_id,omitempty" url:"device_installation_id,omitempty"`
	// The name of the device set by the seller.
	DeviceName *string `json:"device_name,omitempty" url:"device_name,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (d *DeviceDetails) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DeviceDetails) UnmarshalJSON(data []byte) error {
	type unmarshaler DeviceDetails
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeviceDetails(value)

	extraProperties, err := core.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties

	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeviceDetails) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeviceMetadata struct {
	// The Terminal’s remaining battery percentage, between 1-100.
	BatteryPercentage *string `json:"battery_percentage,omitempty" url:"battery_percentage,omitempty"`
	// The current charging state of the Terminal.
	// Options: `CHARGING`, `NOT_CHARGING`
	ChargingState *string `json:"charging_state,omitempty" url:"charging_state,omitempty"`
	// The ID of the Square seller business location associated with the Terminal.
	LocationId *string `json:"location_id,omitempty" url:"location_id,omitempty"`
	// The ID of the Square merchant account that is currently signed-in to the Terminal.
	MerchantId *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The Terminal’s current network connection type.
	// Options: `WIFI`, `ETHERNET`
	NetworkConnectionType *string `json:"network_connection_type,omitempty" url:"network_connection_type,omitempty"`
	// The country in which the Terminal is authorized to take payments.
	PaymentRegion *string `json:"payment_region,omitempty" url:"payment_region,omitempty"`
	// The unique identifier assigned to the Terminal, which can be found on the lower back
	// of the device.
	SerialNumber *string `json:"serial_number,omitempty" url:"serial_number,omitempty"`
	// The current version of the Terminal’s operating system.
	OsVersion *string `json:"os_version,omitempty" url:"os_version,omitempty"`
	// The current version of the application running on the Terminal.
	AppVersion *string `json:"app_version,omitempty" url:"app_version,omitempty"`
	// The name of the Wi-Fi network to which the Terminal is connected.
	WifiNetworkName *string `json:"wifi_network_name,omitempty" url:"wifi_network_name,omitempty"`
	// The signal strength of the Wi-FI network connection.
	// Options: `POOR`, `FAIR`, `GOOD`, `EXCELLENT`
	WifiNetworkStrength *string `json:"wifi_network_strength,omitempty" url:"wifi_network_strength,omitempty"`
	// The IP address of the Terminal.
	IpAddress *string `json:"ip_address,omitempty" url:"ip_address,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (d *DeviceMetadata) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DeviceMetadata) UnmarshalJSON(data []byte) error {
	type unmarshaler DeviceMetadata
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeviceMetadata(value)

	extraProperties, err := core.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties

	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeviceMetadata) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// Additional details about `WALLET` type payments. Contains only non-confidential information.
type DigitalWalletDetails struct {
	// The status of the `WALLET` payment. The status can be `AUTHORIZED`, `CAPTURED`, `VOIDED`, or
	// `FAILED`.
	Status *string `json:"status,omitempty" url:"status,omitempty"`
	// The brand used for the `WALLET` payment. The brand can be `CASH_APP`, `PAYPAY` or `UNKNOWN`.
	Brand *string `json:"brand,omitempty" url:"brand,omitempty"`
	// Brand-specific details for payments with the `brand` of `CASH_APP`.
	CashAppDetails *CashAppDetails `json:"cash_app_details,omitempty" url:"cash_app_details,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (d *DigitalWalletDetails) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DigitalWalletDetails) UnmarshalJSON(data []byte) error {
	type unmarshaler DigitalWalletDetails
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DigitalWalletDetails(value)

	extraProperties, err := core.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties

	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DigitalWalletDetails) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// Represents a [dispute](https://developer.squareup.com/docs/disputes-api/overview) a cardholder initiated with their bank.
type Dispute struct {
	// The unique ID for this `Dispute`, generated by Square.
	DisputeId *string `json:"dispute_id,omitempty" url:"dispute_id,omitempty"`
	// The unique ID for this `Dispute`, generated by Square.
	Id *string `json:"id,omitempty" url:"id,omitempty"`
	// The disputed amount, which can be less than the total transaction amount.
	// For instance, if multiple items were purchased but the cardholder only initiates a dispute over some of the items.
	AmountMoney *Money `json:"amount_money,omitempty" url:"amount_money,omitempty"`
	// The reason why the cardholder initiated the dispute.
	// See [DisputeReason](#type-disputereason) for possible values
	Reason *DisputeReason `json:"reason,omitempty" url:"reason,omitempty"`
	// The current state of this dispute.
	// See [DisputeState](#type-disputestate) for possible values
	State *DisputeState `json:"state,omitempty" url:"state,omitempty"`
	// The deadline by which the seller must respond to the dispute, in [RFC 3339 format](https://developer.squareup.com/docs/build-basics/common-data-types/working-with-dates).
	DueAt *string `json:"due_at,omitempty" url:"due_at,omitempty"`
	// The payment challenged in this dispute.
	DisputedPayment *DisputedPayment `json:"disputed_payment,omitempty" url:"disputed_payment,omitempty"`
	// The IDs of the evidence associated with the dispute.
	EvidenceIds []string `json:"evidence_ids,omitempty" url:"evidence_ids,omitempty"`
	// The card brand used in the disputed payment.
	// See [CardBrand](#type-cardbrand) for possible values
	CardBrand *CardBrand `json:"card_brand,omitempty" url:"card_brand,omitempty"`
	// The timestamp when the dispute was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The timestamp when the dispute was last updated, in RFC 3339 format.
	UpdatedAt *string `json:"updated_at,omitempty" url:"updated_at,omitempty"`
	// The ID of the dispute in the card brand system, generated by the card brand.
	BrandDisputeId *string `json:"brand_dispute_id,omitempty" url:"brand_dispute_id,omitempty"`
	// The timestamp when the dispute was reported, in RFC 3339 format.
	ReportedDate *string `json:"reported_date,omitempty" url:"reported_date,omitempty"`
	// The timestamp when the dispute was reported, in RFC 3339 format.
	ReportedAt *string `json:"reported_at,omitempty" url:"reported_at,omitempty"`
	// The current version of the `Dispute`.
	Version *int `json:"version,omitempty" url:"version,omitempty"`
	// The ID of the location where the dispute originated.
	LocationId *string `json:"location_id,omitempty" url:"location_id,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (d *Dispute) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *Dispute) UnmarshalJSON(data []byte) error {
	type unmarshaler Dispute
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = Dispute(value)

	extraProperties, err := core.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties

	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *Dispute) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// Published when a [Dispute](entity:Dispute) is created.
type DisputeCreatedWebhook struct {
	// The ID of the target merchant associated with the event.
	MerchantId *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The ID of the target location associated with the event.
	LocationId *string `json:"location_id,omitempty" url:"location_id,omitempty"`
	// The type of event this represents.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// A unique ID for the webhook event.
	EventId *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// Timestamp of when the webhook event was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// Data associated with the event.
	Data *DisputeCreatedWebhookData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (d *DisputeCreatedWebhook) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DisputeCreatedWebhook) UnmarshalJSON(data []byte) error {
	type unmarshaler DisputeCreatedWebhook
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DisputeCreatedWebhook(value)

	extraProperties, err := core.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties

	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DisputeCreatedWebhook) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DisputeCreatedWebhookData struct {
	// Name of the affected dispute's type.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// ID of the affected dispute.
	Id *string `json:"id,omitempty" url:"id,omitempty"`
	// An object containing fields and values relevant to the event.
	Object *DisputeCreatedWebhookObject `json:"object,omitempty" url:"object,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (d *DisputeCreatedWebhookData) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DisputeCreatedWebhookData) UnmarshalJSON(data []byte) error {
	type unmarshaler DisputeCreatedWebhookData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DisputeCreatedWebhookData(value)

	extraProperties, err := core.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties

	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DisputeCreatedWebhookData) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DisputeCreatedWebhookObject struct {
	// The dispute object.
	Object *Dispute `json:"object,omitempty" url:"object,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (d *DisputeCreatedWebhookObject) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DisputeCreatedWebhookObject) UnmarshalJSON(data []byte) error {
	type unmarshaler DisputeCreatedWebhookObject
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DisputeCreatedWebhookObject(value)

	extraProperties, err := core.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties

	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DisputeCreatedWebhookObject) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DisputeEvidence struct {
	// The Square-generated ID of the evidence.
	EvidenceId *string `json:"evidence_id,omitempty" url:"evidence_id,omitempty"`
	// The Square-generated ID of the evidence.
	Id *string `json:"id,omitempty" url:"id,omitempty"`
	// The ID of the dispute the evidence is associated with.
	DisputeId *string `json:"dispute_id,omitempty" url:"dispute_id,omitempty"`
	// Image, PDF, TXT
	EvidenceFile *DisputeEvidenceFile `json:"evidence_file,omitempty" url:"evidence_file,omitempty"`
	// Raw text
	EvidenceText *string `json:"evidence_text,omitempty" url:"evidence_text,omitempty"`
	// The time when the evidence was uploaded, in RFC 3339 format.
	UploadedAt *string `json:"uploaded_at,omitempty" url:"uploaded_at,omitempty"`
	// The type of the evidence.
	// See [DisputeEvidenceType](#type-disputeevidencetype) for possible values
	EvidenceType *DisputeEvidenceType `json:"evidence_type,omitempty" url:"evidence_type,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (d *DisputeEvidence) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DisputeEvidence) UnmarshalJSON(data []byte) error {
	type unmarshaler DisputeEvidence
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DisputeEvidence(value)

	extraProperties, err := core.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties

	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DisputeEvidence) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// Published when evidence is added to a [Dispute](entity:Dispute)
// from the Disputes Dashboard in the Seller Dashboard, the Square Point of Sale app,
// or by calling either [CreateDisputeEvidenceFile](api-endpoint:Disputes-CreateDisputeEvidenceFile) or [CreateDisputeEvidenceText](api-endpoint:Disputes-CreateDisputeEvidenceText).
type DisputeEvidenceAddedWebhook struct {
	// The ID of the target merchant associated with the event.
	MerchantId *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The ID of the target location associated with the event.
	LocationId *string `json:"location_id,omitempty" url:"location_id,omitempty"`
	// The type of event this represents.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// A unique ID for the webhook event.
	EventId *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// Timestamp of when the webhook event was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// Data associated with the event.
	Data *DisputeEvidenceAddedWebhookData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (d *DisputeEvidenceAddedWebhook) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DisputeEvidenceAddedWebhook) UnmarshalJSON(data []byte) error {
	type unmarshaler DisputeEvidenceAddedWebhook
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DisputeEvidenceAddedWebhook(value)

	extraProperties, err := core.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties

	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DisputeEvidenceAddedWebhook) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DisputeEvidenceAddedWebhookData struct {
	// Name of the affected dispute's type.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// ID of the affected dispute.
	Id *string `json:"id,omitempty" url:"id,omitempty"`
	// An object containing fields and values relevant to the event.
	Object *DisputeEvidenceAddedWebhookObject `json:"object,omitempty" url:"object,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (d *DisputeEvidenceAddedWebhookData) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DisputeEvidenceAddedWebhookData) UnmarshalJSON(data []byte) error {
	type unmarshaler DisputeEvidenceAddedWebhookData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DisputeEvidenceAddedWebhookData(value)

	extraProperties, err := core.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties

	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DisputeEvidenceAddedWebhookData) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DisputeEvidenceAddedWebhookObject struct {
	// The dispute object.
	Object *Dispute `json:"object,omitempty" url:"object,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (d *DisputeEvidenceAddedWebhookObject) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DisputeEvidenceAddedWebhookObject) UnmarshalJSON(data []byte) error {
	type unmarshaler DisputeEvidenceAddedWebhookObject
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DisputeEvidenceAddedWebhookObject(value)

	extraProperties, err := core.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties

	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DisputeEvidenceAddedWebhookObject) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// Published when evidence is added to a [Dispute](entity:Dispute)
// from the Disputes Dashboard in the Seller Dashboard, the Square Point of Sale app,
// or by calling either [CreateDisputeEvidenceFile](api-endpoint:Disputes-CreateDisputeEvidenceFile) or [CreateDisputeEvidenceText](api-endpoint:Disputes-CreateDisputeEvidenceText).
type DisputeEvidenceCreatedWebhook struct {
	// The ID of the target merchant associated with the event.
	MerchantId *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The ID of the target location associated with the event.
	LocationId *string `json:"location_id,omitempty" url:"location_id,omitempty"`
	// The type of event this represents.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// A unique ID for the webhook event.
	EventId *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// Timestamp of when the webhook event was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// Data associated with the event.
	Data *DisputeEvidenceCreatedWebhookData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (d *DisputeEvidenceCreatedWebhook) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DisputeEvidenceCreatedWebhook) UnmarshalJSON(data []byte) error {
	type unmarshaler DisputeEvidenceCreatedWebhook
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DisputeEvidenceCreatedWebhook(value)

	extraProperties, err := core.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties

	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DisputeEvidenceCreatedWebhook) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DisputeEvidenceCreatedWebhookData struct {
	// Name of the affected dispute's type.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// ID of the affected dispute.
	Id *string `json:"id,omitempty" url:"id,omitempty"`
	// An object containing fields and values relevant to the event.
	Object *DisputeEvidenceCreatedWebhookObject `json:"object,omitempty" url:"object,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (d *DisputeEvidenceCreatedWebhookData) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DisputeEvidenceCreatedWebhookData) UnmarshalJSON(data []byte) error {
	type unmarshaler DisputeEvidenceCreatedWebhookData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DisputeEvidenceCreatedWebhookData(value)

	extraProperties, err := core.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties

	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DisputeEvidenceCreatedWebhookData) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DisputeEvidenceCreatedWebhookObject struct {
	// The dispute object.
	Object *Dispute `json:"object,omitempty" url:"object,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (d *DisputeEvidenceCreatedWebhookObject) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DisputeEvidenceCreatedWebhookObject) UnmarshalJSON(data []byte) error {
	type unmarshaler DisputeEvidenceCreatedWebhookObject
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DisputeEvidenceCreatedWebhookObject(value)

	extraProperties, err := core.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties

	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DisputeEvidenceCreatedWebhookObject) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// Published when evidence is removed from a [Dispute](entity:Dispute)
// from the Disputes Dashboard in the Seller Dashboard, the Square Point of Sale app,
// or by calling [DeleteDisputeEvidence](api-endpoint:Disputes-DeleteDisputeEvidence).
type DisputeEvidenceDeletedWebhook struct {
	// The ID of the target merchant associated with the event.
	MerchantId *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The ID of the target location associated with the event.
	LocationId *string `json:"location_id,omitempty" url:"location_id,omitempty"`
	// The type of event this represents.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// A unique ID for the webhook event.
	EventId *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// Timestamp of when the webhook event was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// Data associated with the event.
	Data *DisputeEvidenceDeletedWebhookData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (d *DisputeEvidenceDeletedWebhook) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DisputeEvidenceDeletedWebhook) UnmarshalJSON(data []byte) error {
	type unmarshaler DisputeEvidenceDeletedWebhook
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DisputeEvidenceDeletedWebhook(value)

	extraProperties, err := core.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties

	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DisputeEvidenceDeletedWebhook) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DisputeEvidenceDeletedWebhookData struct {
	// Name of the affected dispute's type.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// ID of the affected dispute.
	Id *string `json:"id,omitempty" url:"id,omitempty"`
	// An object containing fields and values relevant to the event.
	Object *DisputeEvidenceDeletedWebhookObject `json:"object,omitempty" url:"object,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (d *DisputeEvidenceDeletedWebhookData) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DisputeEvidenceDeletedWebhookData) UnmarshalJSON(data []byte) error {
	type unmarshaler DisputeEvidenceDeletedWebhookData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DisputeEvidenceDeletedWebhookData(value)

	extraProperties, err := core.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties

	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DisputeEvidenceDeletedWebhookData) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DisputeEvidenceDeletedWebhookObject struct {
	// The dispute object.
	Object *Dispute `json:"object,omitempty" url:"object,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (d *DisputeEvidenceDeletedWebhookObject) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DisputeEvidenceDeletedWebhookObject) UnmarshalJSON(data []byte) error {
	type unmarshaler DisputeEvidenceDeletedWebhookObject
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DisputeEvidenceDeletedWebhookObject(value)

	extraProperties, err := core.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties

	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DisputeEvidenceDeletedWebhookObject) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// A file to be uploaded as dispute evidence.
type DisputeEvidenceFile struct {
	// The file name including the file extension. For example: "receipt.tiff".
	Filename *string `json:"filename,omitempty" url:"filename,omitempty"`
	// Dispute evidence files must be application/pdf, image/heic, image/heif, image/jpeg, image/png, or image/tiff formats.
	Filetype *string `json:"filetype,omitempty" url:"filetype,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (d *DisputeEvidenceFile) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DisputeEvidenceFile) UnmarshalJSON(data []byte) error {
	type unmarshaler DisputeEvidenceFile
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DisputeEvidenceFile(value)

	extraProperties, err := core.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties

	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DisputeEvidenceFile) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// Published when evidence is removed from a [Dispute](entity:Dispute)
// from the Disputes Dashboard in the Seller Dashboard, the Square Point of Sale app,
// or by calling [DeleteDisputeEvidence](api-endpoint:Disputes-DeleteDisputeEvidence).
type DisputeEvidenceRemovedWebhook struct {
	// The ID of the target merchant associated with the event.
	MerchantId *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The ID of the target location associated with the event.
	LocationId *string `json:"location_id,omitempty" url:"location_id,omitempty"`
	// The type of event this represents.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// A unique ID for the webhook event.
	EventId *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// Timestamp of when the webhook event was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// Data associated with the event.
	Data *DisputeEvidenceRemovedWebhookData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (d *DisputeEvidenceRemovedWebhook) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DisputeEvidenceRemovedWebhook) UnmarshalJSON(data []byte) error {
	type unmarshaler DisputeEvidenceRemovedWebhook
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DisputeEvidenceRemovedWebhook(value)

	extraProperties, err := core.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties

	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DisputeEvidenceRemovedWebhook) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DisputeEvidenceRemovedWebhookData struct {
	// Name of the affected dispute's type.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// ID of the affected dispute.
	Id *string `json:"id,omitempty" url:"id,omitempty"`
	// An object containing fields and values relevant to the event.
	Object *DisputeEvidenceRemovedWebhookObject `json:"object,omitempty" url:"object,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (d *DisputeEvidenceRemovedWebhookData) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DisputeEvidenceRemovedWebhookData) UnmarshalJSON(data []byte) error {
	type unmarshaler DisputeEvidenceRemovedWebhookData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DisputeEvidenceRemovedWebhookData(value)

	extraProperties, err := core.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties

	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DisputeEvidenceRemovedWebhookData) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DisputeEvidenceRemovedWebhookObject struct {
	// The dispute object.
	Object *Dispute `json:"object,omitempty" url:"object,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (d *DisputeEvidenceRemovedWebhookObject) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DisputeEvidenceRemovedWebhookObject) UnmarshalJSON(data []byte) error {
	type unmarshaler DisputeEvidenceRemovedWebhookObject
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DisputeEvidenceRemovedWebhookObject(value)

	extraProperties, err := core.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties

	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DisputeEvidenceRemovedWebhookObject) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// The list of possible reasons why a cardholder might initiate a
// dispute with their bank.
type DisputeReason string

const (
	DisputeReasonUnknownReason          DisputeReason = "UNKNOWN_REASON"
	DisputeReasonAmountDiffers          DisputeReason = "AMOUNT_DIFFERS"
	DisputeReasonCancelled              DisputeReason = "CANCELLED"
	DisputeReasonCompliance             DisputeReason = "COMPLIANCE"
	DisputeReasonDissatisfied           DisputeReason = "DISSATISFIED"
	DisputeReasonDuplicate              DisputeReason = "DUPLICATE"
	DisputeReasonFraud                  DisputeReason = "FRAUD"
	DisputeReasonNoKnowledge            DisputeReason = "NO_KNOWLEDGE"
	DisputeReasonNotAsDescribed         DisputeReason = "NOT_AS_DESCRIBED"
	DisputeReasonNotReceived            DisputeReason = "NOT_RECEIVED"
	DisputeReasonPaidByOtherMeans       DisputeReason = "PAID_BY_OTHER_MEANS"
	DisputeReasonCustomerRequestsCredit DisputeReason = "CUSTOMER_REQUESTS_CREDIT"
	DisputeReasonUnauthorized           DisputeReason = "UNAUTHORIZED"
	DisputeReasonReturned               DisputeReason = "RETURNED"
	DisputeReasonInsufficientResponse   DisputeReason = "INSUFFICIENT_RESPONSE"
	DisputeReasonRequestDocumentation   DisputeReason = "REQUEST_DOCUMENTATION"
	DisputeReasonEmvLiabilityShift      DisputeReason = "EMV_LIABILITY_SHIFT"
)

func NewDisputeReasonFromString(s string) (DisputeReason, error) {
	switch s {
	case "UNKNOWN_REASON":
		return DisputeReasonUnknownReason, nil
	case "AMOUNT_DIFFERS":
		return DisputeReasonAmountDiffers, nil
	case "CANCELLED":
		return DisputeReasonCancelled, nil
	case "COMPLIANCE":
		return DisputeReasonCompliance, nil
	case "DISSATISFIED":
		return DisputeReasonDissatisfied, nil
	case "DUPLICATE":
		return DisputeReasonDuplicate, nil
	case "FRAUD":
		return DisputeReasonFraud, nil
	case "NO_KNOWLEDGE":
		return DisputeReasonNoKnowledge, nil
	case "NOT_AS_DESCRIBED":
		return DisputeReasonNotAsDescribed, nil
	case "NOT_RECEIVED":
		return DisputeReasonNotReceived, nil
	case "PAID_BY_OTHER_MEANS":
		return DisputeReasonPaidByOtherMeans, nil
	case "CUSTOMER_REQUESTS_CREDIT":
		return DisputeReasonCustomerRequestsCredit, nil
	case "UNAUTHORIZED":
		return DisputeReasonUnauthorized, nil
	case "RETURNED":
		return DisputeReasonReturned, nil
	case "INSUFFICIENT_RESPONSE":
		return DisputeReasonInsufficientResponse, nil
	case "REQUEST_DOCUMENTATION":
		return DisputeReasonRequestDocumentation, nil
	case "EMV_LIABILITY_SHIFT":
		return DisputeReasonEmvLiabilityShift, nil
	}
	var t DisputeReason
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (d DisputeReason) Ptr() *DisputeReason {
	return &d
}

// Published when the state of a [Dispute](entity:Dispute) changes.
// This includes the dispute resolution (WON, LOST) reported by the bank. The event
// data includes details of what changed.
type DisputeStateChangedWebhook struct {
	// The ID of the target merchant associated with the event.
	MerchantId *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The ID of the target location associated with the event.
	LocationId *string `json:"location_id,omitempty" url:"location_id,omitempty"`
	// The type of event this represents.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// A unique ID for the webhook event.
	EventId *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// Timestamp of when the webhook event was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// Data associated with the event.
	Data *DisputeStateChangedWebhookData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (d *DisputeStateChangedWebhook) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DisputeStateChangedWebhook) UnmarshalJSON(data []byte) error {
	type unmarshaler DisputeStateChangedWebhook
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DisputeStateChangedWebhook(value)

	extraProperties, err := core.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties

	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DisputeStateChangedWebhook) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DisputeStateChangedWebhookData struct {
	// Name of the affected dispute's type.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// ID of the affected dispute.
	Id *string `json:"id,omitempty" url:"id,omitempty"`
	// An object containing fields and values relevant to the event.
	Object *DisputeStateChangedWebhookObject `json:"object,omitempty" url:"object,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (d *DisputeStateChangedWebhookData) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DisputeStateChangedWebhookData) UnmarshalJSON(data []byte) error {
	type unmarshaler DisputeStateChangedWebhookData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DisputeStateChangedWebhookData(value)

	extraProperties, err := core.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties

	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DisputeStateChangedWebhookData) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DisputeStateChangedWebhookObject struct {
	// The dispute object.
	Object *Dispute `json:"object,omitempty" url:"object,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (d *DisputeStateChangedWebhookObject) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DisputeStateChangedWebhookObject) UnmarshalJSON(data []byte) error {
	type unmarshaler DisputeStateChangedWebhookObject
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DisputeStateChangedWebhookObject(value)

	extraProperties, err := core.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties

	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DisputeStateChangedWebhookObject) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// Published when the state of a [Dispute](entity:Dispute) changes.
// This includes the dispute resolution (WON, LOST) reported by the bank. The event
// data includes details of what changed.
type DisputeStateUpdatedWebhook struct {
	// The ID of the target merchant associated with the event.
	MerchantId *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The ID of the target location associated with the event.
	LocationId *string `json:"location_id,omitempty" url:"location_id,omitempty"`
	// The type of event this represents.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// A unique ID for the webhook event.
	EventId *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// Timestamp of when the webhook event was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// Data associated with the event.
	Data *DisputeStateUpdatedWebhookData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (d *DisputeStateUpdatedWebhook) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DisputeStateUpdatedWebhook) UnmarshalJSON(data []byte) error {
	type unmarshaler DisputeStateUpdatedWebhook
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DisputeStateUpdatedWebhook(value)

	extraProperties, err := core.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties

	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DisputeStateUpdatedWebhook) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DisputeStateUpdatedWebhookData struct {
	// Name of the affected dispute's type.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// ID of the affected dispute.
	Id *string `json:"id,omitempty" url:"id,omitempty"`
	// An object containing fields and values relevant to the event.
	Object *DisputeStateUpdatedWebhookObject `json:"object,omitempty" url:"object,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (d *DisputeStateUpdatedWebhookData) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DisputeStateUpdatedWebhookData) UnmarshalJSON(data []byte) error {
	type unmarshaler DisputeStateUpdatedWebhookData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DisputeStateUpdatedWebhookData(value)

	extraProperties, err := core.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties

	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DisputeStateUpdatedWebhookData) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DisputeStateUpdatedWebhookObject struct {
	// The dispute object.
	Object *Dispute `json:"object,omitempty" url:"object,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (d *DisputeStateUpdatedWebhookObject) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DisputeStateUpdatedWebhookObject) UnmarshalJSON(data []byte) error {
	type unmarshaler DisputeStateUpdatedWebhookObject
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DisputeStateUpdatedWebhookObject(value)

	extraProperties, err := core.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties

	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DisputeStateUpdatedWebhookObject) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// The payment the cardholder disputed.
type DisputedPayment struct {
	// Square-generated unique ID of the payment being disputed.
	PaymentId *string `json:"payment_id,omitempty" url:"payment_id,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (d *DisputedPayment) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DisputedPayment) UnmarshalJSON(data []byte) error {
	type unmarshaler DisputedPayment
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DisputedPayment(value)

	extraProperties, err := core.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties

	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DisputedPayment) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// Determines item visibility in Ecom (Online Store) and Online Checkout.
type EcomVisibility string

const (
	EcomVisibilityEcomVisibilityDoNotUse EcomVisibility = "ECOM_VISIBILITY_DO_NOT_USE"
	EcomVisibilityUnindexed              EcomVisibility = "UNINDEXED"
	EcomVisibilityUnavailable            EcomVisibility = "UNAVAILABLE"
	EcomVisibilityHidden                 EcomVisibility = "HIDDEN"
	EcomVisibilityVisible                EcomVisibility = "VISIBLE"
)

func NewEcomVisibilityFromString(s string) (EcomVisibility, error) {
	switch s {
	case "ECOM_VISIBILITY_DO_NOT_USE":
		return EcomVisibilityEcomVisibilityDoNotUse, nil
	case "UNINDEXED":
		return EcomVisibilityUnindexed, nil
	case "UNAVAILABLE":
		return EcomVisibilityUnavailable, nil
	case "HIDDEN":
		return EcomVisibilityHidden, nil
	case "VISIBLE":
		return EcomVisibilityVisible, nil
	}
	var t EcomVisibility
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (e EcomVisibility) Ptr() *EcomVisibility {
	return &e
}

// An employee object that is used by the external API.
type Employee struct {
	// UUID for this object.
	Id *string `json:"id,omitempty" url:"id,omitempty"`
	// The employee's first name.
	FirstName *string `json:"first_name,omitempty" url:"first_name,omitempty"`
	// The employee's last name.
	LastName *string `json:"last_name,omitempty" url:"last_name,omitempty"`
	// The employee's email address
	Email *string `json:"email,omitempty" url:"email,omitempty"`
	// The employee's phone number in E.164 format, i.e. "+12125554250"
	PhoneNumber *string `json:"phone_number,omitempty" url:"phone_number,omitempty"`
	// A list of location IDs where this employee has access to.
	LocationIds []string `json:"location_ids,omitempty" url:"location_ids,omitempty"`
	// Specifies the status of the employees being fetched.
	// See [EmployeeStatus](#type-employeestatus) for possible values
	Status *EmployeeStatus `json:"status,omitempty" url:"status,omitempty"`
	// Whether this employee is the owner of the merchant. Each merchant
	// has one owner employee, and that employee has full authority over
	// the account.
	IsOwner *bool `json:"is_owner,omitempty" url:"is_owner,omitempty"`
	// A read-only timestamp in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// A read-only timestamp in RFC 3339 format.
	UpdatedAt *string `json:"updated_at,omitempty" url:"updated_at,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (e *Employee) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *Employee) UnmarshalJSON(data []byte) error {
	type unmarshaler Employee
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = Employee(value)

	extraProperties, err := core.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties

	e._rawJSON = json.RawMessage(data)
	return nil
}

func (e *Employee) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

// The hourly wage rate that an employee earns on a `Shift` for doing the job
// specified by the `title` property of this object. Deprecated at version 2020-08-26. Use `TeamMemberWage` instead.
type EmployeeWage struct {
	// The UUID for this object.
	Id *string `json:"id,omitempty" url:"id,omitempty"`
	// The `Employee` that this wage is assigned to.
	EmployeeId *string `json:"employee_id,omitempty" url:"employee_id,omitempty"`
	// The job title that this wage relates to.
	Title *string `json:"title,omitempty" url:"title,omitempty"`
	// Can be a custom-set hourly wage or the calculated effective hourly
	// wage based on the annual wage and hours worked per week.
	HourlyRate *Money `json:"hourly_rate,omitempty" url:"hourly_rate,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (e *EmployeeWage) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EmployeeWage) UnmarshalJSON(data []byte) error {
	type unmarshaler EmployeeWage
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EmployeeWage(value)

	extraProperties, err := core.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties

	e._rawJSON = json.RawMessage(data)
	return nil
}

func (e *EmployeeWage) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

// Represents an error encountered during a request to the Connect API.
//
// See [Handling errors](https://developer.squareup.com/docs/build-basics/handling-errors) for more information.
type Error struct {
	// The high-level category for the error.
	// See [ErrorCategory](#type-errorcategory) for possible values
	Category ErrorCategory `json:"category" url:"category"`
	// The specific code of the error.
	// See [ErrorCode](#type-errorcode) for possible values
	Code ErrorCode `json:"code" url:"code"`
	// A human-readable description of the error for debugging purposes.
	Detail *string `json:"detail,omitempty" url:"detail,omitempty"`
	// The name of the field provided in the original request (if any) that
	// the error pertains to.
	Field *string `json:"field,omitempty" url:"field,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (e *Error) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *Error) UnmarshalJSON(data []byte) error {
	type unmarshaler Error
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = Error(value)

	extraProperties, err := core.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties

	e._rawJSON = json.RawMessage(data)
	return nil
}

func (e *Error) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

// Indicates which high-level category of error has occurred during a
// request to the Connect API.
type ErrorCategory string

const (
	ErrorCategoryApiError                  ErrorCategory = "API_ERROR"
	ErrorCategoryAuthenticationError       ErrorCategory = "AUTHENTICATION_ERROR"
	ErrorCategoryInvalidRequestError       ErrorCategory = "INVALID_REQUEST_ERROR"
	ErrorCategoryRateLimitError            ErrorCategory = "RATE_LIMIT_ERROR"
	ErrorCategoryPaymentMethodError        ErrorCategory = "PAYMENT_METHOD_ERROR"
	ErrorCategoryRefundError               ErrorCategory = "REFUND_ERROR"
	ErrorCategoryMerchantSubscriptionError ErrorCategory = "MERCHANT_SUBSCRIPTION_ERROR"
)

func NewErrorCategoryFromString(s string) (ErrorCategory, error) {
	switch s {
	case "API_ERROR":
		return ErrorCategoryApiError, nil
	case "AUTHENTICATION_ERROR":
		return ErrorCategoryAuthenticationError, nil
	case "INVALID_REQUEST_ERROR":
		return ErrorCategoryInvalidRequestError, nil
	case "RATE_LIMIT_ERROR":
		return ErrorCategoryRateLimitError, nil
	case "PAYMENT_METHOD_ERROR":
		return ErrorCategoryPaymentMethodError, nil
	case "REFUND_ERROR":
		return ErrorCategoryRefundError, nil
	case "MERCHANT_SUBSCRIPTION_ERROR":
		return ErrorCategoryMerchantSubscriptionError, nil
	}
	var t ErrorCategory
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (e ErrorCategory) Ptr() *ErrorCategory {
	return &e
}

// Indicates the specific error that occurred during a request to a
// Square API.
type ErrorCode string

const (
	ErrorCodeInternalServerError                                 ErrorCode = "INTERNAL_SERVER_ERROR"
	ErrorCodeUnauthorized                                        ErrorCode = "UNAUTHORIZED"
	ErrorCodeAccessTokenExpired                                  ErrorCode = "ACCESS_TOKEN_EXPIRED"
	ErrorCodeAccessTokenRevoked                                  ErrorCode = "ACCESS_TOKEN_REVOKED"
	ErrorCodeClientDisabled                                      ErrorCode = "CLIENT_DISABLED"
	ErrorCodeForbidden                                           ErrorCode = "FORBIDDEN"
	ErrorCodeInsufficientScopes                                  ErrorCode = "INSUFFICIENT_SCOPES"
	ErrorCodeApplicationDisabled                                 ErrorCode = "APPLICATION_DISABLED"
	ErrorCodeV1Application                                       ErrorCode = "V1_APPLICATION"
	ErrorCodeV1AccessToken                                       ErrorCode = "V1_ACCESS_TOKEN"
	ErrorCodeCardProcessingNotEnabled                            ErrorCode = "CARD_PROCESSING_NOT_ENABLED"
	ErrorCodeMerchantSubscriptionNotFound                        ErrorCode = "MERCHANT_SUBSCRIPTION_NOT_FOUND"
	ErrorCodeBadRequest                                          ErrorCode = "BAD_REQUEST"
	ErrorCodeMissingRequiredParameter                            ErrorCode = "MISSING_REQUIRED_PARAMETER"
	ErrorCodeIncorrectType                                       ErrorCode = "INCORRECT_TYPE"
	ErrorCodeInvalidTime                                         ErrorCode = "INVALID_TIME"
	ErrorCodeInvalidTimeRange                                    ErrorCode = "INVALID_TIME_RANGE"
	ErrorCodeInvalidValue                                        ErrorCode = "INVALID_VALUE"
	ErrorCodeInvalidCursor                                       ErrorCode = "INVALID_CURSOR"
	ErrorCodeUnknownQueryParameter                               ErrorCode = "UNKNOWN_QUERY_PARAMETER"
	ErrorCodeConflictingParameters                               ErrorCode = "CONFLICTING_PARAMETERS"
	ErrorCodeExpectedJsonBody                                    ErrorCode = "EXPECTED_JSON_BODY"
	ErrorCodeInvalidSortOrder                                    ErrorCode = "INVALID_SORT_ORDER"
	ErrorCodeValueRegexMismatch                                  ErrorCode = "VALUE_REGEX_MISMATCH"
	ErrorCodeValueTooShort                                       ErrorCode = "VALUE_TOO_SHORT"
	ErrorCodeValueTooLong                                        ErrorCode = "VALUE_TOO_LONG"
	ErrorCodeValueTooLow                                         ErrorCode = "VALUE_TOO_LOW"
	ErrorCodeValueTooHigh                                        ErrorCode = "VALUE_TOO_HIGH"
	ErrorCodeValueEmpty                                          ErrorCode = "VALUE_EMPTY"
	ErrorCodeArrayLengthTooLong                                  ErrorCode = "ARRAY_LENGTH_TOO_LONG"
	ErrorCodeArrayLengthTooShort                                 ErrorCode = "ARRAY_LENGTH_TOO_SHORT"
	ErrorCodeArrayEmpty                                          ErrorCode = "ARRAY_EMPTY"
	ErrorCodeExpectedBoolean                                     ErrorCode = "EXPECTED_BOOLEAN"
	ErrorCodeExpectedInteger                                     ErrorCode = "EXPECTED_INTEGER"
	ErrorCodeExpectedFloat                                       ErrorCode = "EXPECTED_FLOAT"
	ErrorCodeExpectedString                                      ErrorCode = "EXPECTED_STRING"
	ErrorCodeExpectedObject                                      ErrorCode = "EXPECTED_OBJECT"
	ErrorCodeExpectedArray                                       ErrorCode = "EXPECTED_ARRAY"
	ErrorCodeExpectedMap                                         ErrorCode = "EXPECTED_MAP"
	ErrorCodeExpectedBase64EncodedByteArray                      ErrorCode = "EXPECTED_BASE64_ENCODED_BYTE_ARRAY"
	ErrorCodeInvalidArrayValue                                   ErrorCode = "INVALID_ARRAY_VALUE"
	ErrorCodeInvalidEnumValue                                    ErrorCode = "INVALID_ENUM_VALUE"
	ErrorCodeInvalidContentType                                  ErrorCode = "INVALID_CONTENT_TYPE"
	ErrorCodeInvalidFormValue                                    ErrorCode = "INVALID_FORM_VALUE"
	ErrorCodeCustomerNotFound                                    ErrorCode = "CUSTOMER_NOT_FOUND"
	ErrorCodeBuyerNotFound                                       ErrorCode = "BUYER_NOT_FOUND"
	ErrorCodeOneInstrumentExpected                               ErrorCode = "ONE_INSTRUMENT_EXPECTED"
	ErrorCodeNoFieldsSet                                         ErrorCode = "NO_FIELDS_SET"
	ErrorCodeDeprecatedFieldSet                                  ErrorCode = "DEPRECATED_FIELD_SET"
	ErrorCodeRetiredFieldSet                                     ErrorCode = "RETIRED_FIELD_SET"
	ErrorCodeTooManyMapEntries                                   ErrorCode = "TOO_MANY_MAP_ENTRIES"
	ErrorCodeMapKeyLengthTooShort                                ErrorCode = "MAP_KEY_LENGTH_TOO_SHORT"
	ErrorCodeMapKeyLengthTooLong                                 ErrorCode = "MAP_KEY_LENGTH_TOO_LONG"
	ErrorCodeCustomerMissingName                                 ErrorCode = "CUSTOMER_MISSING_NAME"
	ErrorCodeCustomerMissingEmail                                ErrorCode = "CUSTOMER_MISSING_EMAIL"
	ErrorCodeInvalidPauseLength                                  ErrorCode = "INVALID_PAUSE_LENGTH"
	ErrorCodeInvalidDate                                         ErrorCode = "INVALID_DATE"
	ErrorCodeJobTemplateNameTaken                                ErrorCode = "JOB_TEMPLATE_NAME_TAKEN"
	ErrorCodeClientNotSupported                                  ErrorCode = "CLIENT_NOT_SUPPORTED"
	ErrorCodeCardExpired                                         ErrorCode = "CARD_EXPIRED"
	ErrorCodeInvalidExpiration                                   ErrorCode = "INVALID_EXPIRATION"
	ErrorCodeInvalidExpirationYear                               ErrorCode = "INVALID_EXPIRATION_YEAR"
	ErrorCodeInvalidExpirationDate                               ErrorCode = "INVALID_EXPIRATION_DATE"
	ErrorCodeUnsupportedCardBrand                                ErrorCode = "UNSUPPORTED_CARD_BRAND"
	ErrorCodeUnsupportedEntryMethod                              ErrorCode = "UNSUPPORTED_ENTRY_METHOD"
	ErrorCodeInvalidEncryptedCard                                ErrorCode = "INVALID_ENCRYPTED_CARD"
	ErrorCodeInvalidCard                                         ErrorCode = "INVALID_CARD"
	ErrorCodePaymentAmountMismatch                               ErrorCode = "PAYMENT_AMOUNT_MISMATCH"
	ErrorCodeGenericDecline                                      ErrorCode = "GENERIC_DECLINE"
	ErrorCodeCvvFailure                                          ErrorCode = "CVV_FAILURE"
	ErrorCodeAddressVerificationFailure                          ErrorCode = "ADDRESS_VERIFICATION_FAILURE"
	ErrorCodeInvalidAccount                                      ErrorCode = "INVALID_ACCOUNT"
	ErrorCodeCurrencyMismatch                                    ErrorCode = "CURRENCY_MISMATCH"
	ErrorCodeInsufficientFunds                                   ErrorCode = "INSUFFICIENT_FUNDS"
	ErrorCodeInsufficientPermissions                             ErrorCode = "INSUFFICIENT_PERMISSIONS"
	ErrorCodeCardholderInsufficientPermissions                   ErrorCode = "CARDHOLDER_INSUFFICIENT_PERMISSIONS"
	ErrorCodeInvalidLocation                                     ErrorCode = "INVALID_LOCATION"
	ErrorCodeTransactionLimit                                    ErrorCode = "TRANSACTION_LIMIT"
	ErrorCodeVoiceFailure                                        ErrorCode = "VOICE_FAILURE"
	ErrorCodePanFailure                                          ErrorCode = "PAN_FAILURE"
	ErrorCodeExpirationFailure                                   ErrorCode = "EXPIRATION_FAILURE"
	ErrorCodeCardNotSupported                                    ErrorCode = "CARD_NOT_SUPPORTED"
	ErrorCodeInvalidPin                                          ErrorCode = "INVALID_PIN"
	ErrorCodeMissingPin                                          ErrorCode = "MISSING_PIN"
	ErrorCodeMissingAccountType                                  ErrorCode = "MISSING_ACCOUNT_TYPE"
	ErrorCodeInvalidPostalCode                                   ErrorCode = "INVALID_POSTAL_CODE"
	ErrorCodeInvalidFees                                         ErrorCode = "INVALID_FEES"
	ErrorCodeManuallyEnteredPaymentNotSupported                  ErrorCode = "MANUALLY_ENTERED_PAYMENT_NOT_SUPPORTED"
	ErrorCodePaymentLimitExceeded                                ErrorCode = "PAYMENT_LIMIT_EXCEEDED"
	ErrorCodeGiftCardAvailableAmount                             ErrorCode = "GIFT_CARD_AVAILABLE_AMOUNT"
	ErrorCodeGiftCardBuyerDailyLimitReached                      ErrorCode = "GIFT_CARD_BUYER_DAILY_LIMIT_REACHED"
	ErrorCodeGiftCardInvalidAmount                               ErrorCode = "GIFT_CARD_INVALID_AMOUNT"
	ErrorCodeGiftCardMaxValueReached                             ErrorCode = "GIFT_CARD_MAX_VALUE_REACHED"
	ErrorCodeGiftCardMerchantMaxOutstandingBalanceReached        ErrorCode = "GIFT_CARD_MERCHANT_MAX_OUTSTANDING_BALANCE_REACHED"
	ErrorCodeGiftCardValueAdditionLimitReached                   ErrorCode = "GIFT_CARD_VALUE_ADDITION_LIMIT_REACHED"
	ErrorCodeAccountUnusable                                     ErrorCode = "ACCOUNT_UNUSABLE"
	ErrorCodeBuyerRefusedPayment                                 ErrorCode = "BUYER_REFUSED_PAYMENT"
	ErrorCodeDelayedTransactionExpired                           ErrorCode = "DELAYED_TRANSACTION_EXPIRED"
	ErrorCodeDelayedTransactionCanceled                          ErrorCode = "DELAYED_TRANSACTION_CANCELED"
	ErrorCodeDelayedTransactionCaptured                          ErrorCode = "DELAYED_TRANSACTION_CAPTURED"
	ErrorCodeDelayedTransactionFailed                            ErrorCode = "DELAYED_TRANSACTION_FAILED"
	ErrorCodeCardTokenExpired                                    ErrorCode = "CARD_TOKEN_EXPIRED"
	ErrorCodeCardTokenUsed                                       ErrorCode = "CARD_TOKEN_USED"
	ErrorCodeAmountTooHigh                                       ErrorCode = "AMOUNT_TOO_HIGH"
	ErrorCodeUnsupportedInstrumentType                           ErrorCode = "UNSUPPORTED_INSTRUMENT_TYPE"
	ErrorCodeRefundAmountInvalid                                 ErrorCode = "REFUND_AMOUNT_INVALID"
	ErrorCodeRefundAlreadyPending                                ErrorCode = "REFUND_ALREADY_PENDING"
	ErrorCodePaymentNotRefundable                                ErrorCode = "PAYMENT_NOT_REFUNDABLE"
	ErrorCodeRefundDeclined                                      ErrorCode = "REFUND_DECLINED"
	ErrorCodeInvalidCardData                                     ErrorCode = "INVALID_CARD_DATA"
	ErrorCodeSourceUsed                                          ErrorCode = "SOURCE_USED"
	ErrorCodeSourceExpired                                       ErrorCode = "SOURCE_EXPIRED"
	ErrorCodeUnsupportedLoyaltyRewardTier                        ErrorCode = "UNSUPPORTED_LOYALTY_REWARD_TIER"
	ErrorCodeLocationMismatch                                    ErrorCode = "LOCATION_MISMATCH"
	ErrorCodeOrderExpired                                        ErrorCode = "ORDER_EXPIRED"
	ErrorCodeOrderAlreadyUsed                                    ErrorCode = "ORDER_ALREADY_USED"
	ErrorCodeOrderTooManyCatalogObjects                          ErrorCode = "ORDER_TOO_MANY_CATALOG_OBJECTS"
	ErrorCodeInsufficientInventory                               ErrorCode = "INSUFFICIENT_INVENTORY"
	ErrorCodePriceMismatch                                       ErrorCode = "PRICE_MISMATCH"
	ErrorCodeVersionMismatch                                     ErrorCode = "VERSION_MISMATCH"
	ErrorCodeIdempotencyKeyReused                                ErrorCode = "IDEMPOTENCY_KEY_REUSED"
	ErrorCodeUnexpectedValue                                     ErrorCode = "UNEXPECTED_VALUE"
	ErrorCodeSandboxNotSupported                                 ErrorCode = "SANDBOX_NOT_SUPPORTED"
	ErrorCodeInvalidEmailAddress                                 ErrorCode = "INVALID_EMAIL_ADDRESS"
	ErrorCodeInvalidPhoneNumber                                  ErrorCode = "INVALID_PHONE_NUMBER"
	ErrorCodeCheckoutExpired                                     ErrorCode = "CHECKOUT_EXPIRED"
	ErrorCodeBadCertificate                                      ErrorCode = "BAD_CERTIFICATE"
	ErrorCodeInvalidSquareVersionFormat                          ErrorCode = "INVALID_SQUARE_VERSION_FORMAT"
	ErrorCodeApiVersionIncompatible                              ErrorCode = "API_VERSION_INCOMPATIBLE"
	ErrorCodeInvalidUrl                                          ErrorCode = "INVALID_URL"
	ErrorCodeHttpsOnly                                           ErrorCode = "HTTPS_ONLY"
	ErrorCodeUnreachableUrl                                      ErrorCode = "UNREACHABLE_URL"
	ErrorCodeSessionExpired                                      ErrorCode = "SESSION_EXPIRED"
	ErrorCodeInvalidVerificationCode                             ErrorCode = "INVALID_VERIFICATION_CODE"
	ErrorCodeCardDeclined                                        ErrorCode = "CARD_DECLINED"
	ErrorCodeVerifyCvvFailure                                    ErrorCode = "VERIFY_CVV_FAILURE"
	ErrorCodeVerifyAvsFailure                                    ErrorCode = "VERIFY_AVS_FAILURE"
	ErrorCodeCardDeclinedCallIssuer                              ErrorCode = "CARD_DECLINED_CALL_ISSUER"
	ErrorCodeCardDeclinedVerificationRequired                    ErrorCode = "CARD_DECLINED_VERIFICATION_REQUIRED"
	ErrorCodeBadExpiration                                       ErrorCode = "BAD_EXPIRATION"
	ErrorCodeChipInsertionRequired                               ErrorCode = "CHIP_INSERTION_REQUIRED"
	ErrorCodeAllowablePinTriesExceeded                           ErrorCode = "ALLOWABLE_PIN_TRIES_EXCEEDED"
	ErrorCodeReservationDeclined                                 ErrorCode = "RESERVATION_DECLINED"
	ErrorCodeBlockedByBlocklist                                  ErrorCode = "BLOCKED_BY_BLOCKLIST"
	ErrorCodeFulfillmentPreferencesRestrictedDateNotUnique       ErrorCode = "FULFILLMENT_PREFERENCES_RESTRICTED_DATE_NOT_UNIQUE"
	ErrorCodeFulfillmentPreferencesInvalidSchedulingDatetime     ErrorCode = "FULFILLMENT_PREFERENCES_INVALID_SCHEDULING_DATETIME"
	ErrorCodeFulfillmentPreferencesFulfillmentScheduleNotAllowed ErrorCode = "FULFILLMENT_PREFERENCES_FULFILLMENT_SCHEDULE_NOT_ALLOWED"
	ErrorCodeFulfillmentPreferencesAssignmentIsImmutable         ErrorCode = "FULFILLMENT_PREFERENCES_ASSIGNMENT_IS_IMMUTABLE"
	ErrorCodeInvalidTimezone                                     ErrorCode = "INVALID_TIMEZONE"
	ErrorCodeUnknownBodyParameter                                ErrorCode = "UNKNOWN_BODY_PARAMETER"
	ErrorCodeFulfillmentPreferencesConflictingAssignmentType     ErrorCode = "FULFILLMENT_PREFERENCES_CONFLICTING_ASSIGNMENT_TYPE"
	ErrorCodeNotFound                                            ErrorCode = "NOT_FOUND"
	ErrorCodeApplePaymentProcessingCertificateHashNotFound       ErrorCode = "APPLE_PAYMENT_PROCESSING_CERTIFICATE_HASH_NOT_FOUND"
	ErrorCodeMethodNotAllowed                                    ErrorCode = "METHOD_NOT_ALLOWED"
	ErrorCodeNotAcceptable                                       ErrorCode = "NOT_ACCEPTABLE"
	ErrorCodeRequestTimeout                                      ErrorCode = "REQUEST_TIMEOUT"
	ErrorCodeConflict                                            ErrorCode = "CONFLICT"
	ErrorCodeGone                                                ErrorCode = "GONE"
	ErrorCodeRequestEntityTooLarge                               ErrorCode = "REQUEST_ENTITY_TOO_LARGE"
	ErrorCodeUnsupportedMediaType                                ErrorCode = "UNSUPPORTED_MEDIA_TYPE"
	ErrorCodeUnprocessableEntity                                 ErrorCode = "UNPROCESSABLE_ENTITY"
	ErrorCodeRateLimited                                         ErrorCode = "RATE_LIMITED"
	ErrorCodeClientClosedRequest                                 ErrorCode = "CLIENT_CLOSED_REQUEST"
	ErrorCodeNotImplemented                                      ErrorCode = "NOT_IMPLEMENTED"
	ErrorCodeBadGateway                                          ErrorCode = "BAD_GATEWAY"
	ErrorCodeServiceUnavailable                                  ErrorCode = "SERVICE_UNAVAILABLE"
	ErrorCodeTemporaryError                                      ErrorCode = "TEMPORARY_ERROR"
	ErrorCodeGatewayTimeout                                      ErrorCode = "GATEWAY_TIMEOUT"
)

func NewErrorCodeFromString(s string) (ErrorCode, error) {
	switch s {
	case "INTERNAL_SERVER_ERROR":
		return ErrorCodeInternalServerError, nil
	case "UNAUTHORIZED":
		return ErrorCodeUnauthorized, nil
	case "ACCESS_TOKEN_EXPIRED":
		return ErrorCodeAccessTokenExpired, nil
	case "ACCESS_TOKEN_REVOKED":
		return ErrorCodeAccessTokenRevoked, nil
	case "CLIENT_DISABLED":
		return ErrorCodeClientDisabled, nil
	case "FORBIDDEN":
		return ErrorCodeForbidden, nil
	case "INSUFFICIENT_SCOPES":
		return ErrorCodeInsufficientScopes, nil
	case "APPLICATION_DISABLED":
		return ErrorCodeApplicationDisabled, nil
	case "V1_APPLICATION":
		return ErrorCodeV1Application, nil
	case "V1_ACCESS_TOKEN":
		return ErrorCodeV1AccessToken, nil
	case "CARD_PROCESSING_NOT_ENABLED":
		return ErrorCodeCardProcessingNotEnabled, nil
	case "MERCHANT_SUBSCRIPTION_NOT_FOUND":
		return ErrorCodeMerchantSubscriptionNotFound, nil
	case "BAD_REQUEST":
		return ErrorCodeBadRequest, nil
	case "MISSING_REQUIRED_PARAMETER":
		return ErrorCodeMissingRequiredParameter, nil
	case "INCORRECT_TYPE":
		return ErrorCodeIncorrectType, nil
	case "INVALID_TIME":
		return ErrorCodeInvalidTime, nil
	case "INVALID_TIME_RANGE":
		return ErrorCodeInvalidTimeRange, nil
	case "INVALID_VALUE":
		return ErrorCodeInvalidValue, nil
	case "INVALID_CURSOR":
		return ErrorCodeInvalidCursor, nil
	case "UNKNOWN_QUERY_PARAMETER":
		return ErrorCodeUnknownQueryParameter, nil
	case "CONFLICTING_PARAMETERS":
		return ErrorCodeConflictingParameters, nil
	case "EXPECTED_JSON_BODY":
		return ErrorCodeExpectedJsonBody, nil
	case "INVALID_SORT_ORDER":
		return ErrorCodeInvalidSortOrder, nil
	case "VALUE_REGEX_MISMATCH":
		return ErrorCodeValueRegexMismatch, nil
	case "VALUE_TOO_SHORT":
		return ErrorCodeValueTooShort, nil
	case "VALUE_TOO_LONG":
		return ErrorCodeValueTooLong, nil
	case "VALUE_TOO_LOW":
		return ErrorCodeValueTooLow, nil
	case "VALUE_TOO_HIGH":
		return ErrorCodeValueTooHigh, nil
	case "VALUE_EMPTY":
		return ErrorCodeValueEmpty, nil
	case "ARRAY_LENGTH_TOO_LONG":
		return ErrorCodeArrayLengthTooLong, nil
	case "ARRAY_LENGTH_TOO_SHORT":
		return ErrorCodeArrayLengthTooShort, nil
	case "ARRAY_EMPTY":
		return ErrorCodeArrayEmpty, nil
	case "EXPECTED_BOOLEAN":
		return ErrorCodeExpectedBoolean, nil
	case "EXPECTED_INTEGER":
		return ErrorCodeExpectedInteger, nil
	case "EXPECTED_FLOAT":
		return ErrorCodeExpectedFloat, nil
	case "EXPECTED_STRING":
		return ErrorCodeExpectedString, nil
	case "EXPECTED_OBJECT":
		return ErrorCodeExpectedObject, nil
	case "EXPECTED_ARRAY":
		return ErrorCodeExpectedArray, nil
	case "EXPECTED_MAP":
		return ErrorCodeExpectedMap, nil
	case "EXPECTED_BASE64_ENCODED_BYTE_ARRAY":
		return ErrorCodeExpectedBase64EncodedByteArray, nil
	case "INVALID_ARRAY_VALUE":
		return ErrorCodeInvalidArrayValue, nil
	case "INVALID_ENUM_VALUE":
		return ErrorCodeInvalidEnumValue, nil
	case "INVALID_CONTENT_TYPE":
		return ErrorCodeInvalidContentType, nil
	case "INVALID_FORM_VALUE":
		return ErrorCodeInvalidFormValue, nil
	case "CUSTOMER_NOT_FOUND":
		return ErrorCodeCustomerNotFound, nil
	case "BUYER_NOT_FOUND":
		return ErrorCodeBuyerNotFound, nil
	case "ONE_INSTRUMENT_EXPECTED":
		return ErrorCodeOneInstrumentExpected, nil
	case "NO_FIELDS_SET":
		return ErrorCodeNoFieldsSet, nil
	case "DEPRECATED_FIELD_SET":
		return ErrorCodeDeprecatedFieldSet, nil
	case "RETIRED_FIELD_SET":
		return ErrorCodeRetiredFieldSet, nil
	case "TOO_MANY_MAP_ENTRIES":
		return ErrorCodeTooManyMapEntries, nil
	case "MAP_KEY_LENGTH_TOO_SHORT":
		return ErrorCodeMapKeyLengthTooShort, nil
	case "MAP_KEY_LENGTH_TOO_LONG":
		return ErrorCodeMapKeyLengthTooLong, nil
	case "CUSTOMER_MISSING_NAME":
		return ErrorCodeCustomerMissingName, nil
	case "CUSTOMER_MISSING_EMAIL":
		return ErrorCodeCustomerMissingEmail, nil
	case "INVALID_PAUSE_LENGTH":
		return ErrorCodeInvalidPauseLength, nil
	case "INVALID_DATE":
		return ErrorCodeInvalidDate, nil
	case "JOB_TEMPLATE_NAME_TAKEN":
		return ErrorCodeJobTemplateNameTaken, nil
	case "CLIENT_NOT_SUPPORTED":
		return ErrorCodeClientNotSupported, nil
	case "CARD_EXPIRED":
		return ErrorCodeCardExpired, nil
	case "INVALID_EXPIRATION":
		return ErrorCodeInvalidExpiration, nil
	case "INVALID_EXPIRATION_YEAR":
		return ErrorCodeInvalidExpirationYear, nil
	case "INVALID_EXPIRATION_DATE":
		return ErrorCodeInvalidExpirationDate, nil
	case "UNSUPPORTED_CARD_BRAND":
		return ErrorCodeUnsupportedCardBrand, nil
	case "UNSUPPORTED_ENTRY_METHOD":
		return ErrorCodeUnsupportedEntryMethod, nil
	case "INVALID_ENCRYPTED_CARD":
		return ErrorCodeInvalidEncryptedCard, nil
	case "INVALID_CARD":
		return ErrorCodeInvalidCard, nil
	case "PAYMENT_AMOUNT_MISMATCH":
		return ErrorCodePaymentAmountMismatch, nil
	case "GENERIC_DECLINE":
		return ErrorCodeGenericDecline, nil
	case "CVV_FAILURE":
		return ErrorCodeCvvFailure, nil
	case "ADDRESS_VERIFICATION_FAILURE":
		return ErrorCodeAddressVerificationFailure, nil
	case "INVALID_ACCOUNT":
		return ErrorCodeInvalidAccount, nil
	case "CURRENCY_MISMATCH":
		return ErrorCodeCurrencyMismatch, nil
	case "INSUFFICIENT_FUNDS":
		return ErrorCodeInsufficientFunds, nil
	case "INSUFFICIENT_PERMISSIONS":
		return ErrorCodeInsufficientPermissions, nil
	case "CARDHOLDER_INSUFFICIENT_PERMISSIONS":
		return ErrorCodeCardholderInsufficientPermissions, nil
	case "INVALID_LOCATION":
		return ErrorCodeInvalidLocation, nil
	case "TRANSACTION_LIMIT":
		return ErrorCodeTransactionLimit, nil
	case "VOICE_FAILURE":
		return ErrorCodeVoiceFailure, nil
	case "PAN_FAILURE":
		return ErrorCodePanFailure, nil
	case "EXPIRATION_FAILURE":
		return ErrorCodeExpirationFailure, nil
	case "CARD_NOT_SUPPORTED":
		return ErrorCodeCardNotSupported, nil
	case "INVALID_PIN":
		return ErrorCodeInvalidPin, nil
	case "MISSING_PIN":
		return ErrorCodeMissingPin, nil
	case "MISSING_ACCOUNT_TYPE":
		return ErrorCodeMissingAccountType, nil
	case "INVALID_POSTAL_CODE":
		return ErrorCodeInvalidPostalCode, nil
	case "INVALID_FEES":
		return ErrorCodeInvalidFees, nil
	case "MANUALLY_ENTERED_PAYMENT_NOT_SUPPORTED":
		return ErrorCodeManuallyEnteredPaymentNotSupported, nil
	case "PAYMENT_LIMIT_EXCEEDED":
		return ErrorCodePaymentLimitExceeded, nil
	case "GIFT_CARD_AVAILABLE_AMOUNT":
		return ErrorCodeGiftCardAvailableAmount, nil
	case "GIFT_CARD_BUYER_DAILY_LIMIT_REACHED":
		return ErrorCodeGiftCardBuyerDailyLimitReached, nil
	case "GIFT_CARD_INVALID_AMOUNT":
		return ErrorCodeGiftCardInvalidAmount, nil
	case "GIFT_CARD_MAX_VALUE_REACHED":
		return ErrorCodeGiftCardMaxValueReached, nil
	case "GIFT_CARD_MERCHANT_MAX_OUTSTANDING_BALANCE_REACHED":
		return ErrorCodeGiftCardMerchantMaxOutstandingBalanceReached, nil
	case "GIFT_CARD_VALUE_ADDITION_LIMIT_REACHED":
		return ErrorCodeGiftCardValueAdditionLimitReached, nil
	case "ACCOUNT_UNUSABLE":
		return ErrorCodeAccountUnusable, nil
	case "BUYER_REFUSED_PAYMENT":
		return ErrorCodeBuyerRefusedPayment, nil
	case "DELAYED_TRANSACTION_EXPIRED":
		return ErrorCodeDelayedTransactionExpired, nil
	case "DELAYED_TRANSACTION_CANCELED":
		return ErrorCodeDelayedTransactionCanceled, nil
	case "DELAYED_TRANSACTION_CAPTURED":
		return ErrorCodeDelayedTransactionCaptured, nil
	case "DELAYED_TRANSACTION_FAILED":
		return ErrorCodeDelayedTransactionFailed, nil
	case "CARD_TOKEN_EXPIRED":
		return ErrorCodeCardTokenExpired, nil
	case "CARD_TOKEN_USED":
		return ErrorCodeCardTokenUsed, nil
	case "AMOUNT_TOO_HIGH":
		return ErrorCodeAmountTooHigh, nil
	case "UNSUPPORTED_INSTRUMENT_TYPE":
		return ErrorCodeUnsupportedInstrumentType, nil
	case "REFUND_AMOUNT_INVALID":
		return ErrorCodeRefundAmountInvalid, nil
	case "REFUND_ALREADY_PENDING":
		return ErrorCodeRefundAlreadyPending, nil
	case "PAYMENT_NOT_REFUNDABLE":
		return ErrorCodePaymentNotRefundable, nil
	case "REFUND_DECLINED":
		return ErrorCodeRefundDeclined, nil
	case "INVALID_CARD_DATA":
		return ErrorCodeInvalidCardData, nil
	case "SOURCE_USED":
		return ErrorCodeSourceUsed, nil
	case "SOURCE_EXPIRED":
		return ErrorCodeSourceExpired, nil
	case "UNSUPPORTED_LOYALTY_REWARD_TIER":
		return ErrorCodeUnsupportedLoyaltyRewardTier, nil
	case "LOCATION_MISMATCH":
		return ErrorCodeLocationMismatch, nil
	case "ORDER_EXPIRED":
		return ErrorCodeOrderExpired, nil
	case "ORDER_ALREADY_USED":
		return ErrorCodeOrderAlreadyUsed, nil
	case "ORDER_TOO_MANY_CATALOG_OBJECTS":
		return ErrorCodeOrderTooManyCatalogObjects, nil
	case "INSUFFICIENT_INVENTORY":
		return ErrorCodeInsufficientInventory, nil
	case "PRICE_MISMATCH":
		return ErrorCodePriceMismatch, nil
	case "VERSION_MISMATCH":
		return ErrorCodeVersionMismatch, nil
	case "IDEMPOTENCY_KEY_REUSED":
		return ErrorCodeIdempotencyKeyReused, nil
	case "UNEXPECTED_VALUE":
		return ErrorCodeUnexpectedValue, nil
	case "SANDBOX_NOT_SUPPORTED":
		return ErrorCodeSandboxNotSupported, nil
	case "INVALID_EMAIL_ADDRESS":
		return ErrorCodeInvalidEmailAddress, nil
	case "INVALID_PHONE_NUMBER":
		return ErrorCodeInvalidPhoneNumber, nil
	case "CHECKOUT_EXPIRED":
		return ErrorCodeCheckoutExpired, nil
	case "BAD_CERTIFICATE":
		return ErrorCodeBadCertificate, nil
	case "INVALID_SQUARE_VERSION_FORMAT":
		return ErrorCodeInvalidSquareVersionFormat, nil
	case "API_VERSION_INCOMPATIBLE":
		return ErrorCodeApiVersionIncompatible, nil
	case "INVALID_URL":
		return ErrorCodeInvalidUrl, nil
	case "HTTPS_ONLY":
		return ErrorCodeHttpsOnly, nil
	case "UNREACHABLE_URL":
		return ErrorCodeUnreachableUrl, nil
	case "SESSION_EXPIRED":
		return ErrorCodeSessionExpired, nil
	case "INVALID_VERIFICATION_CODE":
		return ErrorCodeInvalidVerificationCode, nil
	case "CARD_DECLINED":
		return ErrorCodeCardDeclined, nil
	case "VERIFY_CVV_FAILURE":
		return ErrorCodeVerifyCvvFailure, nil
	case "VERIFY_AVS_FAILURE":
		return ErrorCodeVerifyAvsFailure, nil
	case "CARD_DECLINED_CALL_ISSUER":
		return ErrorCodeCardDeclinedCallIssuer, nil
	case "CARD_DECLINED_VERIFICATION_REQUIRED":
		return ErrorCodeCardDeclinedVerificationRequired, nil
	case "BAD_EXPIRATION":
		return ErrorCodeBadExpiration, nil
	case "CHIP_INSERTION_REQUIRED":
		return ErrorCodeChipInsertionRequired, nil
	case "ALLOWABLE_PIN_TRIES_EXCEEDED":
		return ErrorCodeAllowablePinTriesExceeded, nil
	case "RESERVATION_DECLINED":
		return ErrorCodeReservationDeclined, nil
	case "BLOCKED_BY_BLOCKLIST":
		return ErrorCodeBlockedByBlocklist, nil
	case "FULFILLMENT_PREFERENCES_RESTRICTED_DATE_NOT_UNIQUE":
		return ErrorCodeFulfillmentPreferencesRestrictedDateNotUnique, nil
	case "FULFILLMENT_PREFERENCES_INVALID_SCHEDULING_DATETIME":
		return ErrorCodeFulfillmentPreferencesInvalidSchedulingDatetime, nil
	case "FULFILLMENT_PREFERENCES_FULFILLMENT_SCHEDULE_NOT_ALLOWED":
		return ErrorCodeFulfillmentPreferencesFulfillmentScheduleNotAllowed, nil
	case "FULFILLMENT_PREFERENCES_ASSIGNMENT_IS_IMMUTABLE":
		return ErrorCodeFulfillmentPreferencesAssignmentIsImmutable, nil
	case "INVALID_TIMEZONE":
		return ErrorCodeInvalidTimezone, nil
	case "UNKNOWN_BODY_PARAMETER":
		return ErrorCodeUnknownBodyParameter, nil
	case "FULFILLMENT_PREFERENCES_CONFLICTING_ASSIGNMENT_TYPE":
		return ErrorCodeFulfillmentPreferencesConflictingAssignmentType, nil
	case "NOT_FOUND":
		return ErrorCodeNotFound, nil
	case "APPLE_PAYMENT_PROCESSING_CERTIFICATE_HASH_NOT_FOUND":
		return ErrorCodeApplePaymentProcessingCertificateHashNotFound, nil
	case "METHOD_NOT_ALLOWED":
		return ErrorCodeMethodNotAllowed, nil
	case "NOT_ACCEPTABLE":
		return ErrorCodeNotAcceptable, nil
	case "REQUEST_TIMEOUT":
		return ErrorCodeRequestTimeout, nil
	case "CONFLICT":
		return ErrorCodeConflict, nil
	case "GONE":
		return ErrorCodeGone, nil
	case "REQUEST_ENTITY_TOO_LARGE":
		return ErrorCodeRequestEntityTooLarge, nil
	case "UNSUPPORTED_MEDIA_TYPE":
		return ErrorCodeUnsupportedMediaType, nil
	case "UNPROCESSABLE_ENTITY":
		return ErrorCodeUnprocessableEntity, nil
	case "RATE_LIMITED":
		return ErrorCodeRateLimited, nil
	case "CLIENT_CLOSED_REQUEST":
		return ErrorCodeClientClosedRequest, nil
	case "NOT_IMPLEMENTED":
		return ErrorCodeNotImplemented, nil
	case "BAD_GATEWAY":
		return ErrorCodeBadGateway, nil
	case "SERVICE_UNAVAILABLE":
		return ErrorCodeServiceUnavailable, nil
	case "TEMPORARY_ERROR":
		return ErrorCodeTemporaryError, nil
	case "GATEWAY_TIMEOUT":
		return ErrorCodeGatewayTimeout, nil
	}
	var t ErrorCode
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (e ErrorCode) Ptr() *ErrorCode {
	return &e
}

// Contains the metadata of a webhook event type.
type EventTypeMetadata struct {
	// The event type.
	EventType *string `json:"event_type,omitempty" url:"event_type,omitempty"`
	// The API version at which the event type was introduced.
	ApiVersionIntroduced *string `json:"api_version_introduced,omitempty" url:"api_version_introduced,omitempty"`
	// The release status of the event type.
	ReleaseStatus *string `json:"release_status,omitempty" url:"release_status,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (e *EventTypeMetadata) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EventTypeMetadata) UnmarshalJSON(data []byte) error {
	type unmarshaler EventTypeMetadata
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EventTypeMetadata(value)

	extraProperties, err := core.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties

	e._rawJSON = json.RawMessage(data)
	return nil
}

func (e *EventTypeMetadata) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

// Indicates which products matched by a CatalogPricingRule
// will be excluded if the pricing rule uses an exclude set.
type ExcludeStrategy string

const (
	ExcludeStrategyExcludeStrategyDoNotUse ExcludeStrategy = "EXCLUDE_STRATEGY_DO_NOT_USE"
	ExcludeStrategyLeastExpensive          ExcludeStrategy = "LEAST_EXPENSIVE"
	ExcludeStrategyMostExpensive           ExcludeStrategy = "MOST_EXPENSIVE"
)

func NewExcludeStrategyFromString(s string) (ExcludeStrategy, error) {
	switch s {
	case "EXCLUDE_STRATEGY_DO_NOT_USE":
		return ExcludeStrategyExcludeStrategyDoNotUse, nil
	case "LEAST_EXPENSIVE":
		return ExcludeStrategyLeastExpensive, nil
	case "MOST_EXPENSIVE":
		return ExcludeStrategyMostExpensive, nil
	}
	var t ExcludeStrategy
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (e ExcludeStrategy) Ptr() *ExcludeStrategy {
	return &e
}

// A filter to select resources based on an exact field value. For any given
// value, the value can only be in one property. Depending on the field, either
// all properties can be set or only a subset will be available.
//
// Refer to the documentation of the field.
type FilterValue struct {
	// A list of terms that must be present on the field of the resource.
	All []string `json:"all,omitempty" url:"all,omitempty"`
	// A list of terms where at least one of them must be present on the
	// field of the resource.
	Any []string `json:"any,omitempty" url:"any,omitempty"`
	// A list of terms that must not be present on the field the resource
	None []string `json:"none,omitempty" url:"none,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (f *FilterValue) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FilterValue) UnmarshalJSON(data []byte) error {
	type unmarshaler FilterValue
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FilterValue(value)

	extraProperties, err := core.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties

	f._rawJSON = json.RawMessage(data)
	return nil
}

func (f *FilterValue) String() string {
	if len(f._rawJSON) > 0 {
		if value, err := core.StringifyJSON(f._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

// Specifies a decimal number range.
type FloatNumberRange struct {
	// A decimal value indicating where the range starts.
	StartAt *string `json:"start_at,omitempty" url:"start_at,omitempty"`
	// A decimal value indicating where the range ends.
	EndAt *string `json:"end_at,omitempty" url:"end_at,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (f *FloatNumberRange) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FloatNumberRange) UnmarshalJSON(data []byte) error {
	type unmarshaler FloatNumberRange
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FloatNumberRange(value)

	extraProperties, err := core.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties

	f._rawJSON = json.RawMessage(data)
	return nil
}

func (f *FloatNumberRange) String() string {
	if len(f._rawJSON) > 0 {
		if value, err := core.StringifyJSON(f._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

// Request object for fetching a specific `BankAccount`
// by the object ID.
type GetBankAccountByV1IdRequest struct {
	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GetBankAccountByV1IdRequest) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetBankAccountByV1IdRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler GetBankAccountByV1IdRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetBankAccountByV1IdRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetBankAccountByV1IdRequest) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// Request object to fetch a specific `BankAccount`
// by the object ID.
type GetBankAccountRequest struct {
	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GetBankAccountRequest) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetBankAccountRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler GetBankAccountRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetBankAccountRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetBankAccountRequest) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetBookingRequest struct {
	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GetBookingRequest) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetBookingRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler GetBookingRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetBookingRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetBookingRequest) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// A request to get a `BreakType` by ID.
type GetBreakTypeRequest struct {
	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GetBreakTypeRequest) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetBreakTypeRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler GetBreakTypeRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetBreakTypeRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetBreakTypeRequest) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// The response to a request to get a `BreakType`. The response contains
// the requested `BreakType` objects and might contain a set of `Error` objects if
// the request resulted in errors.
type GetBreakTypeResponse struct {
	// The response object.
	BreakType *BreakType `json:"break_type,omitempty" url:"break_type,omitempty"`
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GetBreakTypeResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetBreakTypeResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetBreakTypeResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetBreakTypeResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetBreakTypeResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetBusinessBookingProfileRequest struct {
	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GetBusinessBookingProfileRequest) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetBusinessBookingProfileRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler GetBusinessBookingProfileRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetBusinessBookingProfileRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetBusinessBookingProfileRequest) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// Retrieves details for a specific Card. Accessible via
// HTTP requests at GET https://connect.squareup.com/v2/cards/{card_id}
type GetCardRequest struct {
	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GetCardRequest) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetCardRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler GetCardRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetCardRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetCardRequest) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetCashDrawerShiftResponse struct {
	// The cash drawer shift queried for.
	CashDrawerShift *CashDrawerShift `json:"cash_drawer_shift,omitempty" url:"cash_drawer_shift,omitempty"`
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GetCashDrawerShiftResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetCashDrawerShiftResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetCashDrawerShiftResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetCashDrawerShiftResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetCashDrawerShiftResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetCatalogObjectResponse struct {
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The `CatalogObject`s returned.
	Object *CatalogObject `json:"object,omitempty" url:"object,omitempty"`
	// A list of `CatalogObject`s referenced by the object in the `object` field.
	RelatedObjects []*CatalogObject `json:"related_objects,omitempty" url:"related_objects,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GetCatalogObjectResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetCatalogObjectResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetCatalogObjectResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetCatalogObjectResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetCatalogObjectResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// Represents a [RetrieveCustomerCustomAttribute](api-endpoint:CustomerCustomAttributes-RetrieveCustomerCustomAttribute) response.
// Either `custom_attribute_definition` or `errors` is present in the response.
type GetCustomerCustomAttributeResponse struct {
	// The retrieved custom attribute. If `with_definition` was set to `true` in the request,
	// the custom attribute definition is returned in the `definition` field.
	CustomAttribute *CustomAttribute `json:"custom_attribute,omitempty" url:"custom_attribute,omitempty"`
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GetCustomerCustomAttributeResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetCustomerCustomAttributeResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetCustomerCustomAttributeResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetCustomerCustomAttributeResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetCustomerCustomAttributeResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// Defines the fields that can be included in a request to the
// [RetrieveCustomerGroup](api-endpoint:CustomerGroups-RetrieveCustomerGroup) endpoint.
type GetCustomerGroupRequest struct {
	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GetCustomerGroupRequest) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetCustomerGroupRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler GetCustomerGroupRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetCustomerGroupRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetCustomerGroupRequest) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// Defines the fields that are included in the response body of
// a request to the [RetrieveCustomerGroup](api-endpoint:CustomerGroups-RetrieveCustomerGroup) endpoint.
//
// Either `errors` or `group` is present in a given response (never both).
type GetCustomerGroupResponse struct {
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The retrieved customer group.
	Group *CustomerGroup `json:"group,omitempty" url:"group,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GetCustomerGroupResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetCustomerGroupResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetCustomerGroupResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetCustomerGroupResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetCustomerGroupResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// Defines the fields that are included in requests to the `RetrieveCustomer`
// endpoint.
type GetCustomerRequest struct {
	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GetCustomerRequest) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetCustomerRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler GetCustomerRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetCustomerRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetCustomerRequest) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// Defines the valid parameters for requests to the `RetrieveCustomerSegmentRequest` endpoint.
type GetCustomerSegmentRequest struct {
	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GetCustomerSegmentRequest) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetCustomerSegmentRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler GetCustomerSegmentRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetCustomerSegmentRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetCustomerSegmentRequest) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// Defines the fields that are included in the response body for requests to the `RetrieveCustomerSegment` endpoint.
//
// Either `errors` or `segment` is present in a given response (never both).
type GetCustomerSegmentResponse struct {
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The retrieved customer segment.
	Segment *CustomerSegment `json:"segment,omitempty" url:"segment,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GetCustomerSegmentResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetCustomerSegmentResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetCustomerSegmentResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetCustomerSegmentResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetCustomerSegmentResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetDeviceCodeRequest struct {
	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GetDeviceCodeRequest) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetDeviceCodeRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler GetDeviceCodeRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetDeviceCodeRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetDeviceCodeRequest) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetDeviceCodeResponse struct {
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The queried DeviceCode.
	DeviceCode *DeviceCode `json:"device_code,omitempty" url:"device_code,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GetDeviceCodeResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetDeviceCodeResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetDeviceCodeResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetDeviceCodeResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetDeviceCodeResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// Defines the parameters for a `RetrieveDisputeEvidence` request.
type GetDisputeEvidenceRequest struct {
	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GetDisputeEvidenceRequest) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetDisputeEvidenceRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler GetDisputeEvidenceRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetDisputeEvidenceRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetDisputeEvidenceRequest) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// Defines the fields in a `RetrieveDisputeEvidence` response.
type GetDisputeEvidenceResponse struct {
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// Metadata about the dispute evidence file.
	Evidence *DisputeEvidence `json:"evidence,omitempty" url:"evidence,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GetDisputeEvidenceResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetDisputeEvidenceResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetDisputeEvidenceResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetDisputeEvidenceResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetDisputeEvidenceResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// Defines the request parameters for the `RetrieveDispute` endpoint.
type GetDisputeRequest struct {
	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GetDisputeRequest) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetDisputeRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler GetDisputeRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetDisputeRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetDisputeRequest) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetEmployeeRequest struct {
	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GetEmployeeRequest) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetEmployeeRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler GetEmployeeRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetEmployeeRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetEmployeeRequest) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// A request to get an `EmployeeWage`.
type GetEmployeeWageRequest struct {
	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GetEmployeeWageRequest) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetEmployeeWageRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler GetEmployeeWageRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetEmployeeWageRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetEmployeeWageRequest) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// A response to a request to get an `EmployeeWage`. The response contains
// the requested `EmployeeWage` objects and might contain a set of `Error` objects if
// the request resulted in errors.
type GetEmployeeWageResponse struct {
	// The requested `EmployeeWage` object.
	EmployeeWage *EmployeeWage `json:"employee_wage,omitempty" url:"employee_wage,omitempty"`
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GetEmployeeWageResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetEmployeeWageResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetEmployeeWageResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetEmployeeWageResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetEmployeeWageResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// A request to retrieve digital gift cards.
type GetGiftCardRequest struct {
	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GetGiftCardRequest) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetGiftCardRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler GetGiftCardRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetGiftCardRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetGiftCardRequest) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetInventoryAdjustmentRequest struct {
	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GetInventoryAdjustmentRequest) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetInventoryAdjustmentRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler GetInventoryAdjustmentRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetInventoryAdjustmentRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetInventoryAdjustmentRequest) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetInventoryPhysicalCountRequest struct {
	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GetInventoryPhysicalCountRequest) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetInventoryPhysicalCountRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler GetInventoryPhysicalCountRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetInventoryPhysicalCountRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetInventoryPhysicalCountRequest) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetInventoryTransferRequest struct {
	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GetInventoryTransferRequest) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetInventoryTransferRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler GetInventoryTransferRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetInventoryTransferRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetInventoryTransferRequest) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// Describes a `GetInvoice` request.
type GetInvoiceRequest struct {
	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GetInvoiceRequest) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetInvoiceRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler GetInvoiceRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetInvoiceRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetInvoiceRequest) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// Defines the fields that are included in the request body for the
// [RetrieveLocation](api-endpoint:Locations-RetrieveLocation) endpoint.
type GetLocationRequest struct {
	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GetLocationRequest) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetLocationRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler GetLocationRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetLocationRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetLocationRequest) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// A request to retrieve a loyalty account.
type GetLoyaltyAccountRequest struct {
	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GetLoyaltyAccountRequest) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetLoyaltyAccountRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler GetLoyaltyAccountRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetLoyaltyAccountRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetLoyaltyAccountRequest) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// A response that includes the loyalty account.
type GetLoyaltyAccountResponse struct {
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The loyalty account.
	LoyaltyAccount *LoyaltyAccount `json:"loyalty_account,omitempty" url:"loyalty_account,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GetLoyaltyAccountResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetLoyaltyAccountResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetLoyaltyAccountResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetLoyaltyAccountResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetLoyaltyAccountResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// A request to retrieve the [loyalty program](entity:LoyaltyProgram) that belongs to a seller. A seller can have only one loyalty program.
type GetLoyaltyProgramRequest struct {
	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GetLoyaltyProgramRequest) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetLoyaltyProgramRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler GetLoyaltyProgramRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetLoyaltyProgramRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetLoyaltyProgramRequest) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// A response that contains the loyalty program.
type GetLoyaltyProgramResponse struct {
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The loyalty program that was requested.
	Program *LoyaltyProgram `json:"program,omitempty" url:"program,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GetLoyaltyProgramResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetLoyaltyProgramResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetLoyaltyProgramResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetLoyaltyProgramResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetLoyaltyProgramResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// Represents a [RetrieveLoyaltyPromotionPromotions](api-endpoint:Loyalty-RetrieveLoyaltyPromotion) request.
type GetLoyaltyPromotionRequest struct {
	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GetLoyaltyPromotionRequest) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetLoyaltyPromotionRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler GetLoyaltyPromotionRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetLoyaltyPromotionRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetLoyaltyPromotionRequest) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// Represents a [RetrieveLoyaltyPromotionPromotions](api-endpoint:Loyalty-RetrieveLoyaltyPromotion) response.
type GetLoyaltyPromotionResponse struct {
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The retrieved loyalty promotion.
	LoyaltyPromotion *LoyaltyPromotion `json:"loyalty_promotion,omitempty" url:"loyalty_promotion,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GetLoyaltyPromotionResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetLoyaltyPromotionResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetLoyaltyPromotionResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetLoyaltyPromotionResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetLoyaltyPromotionResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// A request to retrieve a loyalty reward.
type GetLoyaltyRewardRequest struct {
	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GetLoyaltyRewardRequest) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetLoyaltyRewardRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler GetLoyaltyRewardRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetLoyaltyRewardRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetLoyaltyRewardRequest) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// A response that includes the loyalty reward.
type GetLoyaltyRewardResponse struct {
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The loyalty reward retrieved.
	Reward *LoyaltyReward `json:"reward,omitempty" url:"reward,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GetLoyaltyRewardResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetLoyaltyRewardResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetLoyaltyRewardResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetLoyaltyRewardResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetLoyaltyRewardResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// Request object for the [RetrieveMerchant](api-endpoint:Merchants-RetrieveMerchant) endpoint.
type GetMerchantRequest struct {
	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GetMerchantRequest) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetMerchantRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler GetMerchantRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetMerchantRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetMerchantRequest) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetOrderRequest struct {
	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GetOrderRequest) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetOrderRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler GetOrderRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetOrderRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetOrderRequest) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetPaymentLinkRequest struct {
	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GetPaymentLinkRequest) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetPaymentLinkRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler GetPaymentLinkRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetPaymentLinkRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetPaymentLinkRequest) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetPaymentLinkResponse struct {
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The payment link that is retrieved.
	PaymentLink *PaymentLink `json:"payment_link,omitempty" url:"payment_link,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GetPaymentLinkResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetPaymentLinkResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetPaymentLinkResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetPaymentLinkResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetPaymentLinkResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// Describes a request to retrieve a refund using
// [GetPaymentRefund](api-endpoint:Refunds-GetPaymentRefund).
type GetPaymentRefundRequest struct {
	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GetPaymentRefundRequest) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetPaymentRefundRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler GetPaymentRefundRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetPaymentRefundRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetPaymentRefundRequest) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// Describes a request to retrieve a payment using
// [GetPayment](api-endpoint:Payments-GetPayment).
type GetPaymentRequest struct {
	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GetPaymentRequest) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetPaymentRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler GetPaymentRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetPaymentRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetPaymentRequest) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetPayoutRequest struct {
	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GetPayoutRequest) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetPayoutRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler GetPayoutRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetPayoutRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetPayoutRequest) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// A request to get a `Shift` by ID.
type GetShiftRequest struct {
	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GetShiftRequest) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetShiftRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler GetShiftRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetShiftRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetShiftRequest) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// A response to a request to get a `Shift`. The response contains
// the requested `Shift` object and might contain a set of `Error` objects if
// the request resulted in errors.
type GetShiftResponse struct {
	// The requested `Shift`.
	Shift *Shift `json:"shift,omitempty" url:"shift,omitempty"`
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GetShiftResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetShiftResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetShiftResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetShiftResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetShiftResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// Represents a `RetrieveSnippet` request.
type GetSnippetRequest struct {
	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GetSnippetRequest) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetSnippetRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler GetSnippetRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetSnippetRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetSnippetRequest) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetTeamMemberBookingProfileRequest struct {
	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GetTeamMemberBookingProfileRequest) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetTeamMemberBookingProfileRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler GetTeamMemberBookingProfileRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetTeamMemberBookingProfileRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetTeamMemberBookingProfileRequest) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetTeamMemberBookingProfileResponse struct {
	// The returned team member booking profile.
	TeamMemberBookingProfile *TeamMemberBookingProfile `json:"team_member_booking_profile,omitempty" url:"team_member_booking_profile,omitempty"`
	// Errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GetTeamMemberBookingProfileResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetTeamMemberBookingProfileResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetTeamMemberBookingProfileResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetTeamMemberBookingProfileResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetTeamMemberBookingProfileResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// Represents a retrieve request for a `TeamMember` object.
type GetTeamMemberRequest struct {
	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GetTeamMemberRequest) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetTeamMemberRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler GetTeamMemberRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetTeamMemberRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetTeamMemberRequest) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// A request to get a `TeamMemberWage`.
type GetTeamMemberWageRequest struct {
	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GetTeamMemberWageRequest) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetTeamMemberWageRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler GetTeamMemberWageRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetTeamMemberWageRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetTeamMemberWageRequest) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// A response to a request to get a `TeamMemberWage`. The response contains
// the requested `TeamMemberWage` objects and might contain a set of `Error` objects if
// the request resulted in errors.
type GetTeamMemberWageResponse struct {
	// The requested `TeamMemberWage` object.
	TeamMemberWage *TeamMemberWage `json:"team_member_wage,omitempty" url:"team_member_wage,omitempty"`
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GetTeamMemberWageResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetTeamMemberWageResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetTeamMemberWageResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetTeamMemberWageResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetTeamMemberWageResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetTerminalActionRequest struct {
	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GetTerminalActionRequest) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetTerminalActionRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler GetTerminalActionRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetTerminalActionRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetTerminalActionRequest) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetTerminalActionResponse struct {
	// Information on errors encountered during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The requested `TerminalAction`
	Action *TerminalAction `json:"action,omitempty" url:"action,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GetTerminalActionResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetTerminalActionResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetTerminalActionResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetTerminalActionResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetTerminalActionResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetTerminalCheckoutRequest struct {
	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GetTerminalCheckoutRequest) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetTerminalCheckoutRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler GetTerminalCheckoutRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetTerminalCheckoutRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetTerminalCheckoutRequest) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetTerminalCheckoutResponse struct {
	// Information about errors encountered during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The requested `TerminalCheckout`.
	Checkout *TerminalCheckout `json:"checkout,omitempty" url:"checkout,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GetTerminalCheckoutResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetTerminalCheckoutResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetTerminalCheckoutResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetTerminalCheckoutResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetTerminalCheckoutResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetTerminalRefundRequest struct {
	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GetTerminalRefundRequest) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetTerminalRefundRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler GetTerminalRefundRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetTerminalRefundRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetTerminalRefundRequest) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetTerminalRefundResponse struct {
	// Information about errors encountered during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The requested `Refund`.
	Refund *TerminalRefund `json:"refund,omitempty" url:"refund,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GetTerminalRefundResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetTerminalRefundResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetTerminalRefundResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetTerminalRefundResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetTerminalRefundResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetTransactionRequest struct {
	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GetTransactionRequest) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetTransactionRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler GetTransactionRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetTransactionRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetTransactionRequest) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// Defines the fields that are included in the response body of
// a request to the [RetrieveTransaction](api-endpoint:Transactions-RetrieveTransaction) endpoint.
//
// One of `errors` or `transaction` is present in a given response (never both).
type GetTransactionResponse struct {
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The requested transaction.
	Transaction *Transaction `json:"transaction,omitempty" url:"transaction,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GetTransactionResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetTransactionResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetTransactionResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetTransactionResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetTransactionResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// Represents an input to a call to [RetrieveVendor](api-endpoint:Vendors-RetrieveVendor).
type GetVendorRequest struct {
	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GetVendorRequest) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetVendorRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler GetVendorRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetVendorRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetVendorRequest) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// Represents a retrieve request for the wage setting of a team member.
type GetWageSettingRequest struct {
	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GetWageSettingRequest) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetWageSettingRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler GetWageSettingRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetWageSettingRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetWageSettingRequest) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// Represents a response from a retrieve request containing the specified `WageSetting` object or error messages.
type GetWageSettingResponse struct {
	// The successfully retrieved `WageSetting` object.
	WageSetting *WageSetting `json:"wage_setting,omitempty" url:"wage_setting,omitempty"`
	// The errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GetWageSettingResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetWageSettingResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetWageSettingResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetWageSettingResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetWageSettingResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// Retrieves a [Subscription](entity:WebhookSubscription) using its id.
type GetWebhookSubscriptionRequest struct {
	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GetWebhookSubscriptionRequest) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetWebhookSubscriptionRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler GetWebhookSubscriptionRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetWebhookSubscriptionRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetWebhookSubscriptionRequest) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// Defines the fields that are included in the response body of
// a request to the [RetrieveWebhookSubscription](api-endpoint:WebhookSubscriptions-RetrieveWebhookSubscription) endpoint.
//
// Note: if there are errors processing the request, the [Subscription](entity:WebhookSubscription) will not be
// present.
type GetWebhookSubscriptionResponse struct {
	// Information on errors encountered during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The requested [Subscription](entity:WebhookSubscription).
	Subscription *WebhookSubscription `json:"subscription,omitempty" url:"subscription,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GetWebhookSubscriptionResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetWebhookSubscriptionResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetWebhookSubscriptionResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetWebhookSubscriptionResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetWebhookSubscriptionResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// Represents an action performed on a [gift card](entity:GiftCard) that affects its state or balance.
// A gift card activity contains information about a specific activity type. For example, a `REDEEM` activity
// includes a `redeem_activity_details` field that contains information about the redemption.
type GiftCardActivity struct {
	// The Square-assigned ID of the gift card activity.
	Id *string `json:"id,omitempty" url:"id,omitempty"`
	// The type of gift card activity.
	// See [Type](#type-type) for possible values
	Type GiftCardActivityType `json:"type" url:"type"`
	// The ID of the [business location](entity:Location) where the activity occurred.
	LocationId string `json:"location_id" url:"location_id"`
	// The timestamp when the gift card activity was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The gift card ID. When creating a gift card activity, `gift_card_id` is not required if
	// `gift_card_gan` is specified.
	GiftCardId *string `json:"gift_card_id,omitempty" url:"gift_card_id,omitempty"`
	// The gift card account number (GAN). When creating a gift card activity, `gift_card_gan`
	// is not required if `gift_card_id` is specified.
	GiftCardGan *string `json:"gift_card_gan,omitempty" url:"gift_card_gan,omitempty"`
	// The final balance on the gift card after the action is completed.
	GiftCardBalanceMoney *Money `json:"gift_card_balance_money,omitempty" url:"gift_card_balance_money,omitempty"`
	// Additional details about a `LOAD` activity, which is used to reload money onto a gift card.
	LoadActivityDetails *GiftCardActivityLoad `json:"load_activity_details,omitempty" url:"load_activity_details,omitempty"`
	// Additional details about an `ACTIVATE` activity, which is used to activate a gift card with
	// an initial balance.
	ActivateActivityDetails *GiftCardActivityActivate `json:"activate_activity_details,omitempty" url:"activate_activity_details,omitempty"`
	// Additional details about a `REDEEM` activity, which is used to redeem a gift card for a purchase.
	//
	// For applications that process payments using the Square Payments API, Square creates a `REDEEM` activity that
	// updates the gift card balance after the corresponding [CreatePayment](api-endpoint:Payments-CreatePayment)
	// request is completed. Applications that use a custom payment processing system must call
	// [CreateGiftCardActivity](api-endpoint:GiftCardActivities-CreateGiftCardActivity) to create the `REDEEM` activity.
	RedeemActivityDetails *GiftCardActivityRedeem `json:"redeem_activity_details,omitempty" url:"redeem_activity_details,omitempty"`
	// Additional details about a `CLEAR_BALANCE` activity, which is used to set the balance of a gift card to zero.
	ClearBalanceActivityDetails *GiftCardActivityClearBalance `json:"clear_balance_activity_details,omitempty" url:"clear_balance_activity_details,omitempty"`
	// Additional details about a `DEACTIVATE` activity, which is used to deactivate a gift card.
	DeactivateActivityDetails *GiftCardActivityDeactivate `json:"deactivate_activity_details,omitempty" url:"deactivate_activity_details,omitempty"`
	// Additional details about an `ADJUST_INCREMENT` activity, which is used to add money to a gift card
	// outside of a typical `ACTIVATE`, `LOAD`, or `REFUND` activity flow.
	AdjustIncrementActivityDetails *GiftCardActivityAdjustIncrement `json:"adjust_increment_activity_details,omitempty" url:"adjust_increment_activity_details,omitempty"`
	// Additional details about an `ADJUST_DECREMENT` activity, which is used to deduct money from a gift
	// card outside of a typical `REDEEM` activity flow.
	AdjustDecrementActivityDetails *GiftCardActivityAdjustDecrement `json:"adjust_decrement_activity_details,omitempty" url:"adjust_decrement_activity_details,omitempty"`
	// Additional details about a `REFUND` activity, which is used to add money to a gift card when
	// refunding a payment.
	//
	// For applications that process payments using the Square Payments API, Square creates a `REFUND` activity that
	// updates the gift card balance after the corresponding [RefundPayment](api-endpoint:Refunds-RefundPayment)
	// request is completed. Applications that use a custom payment processing system must call
	// [CreateGiftCardActivity](api-endpoint:GiftCardActivities-CreateGiftCardActivity) to create the `REFUND` activity.
	RefundActivityDetails *GiftCardActivityRefund `json:"refund_activity_details,omitempty" url:"refund_activity_details,omitempty"`
	// Additional details about an `UNLINKED_ACTIVITY_REFUND` activity. This activity is used to add money
	// to a gift card when refunding a payment that was processed using a custom payment processing system
	// and not linked to the gift card.
	UnlinkedActivityRefundActivityDetails *GiftCardActivityUnlinkedActivityRefund `json:"unlinked_activity_refund_activity_details,omitempty" url:"unlinked_activity_refund_activity_details,omitempty"`
	// Additional details about an `IMPORT` activity, which Square uses to import a third-party
	// gift card with a balance.
	ImportActivityDetails *GiftCardActivityImport `json:"import_activity_details,omitempty" url:"import_activity_details,omitempty"`
	// Additional details about a `BLOCK` activity, which Square uses to temporarily block a gift card.
	BlockActivityDetails *GiftCardActivityBlock `json:"block_activity_details,omitempty" url:"block_activity_details,omitempty"`
	// Additional details about an `UNBLOCK` activity, which Square uses to unblock a gift card.
	UnblockActivityDetails *GiftCardActivityUnblock `json:"unblock_activity_details,omitempty" url:"unblock_activity_details,omitempty"`
	// Additional details about an `IMPORT_REVERSAL` activity, which Square uses to reverse the
	// import of a third-party gift card.
	ImportReversalActivityDetails *GiftCardActivityImportReversal `json:"import_reversal_activity_details,omitempty" url:"import_reversal_activity_details,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GiftCardActivity) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GiftCardActivity) UnmarshalJSON(data []byte) error {
	type unmarshaler GiftCardActivity
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GiftCardActivity(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GiftCardActivity) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// Represents details about an `ACTIVATE` [gift card activity type](entity:GiftCardActivityType).
type GiftCardActivityActivate struct {
	// The amount added to the gift card. This value is a positive integer.
	//
	// Applications that use a custom order processing system must specify this amount in the
	// [CreateGiftCardActivity](api-endpoint:GiftCardActivities-CreateGiftCardActivity) request.
	AmountMoney *Money `json:"amount_money,omitempty" url:"amount_money,omitempty"`
	// The ID of the [order](entity:Order) that contains the `GIFT_CARD` line item.
	//
	// Applications that use the Square Orders API to process orders must specify the order ID
	// [CreateGiftCardActivity](api-endpoint:GiftCardActivities-CreateGiftCardActivity) request.
	OrderId *string `json:"order_id,omitempty" url:"order_id,omitempty"`
	// The UID of the `GIFT_CARD` line item in the order that represents the gift card purchase.
	//
	// Applications that use the Square Orders API to process orders must specify the line item UID
	// in the [CreateGiftCardActivity](api-endpoint:GiftCardActivities-CreateGiftCardActivity) request.
	LineItemUid *string `json:"line_item_uid,omitempty" url:"line_item_uid,omitempty"`
	// A client-specified ID that associates the gift card activity with an entity in another system.
	//
	// Applications that use a custom order processing system can use this field to track information
	// related to an order or payment.
	ReferenceId *string `json:"reference_id,omitempty" url:"reference_id,omitempty"`
	// The payment instrument IDs used to process the gift card purchase, such as a credit card ID
	// or bank account ID.
	//
	// Applications that use a custom order processing system must specify payment instrument IDs in
	// the [CreateGiftCardActivity](api-endpoint:GiftCardActivities-CreateGiftCardActivity) request.
	// Square uses this information to perform compliance checks.
	//
	// For applications that use the Square Orders API to process payments, Square has the necessary
	// instrument IDs to perform compliance checks.
	BuyerPaymentInstrumentIds []string `json:"buyer_payment_instrument_ids,omitempty" url:"buyer_payment_instrument_ids,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GiftCardActivityActivate) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GiftCardActivityActivate) UnmarshalJSON(data []byte) error {
	type unmarshaler GiftCardActivityActivate
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GiftCardActivityActivate(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GiftCardActivityActivate) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// Represents details about an `ADJUST_DECREMENT` [gift card activity type](entity:GiftCardActivityType).
type GiftCardActivityAdjustDecrement struct {
	// The amount deducted from the gift card balance. This value is a positive integer.
	AmountMoney *Money `json:"amount_money,omitempty" url:"amount_money,omitempty"`
	// The reason the gift card balance was adjusted.
	// See [Reason](#type-reason) for possible values
	Reason GiftCardActivityAdjustDecrementReason `json:"reason" url:"reason"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GiftCardActivityAdjustDecrement) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GiftCardActivityAdjustDecrement) UnmarshalJSON(data []byte) error {
	type unmarshaler GiftCardActivityAdjustDecrement
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GiftCardActivityAdjustDecrement(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GiftCardActivityAdjustDecrement) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// Indicates the reason for deducting money from a [gift card](entity:GiftCard).
type GiftCardActivityAdjustDecrementReason string

const (
	GiftCardActivityAdjustDecrementReasonReasonDoNotUse               GiftCardActivityAdjustDecrementReason = "REASON_DO_NOT_USE"
	GiftCardActivityAdjustDecrementReasonSuspiciousActivity           GiftCardActivityAdjustDecrementReason = "SUSPICIOUS_ACTIVITY"
	GiftCardActivityAdjustDecrementReasonBalanceAccidentallyIncreased GiftCardActivityAdjustDecrementReason = "BALANCE_ACCIDENTALLY_INCREASED"
	GiftCardActivityAdjustDecrementReasonSupportIssue                 GiftCardActivityAdjustDecrementReason = "SUPPORT_ISSUE"
)

func NewGiftCardActivityAdjustDecrementReasonFromString(s string) (GiftCardActivityAdjustDecrementReason, error) {
	switch s {
	case "REASON_DO_NOT_USE":
		return GiftCardActivityAdjustDecrementReasonReasonDoNotUse, nil
	case "SUSPICIOUS_ACTIVITY":
		return GiftCardActivityAdjustDecrementReasonSuspiciousActivity, nil
	case "BALANCE_ACCIDENTALLY_INCREASED":
		return GiftCardActivityAdjustDecrementReasonBalanceAccidentallyIncreased, nil
	case "SUPPORT_ISSUE":
		return GiftCardActivityAdjustDecrementReasonSupportIssue, nil
	}
	var t GiftCardActivityAdjustDecrementReason
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GiftCardActivityAdjustDecrementReason) Ptr() *GiftCardActivityAdjustDecrementReason {
	return &g
}

// Represents details about an `ADJUST_INCREMENT` [gift card activity type](entity:GiftCardActivityType).
type GiftCardActivityAdjustIncrement struct {
	// The amount added to the gift card balance. This value is a positive integer.
	AmountMoney *Money `json:"amount_money,omitempty" url:"amount_money,omitempty"`
	// The reason the gift card balance was adjusted.
	// See [Reason](#type-reason) for possible values
	Reason GiftCardActivityAdjustIncrementReason `json:"reason" url:"reason"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GiftCardActivityAdjustIncrement) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GiftCardActivityAdjustIncrement) UnmarshalJSON(data []byte) error {
	type unmarshaler GiftCardActivityAdjustIncrement
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GiftCardActivityAdjustIncrement(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GiftCardActivityAdjustIncrement) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// Indicates the reason for adding money to a [gift card](entity:GiftCard).
type GiftCardActivityAdjustIncrementReason string

const (
	GiftCardActivityAdjustIncrementReasonReasonDoNotUse    GiftCardActivityAdjustIncrementReason = "REASON_DO_NOT_USE"
	GiftCardActivityAdjustIncrementReasonComplimentary     GiftCardActivityAdjustIncrementReason = "COMPLIMENTARY"
	GiftCardActivityAdjustIncrementReasonSupportIssue      GiftCardActivityAdjustIncrementReason = "SUPPORT_ISSUE"
	GiftCardActivityAdjustIncrementReasonTransactionVoided GiftCardActivityAdjustIncrementReason = "TRANSACTION_VOIDED"
)

func NewGiftCardActivityAdjustIncrementReasonFromString(s string) (GiftCardActivityAdjustIncrementReason, error) {
	switch s {
	case "REASON_DO_NOT_USE":
		return GiftCardActivityAdjustIncrementReasonReasonDoNotUse, nil
	case "COMPLIMENTARY":
		return GiftCardActivityAdjustIncrementReasonComplimentary, nil
	case "SUPPORT_ISSUE":
		return GiftCardActivityAdjustIncrementReasonSupportIssue, nil
	case "TRANSACTION_VOIDED":
		return GiftCardActivityAdjustIncrementReasonTransactionVoided, nil
	}
	var t GiftCardActivityAdjustIncrementReason
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GiftCardActivityAdjustIncrementReason) Ptr() *GiftCardActivityAdjustIncrementReason {
	return &g
}

// Represents details about a `BLOCK` [gift card activity type](entity:GiftCardActivityType).
type GiftCardActivityBlock struct {
	// The reason the gift card was blocked.
	// See [Reason](#type-reason) for possible values
	Reason GiftCardActivityBlockReason `json:"reason" url:"reason"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GiftCardActivityBlock) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GiftCardActivityBlock) UnmarshalJSON(data []byte) error {
	type unmarshaler GiftCardActivityBlock
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GiftCardActivityBlock(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GiftCardActivityBlock) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// Indicates the reason for blocking a [gift card](entity:GiftCard).
type GiftCardActivityBlockReason string

const (
	GiftCardActivityBlockReasonReasonDoNotUse  GiftCardActivityBlockReason = "REASON_DO_NOT_USE"
	GiftCardActivityBlockReasonChargebackBlock GiftCardActivityBlockReason = "CHARGEBACK_BLOCK"
)

func NewGiftCardActivityBlockReasonFromString(s string) (GiftCardActivityBlockReason, error) {
	switch s {
	case "REASON_DO_NOT_USE":
		return GiftCardActivityBlockReasonReasonDoNotUse, nil
	case "CHARGEBACK_BLOCK":
		return GiftCardActivityBlockReasonChargebackBlock, nil
	}
	var t GiftCardActivityBlockReason
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GiftCardActivityBlockReason) Ptr() *GiftCardActivityBlockReason {
	return &g
}

// Represents details about a `CLEAR_BALANCE` [gift card activity type](entity:GiftCardActivityType).
type GiftCardActivityClearBalance struct {
	// The reason the gift card balance was cleared.
	// See [Reason](#type-reason) for possible values
	Reason GiftCardActivityClearBalanceReason `json:"reason" url:"reason"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GiftCardActivityClearBalance) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GiftCardActivityClearBalance) UnmarshalJSON(data []byte) error {
	type unmarshaler GiftCardActivityClearBalance
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GiftCardActivityClearBalance(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GiftCardActivityClearBalance) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// Indicates the reason for clearing the balance of a [gift card](entity:GiftCard).
type GiftCardActivityClearBalanceReason string

const (
	GiftCardActivityClearBalanceReasonReasonDoNotUse     GiftCardActivityClearBalanceReason = "REASON_DO_NOT_USE"
	GiftCardActivityClearBalanceReasonSuspiciousActivity GiftCardActivityClearBalanceReason = "SUSPICIOUS_ACTIVITY"
	GiftCardActivityClearBalanceReasonReuseGiftcard      GiftCardActivityClearBalanceReason = "REUSE_GIFTCARD"
	GiftCardActivityClearBalanceReasonUnknownReason      GiftCardActivityClearBalanceReason = "UNKNOWN_REASON"
)

func NewGiftCardActivityClearBalanceReasonFromString(s string) (GiftCardActivityClearBalanceReason, error) {
	switch s {
	case "REASON_DO_NOT_USE":
		return GiftCardActivityClearBalanceReasonReasonDoNotUse, nil
	case "SUSPICIOUS_ACTIVITY":
		return GiftCardActivityClearBalanceReasonSuspiciousActivity, nil
	case "REUSE_GIFTCARD":
		return GiftCardActivityClearBalanceReasonReuseGiftcard, nil
	case "UNKNOWN_REASON":
		return GiftCardActivityClearBalanceReasonUnknownReason, nil
	}
	var t GiftCardActivityClearBalanceReason
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GiftCardActivityClearBalanceReason) Ptr() *GiftCardActivityClearBalanceReason {
	return &g
}

// Published when a [gift card activity](entity:GiftCardActivity) is created.
type GiftCardActivityCreatedWebhook struct {
	// The ID of the Square seller associated with the event.
	MerchantId *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The type of event. For this event, the value is `gift_card.activity.created`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// The unique ID of the event, which is used for
	// [idempotency support](https://developer.squareup.com/docs/webhooks/step4manage#webhooks-best-practices).
	EventId *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// The timestamp of when the event was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The data associated with the event.
	Data *GiftCardActivityCreatedWebhookData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GiftCardActivityCreatedWebhook) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GiftCardActivityCreatedWebhook) UnmarshalJSON(data []byte) error {
	type unmarshaler GiftCardActivityCreatedWebhook
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GiftCardActivityCreatedWebhook(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GiftCardActivityCreatedWebhook) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// Represents the data associated with a `gift_card.activity.created` webhook event.
type GiftCardActivityCreatedWebhookData struct {
	// The type of object affected by the event. For this event, the value is `gift_card.activity`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// The ID of the new gift card activity.
	Id *string `json:"id,omitempty" url:"id,omitempty"`
	// An object that contains the new gift card activity.
	Object *GiftCardActivityCreatedWebhookObject `json:"object,omitempty" url:"object,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GiftCardActivityCreatedWebhookData) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GiftCardActivityCreatedWebhookData) UnmarshalJSON(data []byte) error {
	type unmarshaler GiftCardActivityCreatedWebhookData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GiftCardActivityCreatedWebhookData(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GiftCardActivityCreatedWebhookData) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// An object that contains the gift card activity associated with a
// `gift_card.activity.created` webhook event.
type GiftCardActivityCreatedWebhookObject struct {
	// The new gift card activity.
	GiftCardActivity *GiftCardActivity `json:"gift_card_activity,omitempty" url:"gift_card_activity,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GiftCardActivityCreatedWebhookObject) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GiftCardActivityCreatedWebhookObject) UnmarshalJSON(data []byte) error {
	type unmarshaler GiftCardActivityCreatedWebhookObject
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GiftCardActivityCreatedWebhookObject(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GiftCardActivityCreatedWebhookObject) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// Represents details about a `DEACTIVATE` [gift card activity type](entity:GiftCardActivityType).
type GiftCardActivityDeactivate struct {
	// The reason the gift card was deactivated.
	// See [Reason](#type-reason) for possible values
	Reason GiftCardActivityDeactivateReason `json:"reason" url:"reason"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GiftCardActivityDeactivate) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GiftCardActivityDeactivate) UnmarshalJSON(data []byte) error {
	type unmarshaler GiftCardActivityDeactivate
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GiftCardActivityDeactivate(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GiftCardActivityDeactivate) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// Indicates the reason for deactivating a [gift card](entity:GiftCard).
type GiftCardActivityDeactivateReason string

const (
	GiftCardActivityDeactivateReasonReasonDoNotUse       GiftCardActivityDeactivateReason = "REASON_DO_NOT_USE"
	GiftCardActivityDeactivateReasonSuspiciousActivity   GiftCardActivityDeactivateReason = "SUSPICIOUS_ACTIVITY"
	GiftCardActivityDeactivateReasonUnknownReason        GiftCardActivityDeactivateReason = "UNKNOWN_REASON"
	GiftCardActivityDeactivateReasonChargebackDeactivate GiftCardActivityDeactivateReason = "CHARGEBACK_DEACTIVATE"
)

func NewGiftCardActivityDeactivateReasonFromString(s string) (GiftCardActivityDeactivateReason, error) {
	switch s {
	case "REASON_DO_NOT_USE":
		return GiftCardActivityDeactivateReasonReasonDoNotUse, nil
	case "SUSPICIOUS_ACTIVITY":
		return GiftCardActivityDeactivateReasonSuspiciousActivity, nil
	case "UNKNOWN_REASON":
		return GiftCardActivityDeactivateReasonUnknownReason, nil
	case "CHARGEBACK_DEACTIVATE":
		return GiftCardActivityDeactivateReasonChargebackDeactivate, nil
	}
	var t GiftCardActivityDeactivateReason
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GiftCardActivityDeactivateReason) Ptr() *GiftCardActivityDeactivateReason {
	return &g
}

// Represents details about an `IMPORT` [gift card activity type](entity:GiftCardActivityType).
// This activity type is used when Square imports a third-party gift card, in which case the
// `gan_source` of the gift card is set to `OTHER`.
type GiftCardActivityImport struct {
	// The balance amount on the imported gift card.
	AmountMoney *Money `json:"amount_money,omitempty" url:"amount_money,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GiftCardActivityImport) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GiftCardActivityImport) UnmarshalJSON(data []byte) error {
	type unmarshaler GiftCardActivityImport
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GiftCardActivityImport(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GiftCardActivityImport) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// Represents details about an `IMPORT_REVERSAL` [gift card activity type](entity:GiftCardActivityType).
type GiftCardActivityImportReversal struct {
	// The amount of money cleared from the third-party gift card when
	// the import was reversed.
	AmountMoney *Money `json:"amount_money,omitempty" url:"amount_money,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GiftCardActivityImportReversal) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GiftCardActivityImportReversal) UnmarshalJSON(data []byte) error {
	type unmarshaler GiftCardActivityImportReversal
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GiftCardActivityImportReversal(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GiftCardActivityImportReversal) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// Represents details about a `LOAD` [gift card activity type](entity:GiftCardActivityType).
type GiftCardActivityLoad struct {
	// The amount added to the gift card. This value is a positive integer.
	//
	// Applications that use a custom order processing system must specify this amount in the
	// [CreateGiftCardActivity](api-endpoint:GiftCardActivities-CreateGiftCardActivity) request.
	AmountMoney *Money `json:"amount_money,omitempty" url:"amount_money,omitempty"`
	// The ID of the [order](entity:Order) that contains the `GIFT_CARD` line item.
	//
	// Applications that use the Square Orders API to process orders must specify the order ID in the
	// [CreateGiftCardActivity](api-endpoint:GiftCardActivities-CreateGiftCardActivity) request.
	OrderId *string `json:"order_id,omitempty" url:"order_id,omitempty"`
	// The UID of the `GIFT_CARD` line item in the order that represents the additional funds for the gift card.
	//
	// Applications that use the Square Orders API to process orders must specify the line item UID
	// in the [CreateGiftCardActivity](api-endpoint:GiftCardActivities-CreateGiftCardActivity) request.
	LineItemUid *string `json:"line_item_uid,omitempty" url:"line_item_uid,omitempty"`
	// A client-specified ID that associates the gift card activity with an entity in another system.
	//
	// Applications that use a custom order processing system can use this field to track information related to
	// an order or payment.
	ReferenceId *string `json:"reference_id,omitempty" url:"reference_id,omitempty"`
	// The payment instrument IDs used to process the order for the additional funds, such as a credit card ID
	// or bank account ID.
	//
	// Applications that use a custom order processing system must specify payment instrument IDs in
	// the [CreateGiftCardActivity](api-endpoint:GiftCardActivities-CreateGiftCardActivity) request.
	// Square uses this information to perform compliance checks.
	//
	// For applications that use the Square Orders API to process payments, Square has the necessary
	// instrument IDs to perform compliance checks.
	BuyerPaymentInstrumentIds []string `json:"buyer_payment_instrument_ids,omitempty" url:"buyer_payment_instrument_ids,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GiftCardActivityLoad) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GiftCardActivityLoad) UnmarshalJSON(data []byte) error {
	type unmarshaler GiftCardActivityLoad
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GiftCardActivityLoad(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GiftCardActivityLoad) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// Represents details about a `REDEEM` [gift card activity type](entity:GiftCardActivityType).
type GiftCardActivityRedeem struct {
	// The amount deducted from the gift card for the redemption. This value is a positive integer.
	//
	// Applications that use a custom payment processing system must specify this amount in the
	// [CreateGiftCardActivity](api-endpoint:GiftCardActivities-CreateGiftCardActivity) request.
	AmountMoney *Money `json:"amount_money,omitempty" url:"amount_money,omitempty"`
	// The ID of the payment that represents the gift card redemption. Square populates this field
	// if the payment was processed by Square.
	PaymentId *string `json:"payment_id,omitempty" url:"payment_id,omitempty"`
	// A client-specified ID that associates the gift card activity with an entity in another system.
	//
	// Applications that use a custom payment processing system can use this field to track information
	// related to an order or payment.
	ReferenceId *string `json:"reference_id,omitempty" url:"reference_id,omitempty"`
	// The status of the gift card redemption. Gift cards redeemed from Square Point of Sale or the
	// Square Seller Dashboard use a two-state process: `PENDING`
	// to `COMPLETED` or `PENDING` to `CANCELED`. Gift cards redeemed using the Gift Card Activities API
	// always have a `COMPLETED` status.
	// See [Status](#type-status) for possible values
	Status *GiftCardActivityRedeemStatus `json:"status,omitempty" url:"status,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GiftCardActivityRedeem) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GiftCardActivityRedeem) UnmarshalJSON(data []byte) error {
	type unmarshaler GiftCardActivityRedeem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GiftCardActivityRedeem(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GiftCardActivityRedeem) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// Indicates the status of a [gift card](entity:GiftCard) redemption. This status is relevant only for
// redemptions made from Square products (such as Square Point of Sale) because Square products use a
// two-state process. Gift cards redeemed using the Gift Card Activities API always have a `COMPLETED` status.
type GiftCardActivityRedeemStatus string

const (
	GiftCardActivityRedeemStatusTypeDoNotUse GiftCardActivityRedeemStatus = "TYPE_DO_NOT_USE"
	GiftCardActivityRedeemStatusPending      GiftCardActivityRedeemStatus = "PENDING"
	GiftCardActivityRedeemStatusCompleted    GiftCardActivityRedeemStatus = "COMPLETED"
	GiftCardActivityRedeemStatusCanceled     GiftCardActivityRedeemStatus = "CANCELED"
)

func NewGiftCardActivityRedeemStatusFromString(s string) (GiftCardActivityRedeemStatus, error) {
	switch s {
	case "TYPE_DO_NOT_USE":
		return GiftCardActivityRedeemStatusTypeDoNotUse, nil
	case "PENDING":
		return GiftCardActivityRedeemStatusPending, nil
	case "COMPLETED":
		return GiftCardActivityRedeemStatusCompleted, nil
	case "CANCELED":
		return GiftCardActivityRedeemStatusCanceled, nil
	}
	var t GiftCardActivityRedeemStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GiftCardActivityRedeemStatus) Ptr() *GiftCardActivityRedeemStatus {
	return &g
}

// Represents details about a `REFUND` [gift card activity type](entity:GiftCardActivityType).
type GiftCardActivityRefund struct {
	// The ID of the refunded `REDEEM` gift card activity. Square populates this field if the
	// `payment_id` in the corresponding [RefundPayment](api-endpoint:Refunds-RefundPayment) request
	// represents a redemption made by the same gift card. Note that you must use `RefundPayment`
	// to refund a gift card payment to the same gift card if the payment was processed by Square.
	//
	// For applications that use a custom payment processing system, this field is required when creating
	// a `REFUND` activity. The provided `REDEEM` activity ID must be linked to the same gift card.
	RedeemActivityId *string `json:"redeem_activity_id,omitempty" url:"redeem_activity_id,omitempty"`
	// The amount added to the gift card for the refund. This value is a positive integer.
	//
	// This field is required when creating a `REFUND` activity. The amount can represent a full or partial refund.
	AmountMoney *Money `json:"amount_money,omitempty" url:"amount_money,omitempty"`
	// A client-specified ID that associates the gift card activity with an entity in another system.
	ReferenceId *string `json:"reference_id,omitempty" url:"reference_id,omitempty"`
	// The ID of the refunded payment. Square populates this field if the refund is for a
	// payment processed by Square and one of the following conditions is true:
	//
	//   - The Refunds API is used to refund a gift card payment to the same gift card.
	//   - A seller initiated the refund from Square Point of Sale or the Seller Dashboard. The payment source can be the
	//     same gift card or a cross-tender payment from a credit card or a different gift card.
	PaymentId *string `json:"payment_id,omitempty" url:"payment_id,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GiftCardActivityRefund) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GiftCardActivityRefund) UnmarshalJSON(data []byte) error {
	type unmarshaler GiftCardActivityRefund
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GiftCardActivityRefund(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GiftCardActivityRefund) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// Indicates the type of [gift card activity](entity:GiftCardActivity).
type GiftCardActivityType string

const (
	GiftCardActivityTypeTypeDoNotUse           GiftCardActivityType = "TYPE_DO_NOT_USE"
	GiftCardActivityTypeActivate               GiftCardActivityType = "ACTIVATE"
	GiftCardActivityTypeLoad                   GiftCardActivityType = "LOAD"
	GiftCardActivityTypeRedeem                 GiftCardActivityType = "REDEEM"
	GiftCardActivityTypeClearBalance           GiftCardActivityType = "CLEAR_BALANCE"
	GiftCardActivityTypeDeactivate             GiftCardActivityType = "DEACTIVATE"
	GiftCardActivityTypeAdjustIncrement        GiftCardActivityType = "ADJUST_INCREMENT"
	GiftCardActivityTypeAdjustDecrement        GiftCardActivityType = "ADJUST_DECREMENT"
	GiftCardActivityTypeRefund                 GiftCardActivityType = "REFUND"
	GiftCardActivityTypeUnlinkedActivityRefund GiftCardActivityType = "UNLINKED_ACTIVITY_REFUND"
	GiftCardActivityTypeImport                 GiftCardActivityType = "IMPORT"
	GiftCardActivityTypeOther                  GiftCardActivityType = "OTHER"
	GiftCardActivityTypeBlock                  GiftCardActivityType = "BLOCK"
	GiftCardActivityTypeUnblock                GiftCardActivityType = "UNBLOCK"
	GiftCardActivityTypeImportReversal         GiftCardActivityType = "IMPORT_REVERSAL"
)

func NewGiftCardActivityTypeFromString(s string) (GiftCardActivityType, error) {
	switch s {
	case "TYPE_DO_NOT_USE":
		return GiftCardActivityTypeTypeDoNotUse, nil
	case "ACTIVATE":
		return GiftCardActivityTypeActivate, nil
	case "LOAD":
		return GiftCardActivityTypeLoad, nil
	case "REDEEM":
		return GiftCardActivityTypeRedeem, nil
	case "CLEAR_BALANCE":
		return GiftCardActivityTypeClearBalance, nil
	case "DEACTIVATE":
		return GiftCardActivityTypeDeactivate, nil
	case "ADJUST_INCREMENT":
		return GiftCardActivityTypeAdjustIncrement, nil
	case "ADJUST_DECREMENT":
		return GiftCardActivityTypeAdjustDecrement, nil
	case "REFUND":
		return GiftCardActivityTypeRefund, nil
	case "UNLINKED_ACTIVITY_REFUND":
		return GiftCardActivityTypeUnlinkedActivityRefund, nil
	case "IMPORT":
		return GiftCardActivityTypeImport, nil
	case "OTHER":
		return GiftCardActivityTypeOther, nil
	case "BLOCK":
		return GiftCardActivityTypeBlock, nil
	case "UNBLOCK":
		return GiftCardActivityTypeUnblock, nil
	case "IMPORT_REVERSAL":
		return GiftCardActivityTypeImportReversal, nil
	}
	var t GiftCardActivityType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GiftCardActivityType) Ptr() *GiftCardActivityType {
	return &g
}

// Represents details about an `UNBLOCK` [gift card activity type](entity:GiftCardActivityType).
type GiftCardActivityUnblock struct {
	// The reason the gift card was unblocked.
	// See [Reason](#type-reason) for possible values
	Reason GiftCardActivityUnblockReason `json:"reason" url:"reason"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GiftCardActivityUnblock) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GiftCardActivityUnblock) UnmarshalJSON(data []byte) error {
	type unmarshaler GiftCardActivityUnblock
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GiftCardActivityUnblock(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GiftCardActivityUnblock) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// Indicates the reason for unblocking a [gift card](entity:GiftCard).
type GiftCardActivityUnblockReason string

const (
	GiftCardActivityUnblockReasonReasonDoNotUse    GiftCardActivityUnblockReason = "REASON_DO_NOT_USE"
	GiftCardActivityUnblockReasonChargebackUnblock GiftCardActivityUnblockReason = "CHARGEBACK_UNBLOCK"
)

func NewGiftCardActivityUnblockReasonFromString(s string) (GiftCardActivityUnblockReason, error) {
	switch s {
	case "REASON_DO_NOT_USE":
		return GiftCardActivityUnblockReasonReasonDoNotUse, nil
	case "CHARGEBACK_UNBLOCK":
		return GiftCardActivityUnblockReasonChargebackUnblock, nil
	}
	var t GiftCardActivityUnblockReason
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GiftCardActivityUnblockReason) Ptr() *GiftCardActivityUnblockReason {
	return &g
}

// Represents details about an `UNLINKED_ACTIVITY_REFUND` [gift card activity type](entity:GiftCardActivityType).
type GiftCardActivityUnlinkedActivityRefund struct {
	// The amount added to the gift card for the refund. This value is a positive integer.
	AmountMoney *Money `json:"amount_money,omitempty" url:"amount_money,omitempty"`
	// A client-specified ID that associates the gift card activity with an entity in another system.
	ReferenceId *string `json:"reference_id,omitempty" url:"reference_id,omitempty"`
	// The ID of the refunded payment. This field is not used starting in Square version 2022-06-16.
	PaymentId *string `json:"payment_id,omitempty" url:"payment_id,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GiftCardActivityUnlinkedActivityRefund) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GiftCardActivityUnlinkedActivityRefund) UnmarshalJSON(data []byte) error {
	type unmarshaler GiftCardActivityUnlinkedActivityRefund
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GiftCardActivityUnlinkedActivityRefund(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GiftCardActivityUnlinkedActivityRefund) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// Published when a [gift card activity](entity:GiftCardActivity) is updated.
// Subscribe to this webhook to be notified about the following changes:
//
//   - An update to the `REDEEM` activity for a gift card redemption made from a Square product (such as Square Point of Sale).
//     These redemptions are initially assigned a `PENDING` state, but then change to a `COMPLETED` or `CANCELED` state.
//   - An update to the `IMPORT` activity for an imported gift card when the balance is later adjusted by Square.
type GiftCardActivityUpdatedWebhook struct {
	// The ID of the Square seller associated with the event.
	MerchantId *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The type of event. For this event, the value is `gift_card.activity.updated`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// The unique ID of the event, which is used for
	// [idempotency support](https://developer.squareup.com/docs/webhooks/step4manage#webhooks-best-practices).
	EventId *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// The timestamp of when the event was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The data associated with the event.
	Data *GiftCardActivityUpdatedWebhookData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GiftCardActivityUpdatedWebhook) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GiftCardActivityUpdatedWebhook) UnmarshalJSON(data []byte) error {
	type unmarshaler GiftCardActivityUpdatedWebhook
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GiftCardActivityUpdatedWebhook(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GiftCardActivityUpdatedWebhook) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// The data associated with a `gift_card.activity.updated` webhook event.
type GiftCardActivityUpdatedWebhookData struct {
	// The type of object affected by the event. For this event, the value is `gift_card.activity`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// The ID of the updated gift card activity.
	Id *string `json:"id,omitempty" url:"id,omitempty"`
	// An object that contains the updated gift card activity.
	Object *GiftCardActivityUpdatedWebhookObject `json:"object,omitempty" url:"object,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GiftCardActivityUpdatedWebhookData) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GiftCardActivityUpdatedWebhookData) UnmarshalJSON(data []byte) error {
	type unmarshaler GiftCardActivityUpdatedWebhookData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GiftCardActivityUpdatedWebhookData(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GiftCardActivityUpdatedWebhookData) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// An object that contains the gift card activity associated with a
// `gift_card.activity.updated` webhook event.
type GiftCardActivityUpdatedWebhookObject struct {
	// The updated gift card activity.
	GiftCardActivity *GiftCardActivity `json:"gift_card_activity,omitempty" url:"gift_card_activity,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GiftCardActivityUpdatedWebhookObject) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GiftCardActivityUpdatedWebhookObject) UnmarshalJSON(data []byte) error {
	type unmarshaler GiftCardActivityUpdatedWebhookObject
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GiftCardActivityUpdatedWebhookObject(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GiftCardActivityUpdatedWebhookObject) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// Published when a [gift card](entity:GiftCard) is created.
type GiftCardCreatedWebhook struct {
	// The ID of the Square seller associated with the event.
	MerchantId *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The type of event. For this event, the value is `gift_card.created`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// The unique ID of the event, which is used for
	// [idempotency support](https://developer.squareup.com/docs/webhooks/step4manage#webhooks-best-practices).
	EventId *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// The timestamp of when the event was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The data associated with the event.
	Data *GiftCardCreatedWebhookData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GiftCardCreatedWebhook) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GiftCardCreatedWebhook) UnmarshalJSON(data []byte) error {
	type unmarshaler GiftCardCreatedWebhook
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GiftCardCreatedWebhook(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GiftCardCreatedWebhook) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// The data associated with a `gift_card.created` webhook event.
type GiftCardCreatedWebhookData struct {
	// The type of object affected by the event. For this event, the value is `gift_card`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// The ID of the new gift card.
	Id *string `json:"id,omitempty" url:"id,omitempty"`
	// An object that contains the new gift card.
	Object *GiftCardCreatedWebhookObject `json:"object,omitempty" url:"object,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GiftCardCreatedWebhookData) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GiftCardCreatedWebhookData) UnmarshalJSON(data []byte) error {
	type unmarshaler GiftCardCreatedWebhookData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GiftCardCreatedWebhookData(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GiftCardCreatedWebhookData) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// An object that contains the gift card associated with a `gift_card.created` webhook event.
type GiftCardCreatedWebhookObject struct {
	// The new gift card.
	GiftCard *GiftCard `json:"gift_card,omitempty" url:"gift_card,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GiftCardCreatedWebhookObject) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GiftCardCreatedWebhookObject) UnmarshalJSON(data []byte) error {
	type unmarshaler GiftCardCreatedWebhookObject
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GiftCardCreatedWebhookObject(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GiftCardCreatedWebhookObject) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// Published when a [customer](entity:Customer) is linked to a [gift card](entity:GiftCard).
type GiftCardCustomerLinkedWebhook struct {
	// The ID of the Square seller associated with the event.
	MerchantId *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The type of event. For this event, the value is `gift_card.customer_linked`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// The unique ID of the event, which is used for
	// [idempotency support](https://developer.squareup.com/docs/webhooks/step4manage#webhooks-best-practices).
	EventId *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// The timestamp of when the event was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The data associated with the event.
	Data *GiftCardCustomerLinkedWebhookData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GiftCardCustomerLinkedWebhook) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GiftCardCustomerLinkedWebhook) UnmarshalJSON(data []byte) error {
	type unmarshaler GiftCardCustomerLinkedWebhook
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GiftCardCustomerLinkedWebhook(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GiftCardCustomerLinkedWebhook) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// The data associated with a `gift_card.customer_linked` webhook event.
type GiftCardCustomerLinkedWebhookData struct {
	// The type of object affected by the event. For this event, the value is `gift_card`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// The ID of the updated gift card.
	Id *string `json:"id,omitempty" url:"id,omitempty"`
	// An object that contains the updated gift card and the ID of the linked customer.
	Object *GiftCardCustomerLinkedWebhookObject `json:"object,omitempty" url:"object,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GiftCardCustomerLinkedWebhookData) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GiftCardCustomerLinkedWebhookData) UnmarshalJSON(data []byte) error {
	type unmarshaler GiftCardCustomerLinkedWebhookData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GiftCardCustomerLinkedWebhookData(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GiftCardCustomerLinkedWebhookData) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// An object that contains the gift card and customer ID associated with a
// `gift_card.customer_linked` webhook event.
type GiftCardCustomerLinkedWebhookObject struct {
	// The gift card with the updated `customer_ids` field.
	GiftCard *GiftCard `json:"gift_card,omitempty" url:"gift_card,omitempty"`
	// The ID of the linked [customer](entity:Customer).
	LinkedCustomerId *string `json:"linked_customer_id,omitempty" url:"linked_customer_id,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GiftCardCustomerLinkedWebhookObject) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GiftCardCustomerLinkedWebhookObject) UnmarshalJSON(data []byte) error {
	type unmarshaler GiftCardCustomerLinkedWebhookObject
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GiftCardCustomerLinkedWebhookObject(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GiftCardCustomerLinkedWebhookObject) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// Published when a [customer](entity:Customer) is unlinked from a [gift card](entity:GiftCard).
type GiftCardCustomerUnlinkedWebhook struct {
	// The ID of the Square seller associated with the event.
	MerchantId *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The type of event. For this event, the value is `gift_card.customer_unlinked`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// The unique ID of the event, which is used for
	// [idempotency support](https://developer.squareup.com/docs/webhooks/step4manage#webhooks-best-practices).
	EventId *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// The timestamp of when the event was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The data associated with the event.
	Data *GiftCardCustomerUnlinkedWebhookData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GiftCardCustomerUnlinkedWebhook) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GiftCardCustomerUnlinkedWebhook) UnmarshalJSON(data []byte) error {
	type unmarshaler GiftCardCustomerUnlinkedWebhook
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GiftCardCustomerUnlinkedWebhook(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GiftCardCustomerUnlinkedWebhook) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// The data associated with a `gift_card.customer_unlinked` webhook event.
type GiftCardCustomerUnlinkedWebhookData struct {
	// The type of object affected by the event. For this event, the value is `gift_card`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// The ID of the updated gift card.
	Id *string `json:"id,omitempty" url:"id,omitempty"`
	// An object that contains the updated gift card and the ID of the unlinked customer.
	Object *GiftCardCustomerUnlinkedWebhookObject `json:"object,omitempty" url:"object,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GiftCardCustomerUnlinkedWebhookData) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GiftCardCustomerUnlinkedWebhookData) UnmarshalJSON(data []byte) error {
	type unmarshaler GiftCardCustomerUnlinkedWebhookData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GiftCardCustomerUnlinkedWebhookData(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GiftCardCustomerUnlinkedWebhookData) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// An object that contains the gift card and the customer ID associated with a
// `gift_card.customer_linked` webhook event.
type GiftCardCustomerUnlinkedWebhookObject struct {
	// The gift card with the updated `customer_ids` field.
	// The field is removed if the gift card is not linked to any customers.
	GiftCard *GiftCard `json:"gift_card,omitempty" url:"gift_card,omitempty"`
	// The ID of the unlinked [customer](entity:Customer).
	UnlinkedCustomerId *string `json:"unlinked_customer_id,omitempty" url:"unlinked_customer_id,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GiftCardCustomerUnlinkedWebhookObject) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GiftCardCustomerUnlinkedWebhookObject) UnmarshalJSON(data []byte) error {
	type unmarshaler GiftCardCustomerUnlinkedWebhookObject
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GiftCardCustomerUnlinkedWebhookObject(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GiftCardCustomerUnlinkedWebhookObject) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// Indicates the source that generated the gift card
// account number (GAN).
type GiftCardGanSource string

const (
	GiftCardGanSourceGanSourceDoNotUse GiftCardGanSource = "GAN_SOURCE_DO_NOT_USE"
	GiftCardGanSourceSquare            GiftCardGanSource = "SQUARE"
	GiftCardGanSourceOther             GiftCardGanSource = "OTHER"
)

func NewGiftCardGanSourceFromString(s string) (GiftCardGanSource, error) {
	switch s {
	case "GAN_SOURCE_DO_NOT_USE":
		return GiftCardGanSourceGanSourceDoNotUse, nil
	case "SQUARE":
		return GiftCardGanSourceSquare, nil
	case "OTHER":
		return GiftCardGanSourceOther, nil
	}
	var t GiftCardGanSource
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GiftCardGanSource) Ptr() *GiftCardGanSource {
	return &g
}

// Indicates the gift card state.
type GiftCardStatus string

const (
	GiftCardStatusStatusDoNotUse GiftCardStatus = "STATUS_DO_NOT_USE"
	GiftCardStatusNotActive      GiftCardStatus = "NOT_ACTIVE"
	GiftCardStatusActive         GiftCardStatus = "ACTIVE"
	GiftCardStatusDeactivated    GiftCardStatus = "DEACTIVATED"
	GiftCardStatusBlocked        GiftCardStatus = "BLOCKED"
	GiftCardStatusPending        GiftCardStatus = "PENDING"
	GiftCardStatusUnregistered   GiftCardStatus = "UNREGISTERED"
)

func NewGiftCardStatusFromString(s string) (GiftCardStatus, error) {
	switch s {
	case "STATUS_DO_NOT_USE":
		return GiftCardStatusStatusDoNotUse, nil
	case "NOT_ACTIVE":
		return GiftCardStatusNotActive, nil
	case "ACTIVE":
		return GiftCardStatusActive, nil
	case "DEACTIVATED":
		return GiftCardStatusDeactivated, nil
	case "BLOCKED":
		return GiftCardStatusBlocked, nil
	case "PENDING":
		return GiftCardStatusPending, nil
	case "UNREGISTERED":
		return GiftCardStatusUnregistered, nil
	}
	var t GiftCardStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GiftCardStatus) Ptr() *GiftCardStatus {
	return &g
}

// Indicates the gift card type.
type GiftCardType string

const (
	GiftCardTypeTypeDoNotUse GiftCardType = "TYPE_DO_NOT_USE"
	GiftCardTypePhysical     GiftCardType = "PHYSICAL"
	GiftCardTypeDigital      GiftCardType = "DIGITAL"
)

func NewGiftCardTypeFromString(s string) (GiftCardType, error) {
	switch s {
	case "TYPE_DO_NOT_USE":
		return GiftCardTypeTypeDoNotUse, nil
	case "PHYSICAL":
		return GiftCardTypePhysical, nil
	case "DIGITAL":
		return GiftCardTypeDigital, nil
	}
	var t GiftCardType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GiftCardType) Ptr() *GiftCardType {
	return &g
}

// Published when a [gift card](entity:GiftCard) is updated. This includes
// changes to the state, balance, and customer association.
type GiftCardUpdatedWebhook struct {
	// The ID of the Square seller associated with the event.
	MerchantId *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The type of this event. For this event, the value is `gift_card.updated`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// The unique ID of the event, which is used for
	// [idempotency support](https://developer.squareup.com/docs/webhooks/step4manage#webhooks-best-practices).
	EventId *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// The timestamp of when the event was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The data associated with the event.
	Data *GiftCardUpdatedWebhookData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GiftCardUpdatedWebhook) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GiftCardUpdatedWebhook) UnmarshalJSON(data []byte) error {
	type unmarshaler GiftCardUpdatedWebhook
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GiftCardUpdatedWebhook(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GiftCardUpdatedWebhook) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// The data associated with a `gift_card.updated` webhook event.
type GiftCardUpdatedWebhookData struct {
	// The type of object affected by the event. For this event, the value is `gift_card`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// The ID of the updated gift card.
	Id *string `json:"id,omitempty" url:"id,omitempty"`
	// An object that contains the updated gift card.
	Object *GiftCardUpdatedWebhookObject `json:"object,omitempty" url:"object,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GiftCardUpdatedWebhookData) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GiftCardUpdatedWebhookData) UnmarshalJSON(data []byte) error {
	type unmarshaler GiftCardUpdatedWebhookData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GiftCardUpdatedWebhookData(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GiftCardUpdatedWebhookData) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// An object that contains the gift card associated with a `gift_card.updated` webhook event.
type GiftCardUpdatedWebhookObject struct {
	// The gift card with the updated `balance_money`, `state`, or `customer_ids` field.
	// Some events can affect both `balance_money` and `state`.
	GiftCard *GiftCard `json:"gift_card,omitempty" url:"gift_card,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GiftCardUpdatedWebhookObject) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GiftCardUpdatedWebhookObject) UnmarshalJSON(data []byte) error {
	type unmarshaler GiftCardUpdatedWebhookObject
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GiftCardUpdatedWebhookObject(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GiftCardUpdatedWebhookObject) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// Represents a change in state or quantity of product inventory at a
// particular time and location.
type InventoryAdjustment struct {
	// A unique ID generated by Square for the
	// `InventoryAdjustment`.
	Id *string `json:"id,omitempty" url:"id,omitempty"`
	// An optional ID provided by the application to tie the
	// `InventoryAdjustment` to an external
	// system.
	ReferenceId *string `json:"reference_id,omitempty" url:"reference_id,omitempty"`
	// The [inventory state](entity:InventoryState) of the related quantity
	// of items before the adjustment. Replaced by the `from_state` field.
	// See [InventoryState](#type-inventorystate) for possible values
	FromStatus *InventoryState `json:"from_status,omitempty" url:"from_status,omitempty"`
	// The [inventory state](entity:InventoryState) of the related quantity
	// of items after the adjustment. Replaced by the `to_state` field.
	// See [InventoryState](#type-inventorystate) for possible values
	ToStatus *InventoryState `json:"to_status,omitempty" url:"to_status,omitempty"`
	// The [inventory state](entity:InventoryState) of the related quantity
	// of items before the adjustment.
	// See [InventoryState](#type-inventorystate) for possible values
	FromState *InventoryState `json:"from_state,omitempty" url:"from_state,omitempty"`
	// The [inventory state](entity:InventoryState) of the related quantity
	// of items after the adjustment.
	// See [InventoryState](#type-inventorystate) for possible values
	ToState *InventoryState `json:"to_state,omitempty" url:"to_state,omitempty"`
	// The Square-generated ID of the [Location](entity:Location) where the related
	// quantity of items is being tracked before the adjustment. Replaced by
	// `from_location_id` of [InventoryTransfer](entity:InventoryTransfer).
	FromLocationId *string `json:"from_location_id,omitempty" url:"from_location_id,omitempty"`
	// The Square-generated ID of the [Location](entity:Location) where the related
	// quantity of items is being tracked after the adjustment. Replaced by
	// `to_location_id` of [InventoryTransfer](entity:InventoryTransfer).
	ToLocationId *string `json:"to_location_id,omitempty" url:"to_location_id,omitempty"`
	// The Square-generated ID of the [Location](entity:Location) where the related
	// quantity of items is being tracked.
	LocationId *string `json:"location_id,omitempty" url:"location_id,omitempty"`
	// The Square-generated ID of the
	// [CatalogObject](entity:CatalogObject) being tracked.
	CatalogObjectId *string `json:"catalog_object_id,omitempty" url:"catalog_object_id,omitempty"`
	// The [type](entity:CatalogObjectType) of the [CatalogObject](entity:CatalogObject) being tracked.
	//
	// The Inventory API supports setting and reading the `"catalog_object_type": "ITEM_VARIATION"` field value.
	// In addition, it can also read the `"catalog_object_type": "ITEM"` field value that is set by the Square Restaurants app.
	CatalogObjectType *string `json:"catalog_object_type,omitempty" url:"catalog_object_type,omitempty"`
	// The number of items affected by the adjustment as a decimal string.
	// Can support up to 5 digits after the decimal point.
	Quantity *string `json:"quantity,omitempty" url:"quantity,omitempty"`
	// The total price paid for goods associated with the
	// adjustment. Present if and only if `to_state` is `SOLD`. Always
	// non-negative.
	TotalPriceMoney *Money `json:"total_price_money,omitempty" url:"total_price_money,omitempty"`
	// A client-generated RFC 3339-formatted timestamp that indicates when
	// the inventory adjustment took place. For inventory adjustment updates, the `occurred_at`
	// timestamp cannot be older than 24 hours or in the future relative to the
	// time of the request.
	OccurredAt *string `json:"occurred_at,omitempty" url:"occurred_at,omitempty"`
	// An RFC 3339-formatted timestamp that indicates when the inventory adjustment is received.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// Information about the application that caused the
	// inventory adjustment.
	Source *SourceApplication `json:"source,omitempty" url:"source,omitempty"`
	// The Square-generated ID of the [Employee](entity:Employee) responsible for the
	// inventory adjustment.
	EmployeeId *string `json:"employee_id,omitempty" url:"employee_id,omitempty"`
	// The Square-generated ID of the [Team Member](entity:TeamMember) responsible for the
	// inventory adjustment.
	TeamMemberId *string `json:"team_member_id,omitempty" url:"team_member_id,omitempty"`
	// The Square-generated ID of the [Transaction](entity:Transaction) that
	// caused the adjustment. Only relevant for payment-related state
	// transitions.
	TransactionId *string `json:"transaction_id,omitempty" url:"transaction_id,omitempty"`
	// The Square-generated ID of the [Refund](entity:Refund) that
	// caused the adjustment. Only relevant for refund-related state
	// transitions.
	RefundId *string `json:"refund_id,omitempty" url:"refund_id,omitempty"`
	// The Square-generated ID of the purchase order that caused the
	// adjustment. Only relevant for state transitions from the Square for Retail
	// app.
	PurchaseOrderId *string `json:"purchase_order_id,omitempty" url:"purchase_order_id,omitempty"`
	// The Square-generated ID of the goods receipt that caused the
	// adjustment. Only relevant for state transitions from the Square for Retail
	// app.
	GoodsReceiptId *string `json:"goods_receipt_id,omitempty" url:"goods_receipt_id,omitempty"`
	// An adjustment group bundling the related adjustments of item variations through stock conversions in a single inventory event.
	AdjustmentGroup *InventoryAdjustmentGroup `json:"adjustment_group,omitempty" url:"adjustment_group,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (i *InventoryAdjustment) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InventoryAdjustment) UnmarshalJSON(data []byte) error {
	type unmarshaler InventoryAdjustment
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = InventoryAdjustment(value)

	extraProperties, err := core.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties

	i._rawJSON = json.RawMessage(data)
	return nil
}

func (i *InventoryAdjustment) String() string {
	if len(i._rawJSON) > 0 {
		if value, err := core.StringifyJSON(i._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type InventoryAdjustmentGroup struct {
	// A unique ID generated by Square for the
	// `InventoryAdjustmentGroup`.
	Id *string `json:"id,omitempty" url:"id,omitempty"`
	// The inventory adjustment of the composed variation.
	RootAdjustmentId *string `json:"root_adjustment_id,omitempty" url:"root_adjustment_id,omitempty"`
	// Representative `from_state` for adjustments within the group. For example, for a group adjustment from `IN_STOCK` to `SOLD`,
	// there can be two component adjustments in the group: one from `IN_STOCK`to `COMPOSED` and the other one from `COMPOSED` to `SOLD`.
	// Here, the representative `from_state` for the `InventoryAdjustmentGroup` is `IN_STOCK`.
	// See [InventoryState](#type-inventorystate) for possible values
	FromState *InventoryState `json:"from_state,omitempty" url:"from_state,omitempty"`
	// Representative `to_state` for adjustments within group. For example, for a group adjustment from `IN_STOCK` to `SOLD`,
	// the two component adjustments in the group can be from `IN_STOCK` to `COMPOSED` and from `COMPOSED` to `SOLD`.
	// Here, the representative `to_state` of the `InventoryAdjustmentGroup` is `SOLD`.
	// See [InventoryState](#type-inventorystate) for possible values
	ToState *InventoryState `json:"to_state,omitempty" url:"to_state,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (i *InventoryAdjustmentGroup) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InventoryAdjustmentGroup) UnmarshalJSON(data []byte) error {
	type unmarshaler InventoryAdjustmentGroup
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = InventoryAdjustmentGroup(value)

	extraProperties, err := core.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties

	i._rawJSON = json.RawMessage(data)
	return nil
}

func (i *InventoryAdjustmentGroup) String() string {
	if len(i._rawJSON) > 0 {
		if value, err := core.StringifyJSON(i._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

// Indicates whether Square should alert the merchant when the inventory quantity of a CatalogItemVariation is low.
type InventoryAlertType string

const (
	InventoryAlertTypeInventoryAlertTypeDoNotUse InventoryAlertType = "INVENTORY_ALERT_TYPE_DO_NOT_USE"
	InventoryAlertTypeNone                       InventoryAlertType = "NONE"
	InventoryAlertTypeLowQuantity                InventoryAlertType = "LOW_QUANTITY"
)

func NewInventoryAlertTypeFromString(s string) (InventoryAlertType, error) {
	switch s {
	case "INVENTORY_ALERT_TYPE_DO_NOT_USE":
		return InventoryAlertTypeInventoryAlertTypeDoNotUse, nil
	case "NONE":
		return InventoryAlertTypeNone, nil
	case "LOW_QUANTITY":
		return InventoryAlertTypeLowQuantity, nil
	}
	var t InventoryAlertType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (i InventoryAlertType) Ptr() *InventoryAlertType {
	return &i
}

// Represents a single physical count, inventory, adjustment, or transfer
// that is part of the history of inventory changes for a particular
// [CatalogObject](entity:CatalogObject) instance.
type InventoryChange struct {
	// Indicates how the inventory change is applied. See
	// [InventoryChangeType](entity:InventoryChangeType) for all possible values.
	// See [InventoryChangeType](#type-inventorychangetype) for possible values
	Type *InventoryChangeType `json:"type,omitempty" url:"type,omitempty"`
	// Contains details about the physical count when `type` is
	// `PHYSICAL_COUNT`, and is unset for all other change types.
	PhysicalCount *InventoryPhysicalCount `json:"physical_count,omitempty" url:"physical_count,omitempty"`
	// Contains details about the inventory adjustment when `type` is
	// `ADJUSTMENT`, and is unset for all other change types.
	Adjustment *InventoryAdjustment `json:"adjustment,omitempty" url:"adjustment,omitempty"`
	// Contains details about the inventory transfer when `type` is
	// `TRANSFER`, and is unset for all other change types.
	//
	// _Note:_ An [InventoryTransfer](entity:InventoryTransfer) object can only be set in the input to the
	// [BatchChangeInventory](api-endpoint:Inventory-BatchChangeInventory) endpoint when the seller has an active Retail Plus subscription.
	Transfer *InventoryTransfer `json:"transfer,omitempty" url:"transfer,omitempty"`
	// The [CatalogMeasurementUnit](entity:CatalogMeasurementUnit) object representing the catalog measurement unit associated with the inventory change.
	MeasurementUnit *CatalogMeasurementUnit `json:"measurement_unit,omitempty" url:"measurement_unit,omitempty"`
	// The ID of the [CatalogMeasurementUnit](entity:CatalogMeasurementUnit) object representing the catalog measurement unit associated with the inventory change.
	MeasurementUnitId *string `json:"measurement_unit_id,omitempty" url:"measurement_unit_id,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (i *InventoryChange) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InventoryChange) UnmarshalJSON(data []byte) error {
	type unmarshaler InventoryChange
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = InventoryChange(value)

	extraProperties, err := core.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties

	i._rawJSON = json.RawMessage(data)
	return nil
}

func (i *InventoryChange) String() string {
	if len(i._rawJSON) > 0 {
		if value, err := core.StringifyJSON(i._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

// Indicates how the inventory change was applied to a tracked product quantity.
type InventoryChangeType string

const (
	InventoryChangeTypeInventoryChangeTypeDoNotUse InventoryChangeType = "INVENTORY_CHANGE_TYPE_DO_NOT_USE"
	InventoryChangeTypePhysicalCount               InventoryChangeType = "PHYSICAL_COUNT"
	InventoryChangeTypeAdjustment                  InventoryChangeType = "ADJUSTMENT"
	InventoryChangeTypeTransfer                    InventoryChangeType = "TRANSFER"
	InventoryChangeTypeAvailability                InventoryChangeType = "AVAILABILITY"
)

func NewInventoryChangeTypeFromString(s string) (InventoryChangeType, error) {
	switch s {
	case "INVENTORY_CHANGE_TYPE_DO_NOT_USE":
		return InventoryChangeTypeInventoryChangeTypeDoNotUse, nil
	case "PHYSICAL_COUNT":
		return InventoryChangeTypePhysicalCount, nil
	case "ADJUSTMENT":
		return InventoryChangeTypeAdjustment, nil
	case "TRANSFER":
		return InventoryChangeTypeTransfer, nil
	case "AVAILABILITY":
		return InventoryChangeTypeAvailability, nil
	}
	var t InventoryChangeType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (i InventoryChangeType) Ptr() *InventoryChangeType {
	return &i
}

// Represents Square-estimated quantity of items in a particular state at a
// particular seller location based on the known history of physical counts and
// inventory adjustments.
type InventoryCount struct {
	// The Square-generated ID of the
	// [CatalogObject](entity:CatalogObject) being tracked.
	CatalogObjectId *string `json:"catalog_object_id,omitempty" url:"catalog_object_id,omitempty"`
	// The [type](entity:CatalogObjectType) of the [CatalogObject](entity:CatalogObject) being tracked.
	//
	// The Inventory API supports setting and reading the `"catalog_object_type": "ITEM_VARIATION"` field value.
	// In addition, it can also read the `"catalog_object_type": "ITEM"` field value that is set by the Square Restaurants app.
	CatalogObjectType *string `json:"catalog_object_type,omitempty" url:"catalog_object_type,omitempty"`
	// The current [inventory state](entity:InventoryState) for the related
	// quantity of items. Replaced by the `state` field.
	// See [InventoryState](#type-inventorystate) for possible values
	Status *InventoryState `json:"status,omitempty" url:"status,omitempty"`
	// The current [inventory state](entity:InventoryState) for the related
	// quantity of items.
	// See [InventoryState](#type-inventorystate) for possible values
	State *InventoryState `json:"state,omitempty" url:"state,omitempty"`
	// The Square-generated ID of the [Location](entity:Location) where the related
	// quantity of items is being tracked.
	LocationId *string `json:"location_id,omitempty" url:"location_id,omitempty"`
	// The number of items affected by the estimated count as a decimal string.
	// Can support up to 5 digits after the decimal point.
	Quantity *string `json:"quantity,omitempty" url:"quantity,omitempty"`
	// An RFC 3339-formatted timestamp that indicates when the most recent physical count or adjustment affecting
	// the estimated count is received.
	CalculatedAt *string `json:"calculated_at,omitempty" url:"calculated_at,omitempty"`
	// Whether the inventory count is for composed variation (TRUE) or not (FALSE). If true, the inventory count will not be present in the response of
	// any of these endpoints: [BatchChangeInventory](api-endpoint:Inventory-BatchChangeInventory),
	// [BatchRetrieveInventoryChanges](api-endpoint:Inventory-BatchRetrieveInventoryChanges),
	// [BatchRetrieveInventoryCounts](api-endpoint:Inventory-BatchRetrieveInventoryCounts), and
	// [RetrieveInventoryChanges](api-endpoint:Inventory-RetrieveInventoryChanges).
	IsEstimated *bool `json:"is_estimated,omitempty" url:"is_estimated,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (i *InventoryCount) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InventoryCount) UnmarshalJSON(data []byte) error {
	type unmarshaler InventoryCount
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = InventoryCount(value)

	extraProperties, err := core.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties

	i._rawJSON = json.RawMessage(data)
	return nil
}

func (i *InventoryCount) String() string {
	if len(i._rawJSON) > 0 {
		if value, err := core.StringifyJSON(i._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

// Published when the quantity is updated for a
// [CatalogItemVariation](entity:CatalogItemVariation).
type InventoryCountUpdatedWebhook struct {
	// The ID of the target merchant associated with the event.
	MerchantId *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The type of event this represents.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// A unique ID for the webhook event.
	EventId *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// Timestamp of when the webhook event was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// Data associated with the event.
	Data *InventoryCountUpdatedWebhookData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (i *InventoryCountUpdatedWebhook) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InventoryCountUpdatedWebhook) UnmarshalJSON(data []byte) error {
	type unmarshaler InventoryCountUpdatedWebhook
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = InventoryCountUpdatedWebhook(value)

	extraProperties, err := core.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties

	i._rawJSON = json.RawMessage(data)
	return nil
}

func (i *InventoryCountUpdatedWebhook) String() string {
	if len(i._rawJSON) > 0 {
		if value, err := core.StringifyJSON(i._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type InventoryCountUpdatedWebhookData struct {
	// Name of the affected object’s type.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// ID of the affected object.
	Id *string `json:"id,omitempty" url:"id,omitempty"`
	// An object containing fields and values relevant to the event. Is absent if affected object was deleted.
	Object *InventoryCountUpdatedWebhookObject `json:"object,omitempty" url:"object,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (i *InventoryCountUpdatedWebhookData) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InventoryCountUpdatedWebhookData) UnmarshalJSON(data []byte) error {
	type unmarshaler InventoryCountUpdatedWebhookData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = InventoryCountUpdatedWebhookData(value)

	extraProperties, err := core.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties

	i._rawJSON = json.RawMessage(data)
	return nil
}

func (i *InventoryCountUpdatedWebhookData) String() string {
	if len(i._rawJSON) > 0 {
		if value, err := core.StringifyJSON(i._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type InventoryCountUpdatedWebhookObject struct {
	// The inventory counts.
	InventoryCounts []*InventoryCount `json:"inventory_counts,omitempty" url:"inventory_counts,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (i *InventoryCountUpdatedWebhookObject) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InventoryCountUpdatedWebhookObject) UnmarshalJSON(data []byte) error {
	type unmarshaler InventoryCountUpdatedWebhookObject
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = InventoryCountUpdatedWebhookObject(value)

	extraProperties, err := core.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties

	i._rawJSON = json.RawMessage(data)
	return nil
}

func (i *InventoryCountUpdatedWebhookObject) String() string {
	if len(i._rawJSON) > 0 {
		if value, err := core.StringifyJSON(i._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

// Represents the quantity of an item variation that is physically present
// at a specific location, verified by a seller or a seller's employee. For example,
// a physical count might come from an employee counting the item variations on
// hand or from syncing with an external system.
type InventoryPhysicalCount struct {
	// A unique Square-generated ID for the
	// [InventoryPhysicalCount](entity:InventoryPhysicalCount).
	Id *string `json:"id,omitempty" url:"id,omitempty"`
	// An optional ID provided by the application to tie the
	// [InventoryPhysicalCount](entity:InventoryPhysicalCount) to an external
	// system.
	ReferenceId *string `json:"reference_id,omitempty" url:"reference_id,omitempty"`
	// The Square-generated ID of the
	// [CatalogObject](entity:CatalogObject) being tracked.
	CatalogObjectId *string `json:"catalog_object_id,omitempty" url:"catalog_object_id,omitempty"`
	// The [type](entity:CatalogObjectType) of the [CatalogObject](entity:CatalogObject) being tracked.
	//
	// The Inventory API supports setting and reading the `"catalog_object_type": "ITEM_VARIATION"` field value.
	// In addition, it can also read the `"catalog_object_type": "ITEM"` field value that is set by the Square Restaurants app.
	CatalogObjectType *string `json:"catalog_object_type,omitempty" url:"catalog_object_type,omitempty"`
	// The current [inventory state](entity:InventoryState) for the related
	// quantity of items. It is replaced by the `state` field.
	// See [InventoryState](#type-inventorystate) for possible values
	Status *InventoryState `json:"status,omitempty" url:"status,omitempty"`
	// The current [inventory state](entity:InventoryState) for the related
	// quantity of items.
	// See [InventoryState](#type-inventorystate) for possible values
	State *InventoryState `json:"state,omitempty" url:"state,omitempty"`
	// The Square-generated ID of the [Location](entity:Location) where the related
	// quantity of items is being tracked.
	LocationId *string `json:"location_id,omitempty" url:"location_id,omitempty"`
	// The number of items affected by the physical count as a decimal string.
	// The number can support up to 5 digits after the decimal point.
	Quantity *string `json:"quantity,omitempty" url:"quantity,omitempty"`
	// Information about the application with which the
	// physical count is submitted.
	Source *SourceApplication `json:"source,omitempty" url:"source,omitempty"`
	// The Square-generated ID of the [Employee](entity:Employee) responsible for the
	// physical count.
	EmployeeId *string `json:"employee_id,omitempty" url:"employee_id,omitempty"`
	// The Square-generated ID of the [Team Member](entity:TeamMember) responsible for the
	// physical count.
	TeamMemberId *string `json:"team_member_id,omitempty" url:"team_member_id,omitempty"`
	// A client-generated RFC 3339-formatted timestamp that indicates when
	// the physical count was examined. For physical count updates, the `occurred_at`
	// timestamp cannot be older than 24 hours or in the future relative to the
	// time of the request.
	OccurredAt *string `json:"occurred_at,omitempty" url:"occurred_at,omitempty"`
	// An RFC 3339-formatted timestamp that indicates when the physical count is received.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (i *InventoryPhysicalCount) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InventoryPhysicalCount) UnmarshalJSON(data []byte) error {
	type unmarshaler InventoryPhysicalCount
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = InventoryPhysicalCount(value)

	extraProperties, err := core.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties

	i._rawJSON = json.RawMessage(data)
	return nil
}

func (i *InventoryPhysicalCount) String() string {
	if len(i._rawJSON) > 0 {
		if value, err := core.StringifyJSON(i._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

// Indicates the state of a tracked item quantity in the lifecycle of goods.
type InventoryState string

const (
	InventoryStateInventoryStateDoNotUse  InventoryState = "INVENTORY_STATE_DO_NOT_USE"
	InventoryStateCustom                  InventoryState = "CUSTOM"
	InventoryStateInStock                 InventoryState = "IN_STOCK"
	InventoryStateSold                    InventoryState = "SOLD"
	InventoryStateReturnedByCustomer      InventoryState = "RETURNED_BY_CUSTOMER"
	InventoryStateReservedForSale         InventoryState = "RESERVED_FOR_SALE"
	InventoryStateSoldOnline              InventoryState = "SOLD_ONLINE"
	InventoryStateOrderedFromVendor       InventoryState = "ORDERED_FROM_VENDOR"
	InventoryStateReceivedFromVendor      InventoryState = "RECEIVED_FROM_VENDOR"
	InventoryStateInTransitTo             InventoryState = "IN_TRANSIT_TO"
	InventoryStateNone                    InventoryState = "NONE"
	InventoryStateWaste                   InventoryState = "WASTE"
	InventoryStateUnlinkedReturn          InventoryState = "UNLINKED_RETURN"
	InventoryStateComposed                InventoryState = "COMPOSED"
	InventoryStateDecomposed              InventoryState = "DECOMPOSED"
	InventoryStateSupportedByNewerVersion InventoryState = "SUPPORTED_BY_NEWER_VERSION"
)

func NewInventoryStateFromString(s string) (InventoryState, error) {
	switch s {
	case "INVENTORY_STATE_DO_NOT_USE":
		return InventoryStateInventoryStateDoNotUse, nil
	case "CUSTOM":
		return InventoryStateCustom, nil
	case "IN_STOCK":
		return InventoryStateInStock, nil
	case "SOLD":
		return InventoryStateSold, nil
	case "RETURNED_BY_CUSTOMER":
		return InventoryStateReturnedByCustomer, nil
	case "RESERVED_FOR_SALE":
		return InventoryStateReservedForSale, nil
	case "SOLD_ONLINE":
		return InventoryStateSoldOnline, nil
	case "ORDERED_FROM_VENDOR":
		return InventoryStateOrderedFromVendor, nil
	case "RECEIVED_FROM_VENDOR":
		return InventoryStateReceivedFromVendor, nil
	case "IN_TRANSIT_TO":
		return InventoryStateInTransitTo, nil
	case "NONE":
		return InventoryStateNone, nil
	case "WASTE":
		return InventoryStateWaste, nil
	case "UNLINKED_RETURN":
		return InventoryStateUnlinkedReturn, nil
	case "COMPOSED":
		return InventoryStateComposed, nil
	case "DECOMPOSED":
		return InventoryStateDecomposed, nil
	case "SUPPORTED_BY_NEWER_VERSION":
		return InventoryStateSupportedByNewerVersion, nil
	}
	var t InventoryState
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (i InventoryState) Ptr() *InventoryState {
	return &i
}

// Represents the transfer of a quantity of product inventory at a
// particular time from one location to another.
type InventoryTransfer struct {
	// A unique ID generated by Square for the
	// `InventoryTransfer`.
	Id *string `json:"id,omitempty" url:"id,omitempty"`
	// An optional ID provided by the application to tie the
	// `InventoryTransfer` to an external system.
	ReferenceId *string `json:"reference_id,omitempty" url:"reference_id,omitempty"`
	// The [inventory state](entity:InventoryState) for the quantity of
	// items being transferred.
	// See [InventoryState](#type-inventorystate) for possible values
	State *InventoryState `json:"state,omitempty" url:"state,omitempty"`
	// The Square-generated ID of the [Location](entity:Location) where the related
	// quantity of items was tracked before the transfer.
	FromLocationId *string `json:"from_location_id,omitempty" url:"from_location_id,omitempty"`
	// The Square-generated ID of the [Location](entity:Location) where the related
	// quantity of items was tracked after the transfer.
	ToLocationId *string `json:"to_location_id,omitempty" url:"to_location_id,omitempty"`
	// The Square-generated ID of the
	// [CatalogObject](entity:CatalogObject) being tracked.
	CatalogObjectId *string `json:"catalog_object_id,omitempty" url:"catalog_object_id,omitempty"`
	// The [type](entity:CatalogObjectType) of the [CatalogObject](entity:CatalogObject) being tracked.
	//
	// The Inventory API supports setting and reading the `"catalog_object_type": "ITEM_VARIATION"` field value.
	// In addition, it can also read the `"catalog_object_type": "ITEM"` field value that is set by the Square Restaurants app.
	CatalogObjectType *string `json:"catalog_object_type,omitempty" url:"catalog_object_type,omitempty"`
	// The number of items affected by the transfer as a decimal string.
	// Can support up to 5 digits after the decimal point.
	Quantity *string `json:"quantity,omitempty" url:"quantity,omitempty"`
	// A client-generated RFC 3339-formatted timestamp that indicates when
	// the transfer took place. For write actions, the `occurred_at` timestamp
	// cannot be older than 24 hours or in the future relative to the time of the
	// request.
	OccurredAt *string `json:"occurred_at,omitempty" url:"occurred_at,omitempty"`
	// An RFC 3339-formatted timestamp that indicates when Square
	// received the transfer request.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// Information about the application that initiated the
	// inventory transfer.
	Source *SourceApplication `json:"source,omitempty" url:"source,omitempty"`
	// The Square-generated ID of the [Employee](entity:Employee) responsible for the
	// inventory transfer.
	EmployeeId *string `json:"employee_id,omitempty" url:"employee_id,omitempty"`
	// The Square-generated ID of the [Team Member](entity:TeamMember) responsible for the
	// inventory transfer.
	TeamMemberId *string `json:"team_member_id,omitempty" url:"team_member_id,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (i *InventoryTransfer) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InventoryTransfer) UnmarshalJSON(data []byte) error {
	type unmarshaler InventoryTransfer
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = InventoryTransfer(value)

	extraProperties, err := core.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties

	i._rawJSON = json.RawMessage(data)
	return nil
}

func (i *InventoryTransfer) String() string {
	if len(i._rawJSON) > 0 {
		if value, err := core.StringifyJSON(i._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

// The payment methods that customers can use to pay an invoice on the Square-hosted invoice page.
type InvoiceAcceptedPaymentMethods struct {
	// Indicates whether credit card or debit card payments are accepted. The default value is `false`.
	Card *bool `json:"card,omitempty" url:"card,omitempty"`
	// Indicates whether Square gift card payments are accepted. The default value is `false`.
	SquareGiftCard *bool `json:"square_gift_card,omitempty" url:"square_gift_card,omitempty"`
	// Indicates whether bank transfer payments are accepted. The default value is `false`.
	//
	// This option is allowed only for invoices that have a single payment request of type `BALANCE`.
	BankAccount *bool `json:"bank_account,omitempty" url:"bank_account,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (i *InvoiceAcceptedPaymentMethods) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InvoiceAcceptedPaymentMethods) UnmarshalJSON(data []byte) error {
	type unmarshaler InvoiceAcceptedPaymentMethods
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = InvoiceAcceptedPaymentMethods(value)

	extraProperties, err := core.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties

	i._rawJSON = json.RawMessage(data)
	return nil
}

func (i *InvoiceAcceptedPaymentMethods) String() string {
	if len(i._rawJSON) > 0 {
		if value, err := core.StringifyJSON(i._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

// Indicates the automatic payment method for an [invoice payment request](entity:InvoicePaymentRequest).
type InvoiceAutomaticPaymentSource string

const (
	InvoiceAutomaticPaymentSourceInvoiceAutomaticPaymentSourceDoNotUse InvoiceAutomaticPaymentSource = "INVOICE_AUTOMATIC_PAYMENT_SOURCE_DO_NOT_USE"
	InvoiceAutomaticPaymentSourceNone                                  InvoiceAutomaticPaymentSource = "NONE"
	InvoiceAutomaticPaymentSourceCardOnFile                            InvoiceAutomaticPaymentSource = "CARD_ON_FILE"
	InvoiceAutomaticPaymentSourceBankOnFile                            InvoiceAutomaticPaymentSource = "BANK_ON_FILE"
)

func NewInvoiceAutomaticPaymentSourceFromString(s string) (InvoiceAutomaticPaymentSource, error) {
	switch s {
	case "INVOICE_AUTOMATIC_PAYMENT_SOURCE_DO_NOT_USE":
		return InvoiceAutomaticPaymentSourceInvoiceAutomaticPaymentSourceDoNotUse, nil
	case "NONE":
		return InvoiceAutomaticPaymentSourceNone, nil
	case "CARD_ON_FILE":
		return InvoiceAutomaticPaymentSourceCardOnFile, nil
	case "BANK_ON_FILE":
		return InvoiceAutomaticPaymentSourceBankOnFile, nil
	}
	var t InvoiceAutomaticPaymentSource
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (i InvoiceAutomaticPaymentSource) Ptr() *InvoiceAutomaticPaymentSource {
	return &i
}

// Published when an [Invoice](entity:Invoice) is canceled.
type InvoiceCanceledWebhook struct {
	// The ID of the target merchant associated with the event.
	MerchantId *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The type of event this represents, `"invoice.canceled"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// A unique ID for the webhook event.
	EventId *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// Timestamp of when the webhook event was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// Data associated with the event.
	Data *InvoiceCanceledWebhookData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (i *InvoiceCanceledWebhook) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InvoiceCanceledWebhook) UnmarshalJSON(data []byte) error {
	type unmarshaler InvoiceCanceledWebhook
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = InvoiceCanceledWebhook(value)

	extraProperties, err := core.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties

	i._rawJSON = json.RawMessage(data)
	return nil
}

func (i *InvoiceCanceledWebhook) String() string {
	if len(i._rawJSON) > 0 {
		if value, err := core.StringifyJSON(i._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type InvoiceCanceledWebhookData struct {
	// Name of the affected object’s type, `"invoice"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// ID of the affected invoice.
	Id *string `json:"id,omitempty" url:"id,omitempty"`
	// An object containing the canceled invoice.
	Object *InvoiceCanceledWebhookObject `json:"object,omitempty" url:"object,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (i *InvoiceCanceledWebhookData) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InvoiceCanceledWebhookData) UnmarshalJSON(data []byte) error {
	type unmarshaler InvoiceCanceledWebhookData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = InvoiceCanceledWebhookData(value)

	extraProperties, err := core.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties

	i._rawJSON = json.RawMessage(data)
	return nil
}

func (i *InvoiceCanceledWebhookData) String() string {
	if len(i._rawJSON) > 0 {
		if value, err := core.StringifyJSON(i._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type InvoiceCanceledWebhookObject struct {
	// The related invoice.
	Invoice *Invoice `json:"invoice,omitempty" url:"invoice,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (i *InvoiceCanceledWebhookObject) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InvoiceCanceledWebhookObject) UnmarshalJSON(data []byte) error {
	type unmarshaler InvoiceCanceledWebhookObject
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = InvoiceCanceledWebhookObject(value)

	extraProperties, err := core.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties

	i._rawJSON = json.RawMessage(data)
	return nil
}

func (i *InvoiceCanceledWebhookObject) String() string {
	if len(i._rawJSON) > 0 {
		if value, err := core.StringifyJSON(i._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

// Published when an [Invoice](entity:Invoice) is created.
type InvoiceCreatedWebhook struct {
	// The ID of the target merchant associated with the event.
	MerchantId *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The type of event this represents, `"invoice.created"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// A unique ID for the webhook event.
	EventId *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// Timestamp of when the webhook event was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// Data associated with the event.
	Data *InvoiceCreatedWebhookData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (i *InvoiceCreatedWebhook) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InvoiceCreatedWebhook) UnmarshalJSON(data []byte) error {
	type unmarshaler InvoiceCreatedWebhook
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = InvoiceCreatedWebhook(value)

	extraProperties, err := core.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties

	i._rawJSON = json.RawMessage(data)
	return nil
}

func (i *InvoiceCreatedWebhook) String() string {
	if len(i._rawJSON) > 0 {
		if value, err := core.StringifyJSON(i._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type InvoiceCreatedWebhookData struct {
	// Name of the affected object’s type, `"invoice"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// ID of the affected invoice.
	Id *string `json:"id,omitempty" url:"id,omitempty"`
	// An object containing the created invoice.
	Object *InvoiceCreatedWebhookObject `json:"object,omitempty" url:"object,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (i *InvoiceCreatedWebhookData) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InvoiceCreatedWebhookData) UnmarshalJSON(data []byte) error {
	type unmarshaler InvoiceCreatedWebhookData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = InvoiceCreatedWebhookData(value)

	extraProperties, err := core.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties

	i._rawJSON = json.RawMessage(data)
	return nil
}

func (i *InvoiceCreatedWebhookData) String() string {
	if len(i._rawJSON) > 0 {
		if value, err := core.StringifyJSON(i._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type InvoiceCreatedWebhookObject struct {
	// The related invoice.
	Invoice *Invoice `json:"invoice,omitempty" url:"invoice,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (i *InvoiceCreatedWebhookObject) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InvoiceCreatedWebhookObject) UnmarshalJSON(data []byte) error {
	type unmarshaler InvoiceCreatedWebhookObject
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = InvoiceCreatedWebhookObject(value)

	extraProperties, err := core.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties

	i._rawJSON = json.RawMessage(data)
	return nil
}

func (i *InvoiceCreatedWebhookObject) String() string {
	if len(i._rawJSON) > 0 {
		if value, err := core.StringifyJSON(i._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

// An additional seller-defined and customer-facing field to include on the invoice. For more information,
// see [Custom fields](https://developer.squareup.com/docs/invoices-api/overview#custom-fields).
//
// Adding custom fields to an invoice requires an
// [Invoices Plus subscription](https://developer.squareup.com/docs/invoices-api/overview#invoices-plus-subscription).
type InvoiceCustomField struct {
	// The label or title of the custom field. This field is required for a custom field.
	Label *string `json:"label,omitempty" url:"label,omitempty"`
	// The text of the custom field. If omitted, only the label is rendered.
	Value *string `json:"value,omitempty" url:"value,omitempty"`
	// The location of the custom field on the invoice. This field is required for a custom field.
	// See [InvoiceCustomFieldPlacement](#type-invoicecustomfieldplacement) for possible values
	Placement *InvoiceCustomFieldPlacement `json:"placement,omitempty" url:"placement,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (i *InvoiceCustomField) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InvoiceCustomField) UnmarshalJSON(data []byte) error {
	type unmarshaler InvoiceCustomField
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = InvoiceCustomField(value)

	extraProperties, err := core.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties

	i._rawJSON = json.RawMessage(data)
	return nil
}

func (i *InvoiceCustomField) String() string {
	if len(i._rawJSON) > 0 {
		if value, err := core.StringifyJSON(i._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

// Indicates where to render a custom field on the Square-hosted invoice page and in emailed or PDF
// copies of the invoice.
type InvoiceCustomFieldPlacement string

const (
	InvoiceCustomFieldPlacementUnknownPlacementDoNotUse InvoiceCustomFieldPlacement = "UNKNOWN_PLACEMENT_DO_NOT_USE"
	InvoiceCustomFieldPlacementAboveLineItems           InvoiceCustomFieldPlacement = "ABOVE_LINE_ITEMS"
	InvoiceCustomFieldPlacementBelowLineItems           InvoiceCustomFieldPlacement = "BELOW_LINE_ITEMS"
)

func NewInvoiceCustomFieldPlacementFromString(s string) (InvoiceCustomFieldPlacement, error) {
	switch s {
	case "UNKNOWN_PLACEMENT_DO_NOT_USE":
		return InvoiceCustomFieldPlacementUnknownPlacementDoNotUse, nil
	case "ABOVE_LINE_ITEMS":
		return InvoiceCustomFieldPlacementAboveLineItems, nil
	case "BELOW_LINE_ITEMS":
		return InvoiceCustomFieldPlacementBelowLineItems, nil
	}
	var t InvoiceCustomFieldPlacement
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (i InvoiceCustomFieldPlacement) Ptr() *InvoiceCustomFieldPlacement {
	return &i
}

// Published when a draft [Invoice](entity:Invoice) is deleted.
type InvoiceDeletedWebhook struct {
	// The ID of the target merchant associated with the event.
	MerchantId *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The type of event this represents, `"invoice.deleted"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// A unique ID for the webhook event.
	EventId *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// Timestamp of when the webhook event was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// Data associated with the event.
	Data *InvoiceDeletedWebhookData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (i *InvoiceDeletedWebhook) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InvoiceDeletedWebhook) UnmarshalJSON(data []byte) error {
	type unmarshaler InvoiceDeletedWebhook
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = InvoiceDeletedWebhook(value)

	extraProperties, err := core.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties

	i._rawJSON = json.RawMessage(data)
	return nil
}

func (i *InvoiceDeletedWebhook) String() string {
	if len(i._rawJSON) > 0 {
		if value, err := core.StringifyJSON(i._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type InvoiceDeletedWebhookData struct {
	// Name of the affected object’s type, `"invoice"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// ID of the affected invoice.
	Id *string `json:"id,omitempty" url:"id,omitempty"`
	// Indicates that the invoice was deleted.
	Deleted *bool `json:"deleted,omitempty" url:"deleted,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (i *InvoiceDeletedWebhookData) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InvoiceDeletedWebhookData) UnmarshalJSON(data []byte) error {
	type unmarshaler InvoiceDeletedWebhookData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = InvoiceDeletedWebhookData(value)

	extraProperties, err := core.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties

	i._rawJSON = json.RawMessage(data)
	return nil
}

func (i *InvoiceDeletedWebhookData) String() string {
	if len(i._rawJSON) > 0 {
		if value, err := core.StringifyJSON(i._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

// Indicates how Square delivers the [invoice](entity:Invoice) to the customer.
type InvoiceDeliveryMethod string

const (
	InvoiceDeliveryMethodInvoiceDeliveryMethodDoNotUse InvoiceDeliveryMethod = "INVOICE_DELIVERY_METHOD_DO_NOT_USE"
	InvoiceDeliveryMethodEmail                         InvoiceDeliveryMethod = "EMAIL"
	InvoiceDeliveryMethodShareManually                 InvoiceDeliveryMethod = "SHARE_MANUALLY"
	InvoiceDeliveryMethodSms                           InvoiceDeliveryMethod = "SMS"
)

func NewInvoiceDeliveryMethodFromString(s string) (InvoiceDeliveryMethod, error) {
	switch s {
	case "INVOICE_DELIVERY_METHOD_DO_NOT_USE":
		return InvoiceDeliveryMethodInvoiceDeliveryMethodDoNotUse, nil
	case "EMAIL":
		return InvoiceDeliveryMethodEmail, nil
	case "SHARE_MANUALLY":
		return InvoiceDeliveryMethodShareManually, nil
	case "SMS":
		return InvoiceDeliveryMethodSms, nil
	}
	var t InvoiceDeliveryMethod
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (i InvoiceDeliveryMethod) Ptr() *InvoiceDeliveryMethod {
	return &i
}

// Describes query filters to apply.
type InvoiceFilter struct {
	// Limits the search to the specified locations. A location is required.
	// In the current implementation, only one location can be specified.
	LocationIds []string `json:"location_ids,omitempty" url:"location_ids,omitempty"`
	// Limits the search to the specified customers, within the specified locations.
	// Specifying a customer is optional. In the current implementation,
	// a maximum of one customer can be specified.
	CustomerIds []string `json:"customer_ids,omitempty" url:"customer_ids,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (i *InvoiceFilter) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InvoiceFilter) UnmarshalJSON(data []byte) error {
	type unmarshaler InvoiceFilter
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = InvoiceFilter(value)

	extraProperties, err := core.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties

	i._rawJSON = json.RawMessage(data)
	return nil
}

func (i *InvoiceFilter) String() string {
	if len(i._rawJSON) > 0 {
		if value, err := core.StringifyJSON(i._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

// Published when a payment that is associated with an [Invoice](entity:Invoice) is completed.
type InvoicePaymentMadeWebhook struct {
	// The ID of the target merchant associated with the event.
	MerchantId *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The type of event this represents, `"invoice.payment_made"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// A unique ID for the webhook event.
	EventId *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// Timestamp of when the webhook event was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// Data associated with the event.
	Data *InvoicePaymentMadeWebhookData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (i *InvoicePaymentMadeWebhook) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InvoicePaymentMadeWebhook) UnmarshalJSON(data []byte) error {
	type unmarshaler InvoicePaymentMadeWebhook
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = InvoicePaymentMadeWebhook(value)

	extraProperties, err := core.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties

	i._rawJSON = json.RawMessage(data)
	return nil
}

func (i *InvoicePaymentMadeWebhook) String() string {
	if len(i._rawJSON) > 0 {
		if value, err := core.StringifyJSON(i._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type InvoicePaymentMadeWebhookData struct {
	// Name of the affected object’s type, `"invoice"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// ID of the affected invoice.
	Id *string `json:"id,omitempty" url:"id,omitempty"`
	// An object containing the invoice that was paid.
	Object *InvoicePaymentMadeWebhookObject `json:"object,omitempty" url:"object,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (i *InvoicePaymentMadeWebhookData) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InvoicePaymentMadeWebhookData) UnmarshalJSON(data []byte) error {
	type unmarshaler InvoicePaymentMadeWebhookData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = InvoicePaymentMadeWebhookData(value)

	extraProperties, err := core.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties

	i._rawJSON = json.RawMessage(data)
	return nil
}

func (i *InvoicePaymentMadeWebhookData) String() string {
	if len(i._rawJSON) > 0 {
		if value, err := core.StringifyJSON(i._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type InvoicePaymentMadeWebhookObject struct {
	// The related invoice.
	Invoice *Invoice `json:"invoice,omitempty" url:"invoice,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (i *InvoicePaymentMadeWebhookObject) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InvoicePaymentMadeWebhookObject) UnmarshalJSON(data []byte) error {
	type unmarshaler InvoicePaymentMadeWebhookObject
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = InvoicePaymentMadeWebhookObject(value)

	extraProperties, err := core.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties

	i._rawJSON = json.RawMessage(data)
	return nil
}

func (i *InvoicePaymentMadeWebhookObject) String() string {
	if len(i._rawJSON) > 0 {
		if value, err := core.StringifyJSON(i._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

// Describes a payment request reminder (automatic notification) that Square sends
// to the customer. You configure a reminder relative to the payment request
// `due_date`.
type InvoicePaymentReminder struct {
	// A Square-assigned ID that uniquely identifies the reminder within the
	// `InvoicePaymentRequest`.
	Uid *string `json:"uid,omitempty" url:"uid,omitempty"`
	// The number of days before (a negative number) or after (a positive number)
	// the payment request `due_date` when the reminder is sent. For example, -3 indicates that
	// the reminder should be sent 3 days before the payment request `due_date`.
	RelativeScheduledDays *int `json:"relative_scheduled_days,omitempty" url:"relative_scheduled_days,omitempty"`
	// The reminder message.
	Message *string `json:"message,omitempty" url:"message,omitempty"`
	// The status of the reminder.
	// See [InvoicePaymentReminderStatus](#type-invoicepaymentreminderstatus) for possible values
	Status *InvoicePaymentReminderStatus `json:"status,omitempty" url:"status,omitempty"`
	// If sent, the timestamp when the reminder was sent, in RFC 3339 format.
	SentAt *string `json:"sent_at,omitempty" url:"sent_at,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (i *InvoicePaymentReminder) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InvoicePaymentReminder) UnmarshalJSON(data []byte) error {
	type unmarshaler InvoicePaymentReminder
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = InvoicePaymentReminder(value)

	extraProperties, err := core.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties

	i._rawJSON = json.RawMessage(data)
	return nil
}

func (i *InvoicePaymentReminder) String() string {
	if len(i._rawJSON) > 0 {
		if value, err := core.StringifyJSON(i._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

// The status of a payment request reminder.
type InvoicePaymentReminderStatus string

const (
	InvoicePaymentReminderStatusInvoicePaymentReminderStatusDoNotUse InvoicePaymentReminderStatus = "INVOICE_PAYMENT_REMINDER_STATUS_DO_NOT_USE"
	InvoicePaymentReminderStatusPending                              InvoicePaymentReminderStatus = "PENDING"
	InvoicePaymentReminderStatusNotApplicable                        InvoicePaymentReminderStatus = "NOT_APPLICABLE"
	InvoicePaymentReminderStatusSent                                 InvoicePaymentReminderStatus = "SENT"
)

func NewInvoicePaymentReminderStatusFromString(s string) (InvoicePaymentReminderStatus, error) {
	switch s {
	case "INVOICE_PAYMENT_REMINDER_STATUS_DO_NOT_USE":
		return InvoicePaymentReminderStatusInvoicePaymentReminderStatusDoNotUse, nil
	case "PENDING":
		return InvoicePaymentReminderStatusPending, nil
	case "NOT_APPLICABLE":
		return InvoicePaymentReminderStatusNotApplicable, nil
	case "SENT":
		return InvoicePaymentReminderStatusSent, nil
	}
	var t InvoicePaymentReminderStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (i InvoicePaymentReminderStatus) Ptr() *InvoicePaymentReminderStatus {
	return &i
}

// Represents a payment request for an [invoice](entity:Invoice). Invoices can specify a maximum
// of 13 payment requests, with up to 12 `INSTALLMENT` request types. For more information,
// see [Configuring payment requests](https://developer.squareup.com/docs/invoices-api/create-publish-invoices#payment-requests).
//
// Adding `INSTALLMENT` payment requests to an invoice requires an
// [Invoices Plus subscription](https://developer.squareup.com/docs/invoices-api/overview#invoices-plus-subscription).
type InvoicePaymentRequest struct {
	// The Square-generated ID of the payment request in an [invoice](entity:Invoice).
	Uid *string `json:"uid,omitempty" url:"uid,omitempty"`
	// Indicates how Square processes the payment request. DEPRECATED at version 2021-01-21. Replaced by the
	// `Invoice.delivery_method` and `InvoicePaymentRequest.automatic_payment_source` fields.
	//
	// One of the following is required when creating an invoice:
	//
	//   - (Recommended) The `delivery_method` field of the invoice. To configure an automatic payment, the
	//     `automatic_payment_source` field of the payment request is also required.
	//   - This `request_method` field. Note that `invoice` objects returned in responses do not include `request_method`.
	//     See [InvoiceRequestMethod](#type-invoicerequestmethod) for possible values
	RequestMethod *InvoiceRequestMethod `json:"request_method,omitempty" url:"request_method,omitempty"`
	// Identifies the payment request type. This type defines how the payment request amount is determined.
	// This field is required to create a payment request.
	// See [InvoiceRequestType](#type-invoicerequesttype) for possible values
	RequestType *InvoiceRequestType `json:"request_type,omitempty" url:"request_type,omitempty"`
	// The due date (in the invoice's time zone) for the payment request, in `YYYY-MM-DD` format. This field
	// is required to create a payment request. If an `automatic_payment_source` is defined for the request, Square
	// charges the payment source on this date.
	//
	// After this date, the invoice becomes overdue. For example, a payment `due_date` of 2021-03-09 with a `timezone`
	// of America/Los_Angeles becomes overdue at midnight on March 9 in America/Los_Angeles (which equals a UTC
	// timestamp of 2021-03-10T08:00:00Z).
	DueDate *string `json:"due_date,omitempty" url:"due_date,omitempty"`
	// If the payment request specifies `DEPOSIT` or `INSTALLMENT` as the `request_type`,
	// this indicates the request amount.
	// You cannot specify this when `request_type` is `BALANCE` or when the
	// payment request includes the `percentage_requested` field.
	FixedAmountRequestedMoney *Money `json:"fixed_amount_requested_money,omitempty" url:"fixed_amount_requested_money,omitempty"`
	// Specifies the amount for the payment request in percentage:
	//
	//   - When the payment `request_type` is `DEPOSIT`, it is the percentage of the order's total amount.
	//   - When the payment `request_type` is `INSTALLMENT`, it is the percentage of the order's total less
	//     the deposit, if requested. The sum of the `percentage_requested` in all installment
	//     payment requests must be equal to 100.
	//
	// You cannot specify this when the payment `request_type` is `BALANCE` or when the
	// payment request specifies the `fixed_amount_requested_money` field.
	PercentageRequested *string `json:"percentage_requested,omitempty" url:"percentage_requested,omitempty"`
	// If set to true, the Square-hosted invoice page (the `public_url` field of the invoice)
	// provides a place for the customer to pay a tip.
	//
	// This field is allowed only on the final payment request
	// and the payment `request_type` must be `BALANCE` or `INSTALLMENT`.
	TippingEnabled *bool `json:"tipping_enabled,omitempty" url:"tipping_enabled,omitempty"`
	// The payment method for an automatic payment.
	//
	// The default value is `NONE`.
	// See [InvoiceAutomaticPaymentSource](#type-invoiceautomaticpaymentsource) for possible values
	AutomaticPaymentSource *InvoiceAutomaticPaymentSource `json:"automatic_payment_source,omitempty" url:"automatic_payment_source,omitempty"`
	// The ID of the credit or debit card on file to charge for the payment request. To get the cards on file for a customer,
	// call [ListCards](api-endpoint:Cards-ListCards) and include the `customer_id` of the invoice recipient.
	CardId *string `json:"card_id,omitempty" url:"card_id,omitempty"`
	// A list of one or more reminders to send for the payment request.
	Reminders []*InvoicePaymentReminder `json:"reminders,omitempty" url:"reminders,omitempty"`
	// The amount of the payment request, computed using the order amount and information from the various payment
	// request fields (`request_type`, `fixed_amount_requested_money`, and `percentage_requested`).
	ComputedAmountMoney *Money `json:"computed_amount_money,omitempty" url:"computed_amount_money,omitempty"`
	// The amount of money already paid for the specific payment request.
	// This amount might include a rounding adjustment if the most recent invoice payment
	// was in cash in a currency that rounds cash payments (such as, `CAD` or `AUD`).
	TotalCompletedAmountMoney *Money `json:"total_completed_amount_money,omitempty" url:"total_completed_amount_money,omitempty"`
	// If the most recent payment was a cash payment
	// in a currency that rounds cash payments (such as, `CAD` or `AUD`) and the payment
	// is rounded from `computed_amount_money` in the payment request, then this
	// field specifies the rounding adjustment applied. This amount
	// might be negative.
	RoundingAdjustmentIncludedMoney *Money `json:"rounding_adjustment_included_money,omitempty" url:"rounding_adjustment_included_money,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (i *InvoicePaymentRequest) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InvoicePaymentRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler InvoicePaymentRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = InvoicePaymentRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties

	i._rawJSON = json.RawMessage(data)
	return nil
}

func (i *InvoicePaymentRequest) String() string {
	if len(i._rawJSON) > 0 {
		if value, err := core.StringifyJSON(i._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

// Published when an [Invoice](entity:Invoice) transitions from a draft to a non-draft status.
type InvoicePublishedWebhook struct {
	// The ID of the target merchant associated with the event.
	MerchantId *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The type of event this represents, `"invoice.published"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// A unique ID for the webhook event.
	EventId *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// Timestamp of when the webhook event was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// Data associated with the event.
	Data *InvoicePublishedWebhookData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (i *InvoicePublishedWebhook) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InvoicePublishedWebhook) UnmarshalJSON(data []byte) error {
	type unmarshaler InvoicePublishedWebhook
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = InvoicePublishedWebhook(value)

	extraProperties, err := core.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties

	i._rawJSON = json.RawMessage(data)
	return nil
}

func (i *InvoicePublishedWebhook) String() string {
	if len(i._rawJSON) > 0 {
		if value, err := core.StringifyJSON(i._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type InvoicePublishedWebhookData struct {
	// Name of the affected object’s type, `"invoice"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// ID of the affected invoice.
	Id *string `json:"id,omitempty" url:"id,omitempty"`
	// An object containing the published invoice.
	Object *InvoicePublishedWebhookObject `json:"object,omitempty" url:"object,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (i *InvoicePublishedWebhookData) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InvoicePublishedWebhookData) UnmarshalJSON(data []byte) error {
	type unmarshaler InvoicePublishedWebhookData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = InvoicePublishedWebhookData(value)

	extraProperties, err := core.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties

	i._rawJSON = json.RawMessage(data)
	return nil
}

func (i *InvoicePublishedWebhookData) String() string {
	if len(i._rawJSON) > 0 {
		if value, err := core.StringifyJSON(i._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type InvoicePublishedWebhookObject struct {
	// The related invoice.
	Invoice *Invoice `json:"invoice,omitempty" url:"invoice,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (i *InvoicePublishedWebhookObject) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InvoicePublishedWebhookObject) UnmarshalJSON(data []byte) error {
	type unmarshaler InvoicePublishedWebhookObject
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = InvoicePublishedWebhookObject(value)

	extraProperties, err := core.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties

	i._rawJSON = json.RawMessage(data)
	return nil
}

func (i *InvoicePublishedWebhookObject) String() string {
	if len(i._rawJSON) > 0 {
		if value, err := core.StringifyJSON(i._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

// Represents a snapshot of customer data. This object stores customer data that is displayed on the invoice
// and that Square uses to deliver the invoice.
//
// When you provide a customer ID for a draft invoice, Square retrieves the associated customer profile and populates
// the remaining `InvoiceRecipient` fields. You cannot update these fields after the invoice is published.
// Square updates the customer ID in response to a merge operation, but does not update other fields.
type InvoiceRecipient struct {
	// The ID of the customer. This is the customer profile ID that
	// you provide when creating a draft invoice.
	CustomerId *string `json:"customer_id,omitempty" url:"customer_id,omitempty"`
	// The recipient's given (that is, first) name.
	GivenName *string `json:"given_name,omitempty" url:"given_name,omitempty"`
	// The recipient's family (that is, last) name.
	FamilyName *string `json:"family_name,omitempty" url:"family_name,omitempty"`
	// The recipient's email address.
	EmailAddress *string `json:"email_address,omitempty" url:"email_address,omitempty"`
	// The recipient's physical address.
	Address *Address `json:"address,omitempty" url:"address,omitempty"`
	// The recipient's phone number.
	PhoneNumber *string `json:"phone_number,omitempty" url:"phone_number,omitempty"`
	// The name of the recipient's company.
	CompanyName *string `json:"company_name,omitempty" url:"company_name,omitempty"`
	// The recipient's tax IDs. The country of the seller account determines whether this field
	// is available for the customer. For more information, see [Invoice recipient tax IDs](https://developer.squareup.com/docs/invoices-api/overview#recipient-tax-ids).
	TaxIds *InvoiceRecipientTaxIds `json:"tax_ids,omitempty" url:"tax_ids,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (i *InvoiceRecipient) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InvoiceRecipient) UnmarshalJSON(data []byte) error {
	type unmarshaler InvoiceRecipient
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = InvoiceRecipient(value)

	extraProperties, err := core.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties

	i._rawJSON = json.RawMessage(data)
	return nil
}

func (i *InvoiceRecipient) String() string {
	if len(i._rawJSON) > 0 {
		if value, err := core.StringifyJSON(i._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

// Represents the tax IDs for an invoice recipient. The country of the seller account determines
// whether the corresponding `tax_ids` field is available for the customer. For more information,
// see [Invoice recipient tax IDs](https://developer.squareup.com/docs/invoices-api/overview#recipient-tax-ids).
type InvoiceRecipientTaxIds struct {
	// The EU VAT identification number for the invoice recipient. For example, `IE3426675K`.
	EuVat *string `json:"eu_vat,omitempty" url:"eu_vat,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (i *InvoiceRecipientTaxIds) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InvoiceRecipientTaxIds) UnmarshalJSON(data []byte) error {
	type unmarshaler InvoiceRecipientTaxIds
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = InvoiceRecipientTaxIds(value)

	extraProperties, err := core.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties

	i._rawJSON = json.RawMessage(data)
	return nil
}

func (i *InvoiceRecipientTaxIds) String() string {
	if len(i._rawJSON) > 0 {
		if value, err := core.StringifyJSON(i._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

// Published when a refund is applied towards a payment of an [Invoice](entity:Invoice).
type InvoiceRefundedWebhook struct {
	// The ID of the target merchant associated with the event.
	MerchantId *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The type of event this represents, `"invoice.refunded"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// A unique ID for the webhook event.
	EventId *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// Timestamp of when the webhook event was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// Data associated with the event.
	Data *InvoiceRefundedWebhookData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (i *InvoiceRefundedWebhook) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InvoiceRefundedWebhook) UnmarshalJSON(data []byte) error {
	type unmarshaler InvoiceRefundedWebhook
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = InvoiceRefundedWebhook(value)

	extraProperties, err := core.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties

	i._rawJSON = json.RawMessage(data)
	return nil
}

func (i *InvoiceRefundedWebhook) String() string {
	if len(i._rawJSON) > 0 {
		if value, err := core.StringifyJSON(i._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type InvoiceRefundedWebhookData struct {
	// Name of the affected object’s type, `"invoice"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// ID of the affected invoice.
	Id *string `json:"id,omitempty" url:"id,omitempty"`
	// An object containing the refunded invoice.
	Object *InvoiceRefundedWebhookObject `json:"object,omitempty" url:"object,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (i *InvoiceRefundedWebhookData) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InvoiceRefundedWebhookData) UnmarshalJSON(data []byte) error {
	type unmarshaler InvoiceRefundedWebhookData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = InvoiceRefundedWebhookData(value)

	extraProperties, err := core.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties

	i._rawJSON = json.RawMessage(data)
	return nil
}

func (i *InvoiceRefundedWebhookData) String() string {
	if len(i._rawJSON) > 0 {
		if value, err := core.StringifyJSON(i._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type InvoiceRefundedWebhookObject struct {
	// The related invoice.
	Invoice *Invoice `json:"invoice,omitempty" url:"invoice,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (i *InvoiceRefundedWebhookObject) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InvoiceRefundedWebhookObject) UnmarshalJSON(data []byte) error {
	type unmarshaler InvoiceRefundedWebhookObject
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = InvoiceRefundedWebhookObject(value)

	extraProperties, err := core.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties

	i._rawJSON = json.RawMessage(data)
	return nil
}

func (i *InvoiceRefundedWebhookObject) String() string {
	if len(i._rawJSON) > 0 {
		if value, err := core.StringifyJSON(i._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

// Specifies the action for Square to take for processing the invoice. For example,
// email the invoice, charge a customer's card on file, or do nothing. DEPRECATED at
// version 2021-01-21. The corresponding `request_method` field is replaced by the
// `Invoice.delivery_method` and `InvoicePaymentRequest.automatic_payment_source` fields.
type InvoiceRequestMethod string

const (
	InvoiceRequestMethodInvoiceRequestMethodDoNotUse InvoiceRequestMethod = "INVOICE_REQUEST_METHOD_DO_NOT_USE"
	InvoiceRequestMethodEmail                        InvoiceRequestMethod = "EMAIL"
	InvoiceRequestMethodChargeCardOnFile             InvoiceRequestMethod = "CHARGE_CARD_ON_FILE"
	InvoiceRequestMethodShareManually                InvoiceRequestMethod = "SHARE_MANUALLY"
	InvoiceRequestMethodChargeBankOnFile             InvoiceRequestMethod = "CHARGE_BANK_ON_FILE"
	InvoiceRequestMethodSms                          InvoiceRequestMethod = "SMS"
	InvoiceRequestMethodSmsChargeCardOnFile          InvoiceRequestMethod = "SMS_CHARGE_CARD_ON_FILE"
	InvoiceRequestMethodSmsChargeBankOnFile          InvoiceRequestMethod = "SMS_CHARGE_BANK_ON_FILE"
)

func NewInvoiceRequestMethodFromString(s string) (InvoiceRequestMethod, error) {
	switch s {
	case "INVOICE_REQUEST_METHOD_DO_NOT_USE":
		return InvoiceRequestMethodInvoiceRequestMethodDoNotUse, nil
	case "EMAIL":
		return InvoiceRequestMethodEmail, nil
	case "CHARGE_CARD_ON_FILE":
		return InvoiceRequestMethodChargeCardOnFile, nil
	case "SHARE_MANUALLY":
		return InvoiceRequestMethodShareManually, nil
	case "CHARGE_BANK_ON_FILE":
		return InvoiceRequestMethodChargeBankOnFile, nil
	case "SMS":
		return InvoiceRequestMethodSms, nil
	case "SMS_CHARGE_CARD_ON_FILE":
		return InvoiceRequestMethodSmsChargeCardOnFile, nil
	case "SMS_CHARGE_BANK_ON_FILE":
		return InvoiceRequestMethodSmsChargeBankOnFile, nil
	}
	var t InvoiceRequestMethod
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (i InvoiceRequestMethod) Ptr() *InvoiceRequestMethod {
	return &i
}

// Indicates the type of the payment request. For more information, see
// [Configuring payment requests](https://developer.squareup.com/docs/invoices-api/create-publish-invoices#payment-requests).
type InvoiceRequestType string

const (
	InvoiceRequestTypeInvoiceRequestTypeDoNotUse InvoiceRequestType = "INVOICE_REQUEST_TYPE_DO_NOT_USE"
	InvoiceRequestTypeBalance                    InvoiceRequestType = "BALANCE"
	InvoiceRequestTypeDeposit                    InvoiceRequestType = "DEPOSIT"
	InvoiceRequestTypeInstallment                InvoiceRequestType = "INSTALLMENT"
)

func NewInvoiceRequestTypeFromString(s string) (InvoiceRequestType, error) {
	switch s {
	case "INVOICE_REQUEST_TYPE_DO_NOT_USE":
		return InvoiceRequestTypeInvoiceRequestTypeDoNotUse, nil
	case "BALANCE":
		return InvoiceRequestTypeBalance, nil
	case "DEPOSIT":
		return InvoiceRequestTypeDeposit, nil
	case "INSTALLMENT":
		return InvoiceRequestTypeInstallment, nil
	}
	var t InvoiceRequestType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (i InvoiceRequestType) Ptr() *InvoiceRequestType {
	return &i
}

// Published when an automatic scheduled payment for an [Invoice](entity:Invoice) has failed.
type InvoiceScheduledChargeFailedWebhook struct {
	// The ID of the target merchant associated with the event.
	MerchantId *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The type of event this represents, `"invoice.scheduled_charge_failed"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// A unique ID for the webhook event.
	EventId *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// Timestamp of when the webhook event was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// Data associated with the event.
	Data *InvoiceScheduledChargeFailedWebhookData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (i *InvoiceScheduledChargeFailedWebhook) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InvoiceScheduledChargeFailedWebhook) UnmarshalJSON(data []byte) error {
	type unmarshaler InvoiceScheduledChargeFailedWebhook
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = InvoiceScheduledChargeFailedWebhook(value)

	extraProperties, err := core.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties

	i._rawJSON = json.RawMessage(data)
	return nil
}

func (i *InvoiceScheduledChargeFailedWebhook) String() string {
	if len(i._rawJSON) > 0 {
		if value, err := core.StringifyJSON(i._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type InvoiceScheduledChargeFailedWebhookData struct {
	// Name of the affected object’s type, `"invoice"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// ID of the affected invoice.
	Id *string `json:"id,omitempty" url:"id,omitempty"`
	// An object containing the invoice that experienced the failed scheduled charge.
	Object *InvoiceScheduledChargeFailedWebhookObject `json:"object,omitempty" url:"object,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (i *InvoiceScheduledChargeFailedWebhookData) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InvoiceScheduledChargeFailedWebhookData) UnmarshalJSON(data []byte) error {
	type unmarshaler InvoiceScheduledChargeFailedWebhookData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = InvoiceScheduledChargeFailedWebhookData(value)

	extraProperties, err := core.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties

	i._rawJSON = json.RawMessage(data)
	return nil
}

func (i *InvoiceScheduledChargeFailedWebhookData) String() string {
	if len(i._rawJSON) > 0 {
		if value, err := core.StringifyJSON(i._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type InvoiceScheduledChargeFailedWebhookObject struct {
	// The related invoice.
	Invoice *Invoice `json:"invoice,omitempty" url:"invoice,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (i *InvoiceScheduledChargeFailedWebhookObject) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InvoiceScheduledChargeFailedWebhookObject) UnmarshalJSON(data []byte) error {
	type unmarshaler InvoiceScheduledChargeFailedWebhookObject
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = InvoiceScheduledChargeFailedWebhookObject(value)

	extraProperties, err := core.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties

	i._rawJSON = json.RawMessage(data)
	return nil
}

func (i *InvoiceScheduledChargeFailedWebhookObject) String() string {
	if len(i._rawJSON) > 0 {
		if value, err := core.StringifyJSON(i._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

// Identifies the sort field and sort order.
type InvoiceSort struct {
	// The field to use for sorting.
	// See [InvoiceSortField](#type-invoicesortfield) for possible values
	Field InvoiceSortField `json:"field" url:"field"`
	// The order to use for sorting the results.
	// See [SortOrder](#type-sortorder) for possible values
	Order *SortOrder `json:"order,omitempty" url:"order,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (i *InvoiceSort) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InvoiceSort) UnmarshalJSON(data []byte) error {
	type unmarshaler InvoiceSort
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = InvoiceSort(value)

	extraProperties, err := core.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties

	i._rawJSON = json.RawMessage(data)
	return nil
}

func (i *InvoiceSort) String() string {
	if len(i._rawJSON) > 0 {
		if value, err := core.StringifyJSON(i._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

// The field to use for sorting.
type InvoiceSortField string

const (
	InvoiceSortFieldInvoiceSortFieldDoNotUse InvoiceSortField = "INVOICE_SORT_FIELD_DO_NOT_USE"
	InvoiceSortFieldInvoiceSortDate          InvoiceSortField = "INVOICE_SORT_DATE"
)

func NewInvoiceSortFieldFromString(s string) (InvoiceSortField, error) {
	switch s {
	case "INVOICE_SORT_FIELD_DO_NOT_USE":
		return InvoiceSortFieldInvoiceSortFieldDoNotUse, nil
	case "INVOICE_SORT_DATE":
		return InvoiceSortFieldInvoiceSortDate, nil
	}
	var t InvoiceSortField
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (i InvoiceSortField) Ptr() *InvoiceSortField {
	return &i
}

// Indicates the status of an invoice.
type InvoiceStatus string

const (
	InvoiceStatusInvoiceStatusDoNotUse InvoiceStatus = "INVOICE_STATUS_DO_NOT_USE"
	InvoiceStatusDraft                 InvoiceStatus = "DRAFT"
	InvoiceStatusUnpaid                InvoiceStatus = "UNPAID"
	InvoiceStatusScheduled             InvoiceStatus = "SCHEDULED"
	InvoiceStatusPartiallyPaid         InvoiceStatus = "PARTIALLY_PAID"
	InvoiceStatusPaid                  InvoiceStatus = "PAID"
	InvoiceStatusPartiallyRefunded     InvoiceStatus = "PARTIALLY_REFUNDED"
	InvoiceStatusRefunded              InvoiceStatus = "REFUNDED"
	InvoiceStatusCanceled              InvoiceStatus = "CANCELED"
	InvoiceStatusFailed                InvoiceStatus = "FAILED"
	InvoiceStatusPaymentPending        InvoiceStatus = "PAYMENT_PENDING"
)

func NewInvoiceStatusFromString(s string) (InvoiceStatus, error) {
	switch s {
	case "INVOICE_STATUS_DO_NOT_USE":
		return InvoiceStatusInvoiceStatusDoNotUse, nil
	case "DRAFT":
		return InvoiceStatusDraft, nil
	case "UNPAID":
		return InvoiceStatusUnpaid, nil
	case "SCHEDULED":
		return InvoiceStatusScheduled, nil
	case "PARTIALLY_PAID":
		return InvoiceStatusPartiallyPaid, nil
	case "PAID":
		return InvoiceStatusPaid, nil
	case "PARTIALLY_REFUNDED":
		return InvoiceStatusPartiallyRefunded, nil
	case "REFUNDED":
		return InvoiceStatusRefunded, nil
	case "CANCELED":
		return InvoiceStatusCanceled, nil
	case "FAILED":
		return InvoiceStatusFailed, nil
	case "PAYMENT_PENDING":
		return InvoiceStatusPaymentPending, nil
	}
	var t InvoiceStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (i InvoiceStatus) Ptr() *InvoiceStatus {
	return &i
}

// Published when an [Invoice](entity:Invoice) is updated.
type InvoiceUpdatedWebhook struct {
	// The ID of the target merchant associated with the event.
	MerchantId *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The type of event this represents, `"invoice.updated"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// A unique ID for the webhook event.
	EventId *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// Timestamp of when the webhook event was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// Data associated with the event.
	Data *InvoiceUpdatedWebhookData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (i *InvoiceUpdatedWebhook) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InvoiceUpdatedWebhook) UnmarshalJSON(data []byte) error {
	type unmarshaler InvoiceUpdatedWebhook
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = InvoiceUpdatedWebhook(value)

	extraProperties, err := core.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties

	i._rawJSON = json.RawMessage(data)
	return nil
}

func (i *InvoiceUpdatedWebhook) String() string {
	if len(i._rawJSON) > 0 {
		if value, err := core.StringifyJSON(i._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type InvoiceUpdatedWebhookData struct {
	// Name of the affected object’s type, `"invoice"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// ID of the affected invoice.
	Id *string `json:"id,omitempty" url:"id,omitempty"`
	// An object containing the updated invoice.
	Object *InvoiceUpdatedWebhookObject `json:"object,omitempty" url:"object,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (i *InvoiceUpdatedWebhookData) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InvoiceUpdatedWebhookData) UnmarshalJSON(data []byte) error {
	type unmarshaler InvoiceUpdatedWebhookData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = InvoiceUpdatedWebhookData(value)

	extraProperties, err := core.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties

	i._rawJSON = json.RawMessage(data)
	return nil
}

func (i *InvoiceUpdatedWebhookData) String() string {
	if len(i._rawJSON) > 0 {
		if value, err := core.StringifyJSON(i._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type InvoiceUpdatedWebhookObject struct {
	// The related invoice.
	Invoice *Invoice `json:"invoice,omitempty" url:"invoice,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (i *InvoiceUpdatedWebhookObject) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InvoiceUpdatedWebhookObject) UnmarshalJSON(data []byte) error {
	type unmarshaler InvoiceUpdatedWebhookObject
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = InvoiceUpdatedWebhookObject(value)

	extraProperties, err := core.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties

	i._rawJSON = json.RawMessage(data)
	return nil
}

func (i *InvoiceUpdatedWebhookObject) String() string {
	if len(i._rawJSON) > 0 {
		if value, err := core.StringifyJSON(i._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

// Price and inventory alerting overrides for a `CatalogItemVariation` at a specific `Location`.
type ItemVariationLocationOverrides struct {
	// The ID of the `Location`. This can include locations that are deactivated.
	LocationId *string `json:"location_id,omitempty" url:"location_id,omitempty"`
	// The price of the `CatalogItemVariation` at the given `Location`, or blank for variable pricing.
	PriceMoney *Money `json:"price_money,omitempty" url:"price_money,omitempty"`
	// The pricing type (fixed or variable) for the `CatalogItemVariation` at the given `Location`.
	// See [CatalogPricingType](#type-catalogpricingtype) for possible values
	PricingType *CatalogPricingType `json:"pricing_type,omitempty" url:"pricing_type,omitempty"`
	// If `true`, inventory tracking is active for the `CatalogItemVariation` at this `Location`.
	TrackInventory *bool `json:"track_inventory,omitempty" url:"track_inventory,omitempty"`
	// Indicates whether the `CatalogItemVariation` displays an alert when its inventory
	// quantity is less than or equal to its `inventory_alert_threshold`.
	// See [InventoryAlertType](#type-inventoryalerttype) for possible values
	InventoryAlertType *InventoryAlertType `json:"inventory_alert_type,omitempty" url:"inventory_alert_type,omitempty"`
	// If the inventory quantity for the variation is less than or equal to this value and `inventory_alert_type`
	// is `LOW_QUANTITY`, the variation displays an alert in the merchant dashboard.
	//
	// This value is always an integer.
	InventoryAlertThreshold *int64 `json:"inventory_alert_threshold,omitempty" url:"inventory_alert_threshold,omitempty"`
	// Indicates whether the overridden item variation is sold out at the specified location.
	//
	// When inventory tracking is enabled on the item variation either globally or at the specified location,
	// the item variation is automatically marked as sold out when its inventory count reaches zero. The seller
	// can manually set the item variation as sold out even when the inventory count is greater than zero.
	// Attempts by an application to set this attribute are ignored. Regardless how the sold-out status is set,
	// applications should treat its inventory count as zero when this attribute value is `true`.
	SoldOut *bool `json:"sold_out,omitempty" url:"sold_out,omitempty"`
	// The seller-assigned timestamp, of the RFC 3339 format, to indicate when this sold-out variation
	// becomes available again at the specified location. Attempts by an application to set this attribute are ignored.
	// When the current time is later than this attribute value, the affected item variation is no longer sold out.
	SoldOutValidUntil *string `json:"sold_out_valid_until,omitempty" url:"sold_out_valid_until,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (i *ItemVariationLocationOverrides) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *ItemVariationLocationOverrides) UnmarshalJSON(data []byte) error {
	type unmarshaler ItemVariationLocationOverrides
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = ItemVariationLocationOverrides(value)

	extraProperties, err := core.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties

	i._rawJSON = json.RawMessage(data)
	return nil
}

func (i *ItemVariationLocationOverrides) String() string {
	if len(i._rawJSON) > 0 {
		if value, err := core.StringifyJSON(i._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

// An object describing a job that a team member is assigned to.
type JobAssignment struct {
	// The title of the job.
	JobTitle string `json:"job_title" url:"job_title"`
	// The current pay type for the job assignment used to
	// calculate the pay amount in a pay period.
	// See [JobAssignmentPayType](#type-jobassignmentpaytype) for possible values
	PayType JobAssignmentPayType `json:"pay_type" url:"pay_type"`
	// The hourly pay rate of the job.
	HourlyRate *Money `json:"hourly_rate,omitempty" url:"hourly_rate,omitempty"`
	// The total pay amount for a 12-month period on the job. Set if the job `PayType` is `SALARY`.
	AnnualRate *Money `json:"annual_rate,omitempty" url:"annual_rate,omitempty"`
	// The planned hours per week for the job. Set if the job `PayType` is `SALARY`.
	WeeklyHours *int `json:"weekly_hours,omitempty" url:"weekly_hours,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (j *JobAssignment) GetExtraProperties() map[string]interface{} {
	return j.extraProperties
}

func (j *JobAssignment) UnmarshalJSON(data []byte) error {
	type unmarshaler JobAssignment
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*j = JobAssignment(value)

	extraProperties, err := core.ExtractExtraProperties(data, *j)
	if err != nil {
		return err
	}
	j.extraProperties = extraProperties

	j._rawJSON = json.RawMessage(data)
	return nil
}

func (j *JobAssignment) String() string {
	if len(j._rawJSON) > 0 {
		if value, err := core.StringifyJSON(j._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(j); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", j)
}

// Enumerates the possible pay types that a job can be assigned.
type JobAssignmentPayType string

const (
	JobAssignmentPayTypeStatusDoNotUse JobAssignmentPayType = "STATUS_DO_NOT_USE"
	JobAssignmentPayTypeNone           JobAssignmentPayType = "NONE"
	JobAssignmentPayTypeHourly         JobAssignmentPayType = "HOURLY"
	JobAssignmentPayTypeSalary         JobAssignmentPayType = "SALARY"
)

func NewJobAssignmentPayTypeFromString(s string) (JobAssignmentPayType, error) {
	switch s {
	case "STATUS_DO_NOT_USE":
		return JobAssignmentPayTypeStatusDoNotUse, nil
	case "NONE":
		return JobAssignmentPayTypeNone, nil
	case "HOURLY":
		return JobAssignmentPayTypeHourly, nil
	case "SALARY":
		return JobAssignmentPayTypeSalary, nil
	}
	var t JobAssignmentPayType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (j JobAssignmentPayType) Ptr() *JobAssignmentPayType {
	return &j
}

// Published when a worker starts a [Shift](entity:Shift).
type LaborShiftCreatedWebhook struct {
	// The ID of the target merchant associated with the event.
	MerchantId *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The type of event this represents.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// A unique ID for the webhook event.
	EventId *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// Timestamp of when the webhook event was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// Data associated with the event.
	Data *LaborShiftCreatedWebhookData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *LaborShiftCreatedWebhook) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LaborShiftCreatedWebhook) UnmarshalJSON(data []byte) error {
	type unmarshaler LaborShiftCreatedWebhook
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LaborShiftCreatedWebhook(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *LaborShiftCreatedWebhook) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

type LaborShiftCreatedWebhookData struct {
	// Name of the affected object’s type.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// ID of the affected object.
	Id *string `json:"id,omitempty" url:"id,omitempty"`
	// An object containing fields and values relevant to the event. Is absent if affected object was deleted.
	Object *LaborShiftCreatedWebhookObject `json:"object,omitempty" url:"object,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *LaborShiftCreatedWebhookData) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LaborShiftCreatedWebhookData) UnmarshalJSON(data []byte) error {
	type unmarshaler LaborShiftCreatedWebhookData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LaborShiftCreatedWebhookData(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *LaborShiftCreatedWebhookData) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

type LaborShiftCreatedWebhookObject struct {
	// The work shift.
	Shift *Shift `json:"shift,omitempty" url:"shift,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *LaborShiftCreatedWebhookObject) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LaborShiftCreatedWebhookObject) UnmarshalJSON(data []byte) error {
	type unmarshaler LaborShiftCreatedWebhookObject
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LaborShiftCreatedWebhookObject(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *LaborShiftCreatedWebhookObject) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Published when a [Shift](entity:Shift) is deleted.
type LaborShiftDeletedWebhook struct {
	// The ID of the target merchant associated with the event.
	MerchantId *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The type of event this represents.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// A unique ID for the webhook event.
	EventId *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// Timestamp of when the webhook event was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// Data associated with the event.
	Data *LaborShiftDeletedWebhookData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *LaborShiftDeletedWebhook) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LaborShiftDeletedWebhook) UnmarshalJSON(data []byte) error {
	type unmarshaler LaborShiftDeletedWebhook
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LaborShiftDeletedWebhook(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *LaborShiftDeletedWebhook) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

type LaborShiftDeletedWebhookData struct {
	// Name of the affected object’s type.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// ID of the affected object.
	Id *string `json:"id,omitempty" url:"id,omitempty"`
	// Is true if the affected object was deleted. Otherwise absent.
	Deleted *bool `json:"deleted,omitempty" url:"deleted,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *LaborShiftDeletedWebhookData) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LaborShiftDeletedWebhookData) UnmarshalJSON(data []byte) error {
	type unmarshaler LaborShiftDeletedWebhookData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LaborShiftDeletedWebhookData(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *LaborShiftDeletedWebhookData) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Published when a [Shift](entity:Shift) is updated.
type LaborShiftUpdatedWebhook struct {
	// The ID of the target merchant associated with the event.
	MerchantId *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The type of event this represents.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// A unique ID for the webhook event.
	EventId *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// Timestamp of when the webhook event was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// Data associated with the event.
	Data *LaborShiftUpdatedWebhookData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *LaborShiftUpdatedWebhook) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LaborShiftUpdatedWebhook) UnmarshalJSON(data []byte) error {
	type unmarshaler LaborShiftUpdatedWebhook
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LaborShiftUpdatedWebhook(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *LaborShiftUpdatedWebhook) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

type LaborShiftUpdatedWebhookData struct {
	// Name of the affected object’s type.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// ID of the affected object.
	Id *string `json:"id,omitempty" url:"id,omitempty"`
	// An object containing fields and values relevant to the event. Is absent if affected object was deleted.
	Object *LaborShiftUpdatedWebhookObject `json:"object,omitempty" url:"object,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *LaborShiftUpdatedWebhookData) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LaborShiftUpdatedWebhookData) UnmarshalJSON(data []byte) error {
	type unmarshaler LaborShiftUpdatedWebhookData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LaborShiftUpdatedWebhookData(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *LaborShiftUpdatedWebhookData) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

type LaborShiftUpdatedWebhookObject struct {
	// The work shift.
	Shift *Shift `json:"shift,omitempty" url:"shift,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *LaborShiftUpdatedWebhookObject) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LaborShiftUpdatedWebhookObject) UnmarshalJSON(data []byte) error {
	type unmarshaler LaborShiftUpdatedWebhookObject
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LaborShiftUpdatedWebhookObject(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *LaborShiftUpdatedWebhookObject) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

type ListCashDrawerShiftEventsResponse struct {
	// All of the events (payments, refunds, etc.) for a cash drawer during
	// the shift.
	Events []*CashDrawerShiftEvent `json:"events,omitempty" url:"events,omitempty"`
	// Opaque cursor for fetching the next page. Cursor is not present in
	// the last page of results.
	Cursor *string `json:"cursor,omitempty" url:"cursor,omitempty"`
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *ListCashDrawerShiftEventsResponse) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *ListCashDrawerShiftEventsResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ListCashDrawerShiftEventsResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListCashDrawerShiftEventsResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListCashDrawerShiftEventsResponse) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

type ListCashDrawerShiftsResponse struct {
	// A collection of CashDrawerShiftSummary objects for shifts that match
	// the query.
	Items []*CashDrawerShiftSummary `json:"items,omitempty" url:"items,omitempty"`
	// Opaque cursor for fetching the next page of results. Cursor is not
	// present in the last page of results.
	Cursor *string `json:"cursor,omitempty" url:"cursor,omitempty"`
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *ListCashDrawerShiftsResponse) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *ListCashDrawerShiftsResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ListCashDrawerShiftsResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListCashDrawerShiftsResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListCashDrawerShiftsResponse) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Represents a [ListCustomerCustomAttributes](api-endpoint:CustomerCustomAttributes-ListCustomerCustomAttributes) response.
// Either `custom_attributes`, an empty object, or `errors` is present in the response. If additional
// results are available, the `cursor` field is also present along with `custom_attributes`.
type ListCustomerCustomAttributesResponse struct {
	// The retrieved custom attributes. If `with_definitions` was set to `true` in the request,
	// the custom attribute definition is returned in the `definition` field of each custom attribute.
	//
	// If no custom attributes are found, Square returns an empty object (`{}`).
	CustomAttributes []*CustomAttribute `json:"custom_attributes,omitempty" url:"custom_attributes,omitempty"`
	// The cursor to use in your next call to this endpoint to retrieve the next page of results
	// for your original request. This field is present only if the request succeeded and additional
	// results are available. For more information, see [Pagination](https://developer.squareup.com/docs/build-basics/common-api-patterns/pagination).
	Cursor *string `json:"cursor,omitempty" url:"cursor,omitempty"`
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *ListCustomerCustomAttributesResponse) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *ListCustomerCustomAttributesResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ListCustomerCustomAttributesResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListCustomerCustomAttributesResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListCustomerCustomAttributesResponse) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Defines the fields that are included in the response body of
// a request to the [ListCustomerGroups](api-endpoint:CustomerGroups-ListCustomerGroups) endpoint.
//
// Either `errors` or `groups` is present in a given response (never both).
type ListCustomerGroupsResponse struct {
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// A list of customer groups belonging to the current seller.
	Groups []*CustomerGroup `json:"groups,omitempty" url:"groups,omitempty"`
	// A pagination cursor to retrieve the next set of results for your
	// original query to the endpoint. This value is present only if the request
	// succeeded and additional results are available.
	//
	// For more information, see [Pagination](https://developer.squareup.com/docs/build-basics/common-api-patterns/pagination).
	Cursor *string `json:"cursor,omitempty" url:"cursor,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *ListCustomerGroupsResponse) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *ListCustomerGroupsResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ListCustomerGroupsResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListCustomerGroupsResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListCustomerGroupsResponse) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Defines the fields that are included in the response body for requests to the `ListCustomerSegments` endpoint.
//
// Either `errors` or `segments` is present in a given response (never both).
type ListCustomerSegmentsResponse struct {
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The list of customer segments belonging to the associated Square account.
	Segments []*CustomerSegment `json:"segments,omitempty" url:"segments,omitempty"`
	// A pagination cursor to be used in subsequent calls to `ListCustomerSegments`
	// to retrieve the next set of query results. The cursor is only present if the request succeeded and
	// additional results are available.
	//
	// For more information, see [Pagination](https://developer.squareup.com/docs/build-basics/common-api-patterns/pagination).
	Cursor *string `json:"cursor,omitempty" url:"cursor,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *ListCustomerSegmentsResponse) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *ListCustomerSegmentsResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ListCustomerSegmentsResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListCustomerSegmentsResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListCustomerSegmentsResponse) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

type ListDeviceCodesResponse struct {
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The queried DeviceCode.
	DeviceCodes []*DeviceCode `json:"device_codes,omitempty" url:"device_codes,omitempty"`
	// A pagination cursor to retrieve the next set of results for your
	// original query to the endpoint. This value is present only if the request
	// succeeded and additional results are available.
	//
	// See [Paginating results](https://developer.squareup.com/docs/working-with-apis/pagination) for more information.
	Cursor *string `json:"cursor,omitempty" url:"cursor,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *ListDeviceCodesResponse) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *ListDeviceCodesResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ListDeviceCodesResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListDeviceCodesResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListDeviceCodesResponse) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Defines the fields in a `ListDisputeEvidence` response.
type ListDisputeEvidenceResponse struct {
	// The list of evidence previously uploaded to the specified dispute.
	Evidence []*DisputeEvidence `json:"evidence,omitempty" url:"evidence,omitempty"`
	// Information about errors encountered during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The pagination cursor to be used in a subsequent request.
	// If unset, this is the final response. For more information, see [Pagination](https://developer.squareup.com/docs/build-basics/common-api-patterns/pagination).
	Cursor *string `json:"cursor,omitempty" url:"cursor,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *ListDisputeEvidenceResponse) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *ListDisputeEvidenceResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ListDisputeEvidenceResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListDisputeEvidenceResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListDisputeEvidenceResponse) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// The response to a request for a set of `EmployeeWage` objects. The response contains
// a set of `EmployeeWage` objects.
type ListEmployeeWagesResponse struct {
	// A page of `EmployeeWage` results.
	EmployeeWages []*EmployeeWage `json:"employee_wages,omitempty" url:"employee_wages,omitempty"`
	// The value supplied in the subsequent request to fetch the next page
	// of `EmployeeWage` results.
	Cursor *string `json:"cursor,omitempty" url:"cursor,omitempty"`
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *ListEmployeeWagesResponse) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *ListEmployeeWagesResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ListEmployeeWagesResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListEmployeeWagesResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListEmployeeWagesResponse) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// A response that contains a list of `GiftCardActivity` objects. If the request resulted in errors,
// the response contains a set of `Error` objects.
type ListGiftCardActivitiesResponse struct {
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The requested gift card activities or an empty object if none are found.
	GiftCardActivities []*GiftCardActivity `json:"gift_card_activities,omitempty" url:"gift_card_activities,omitempty"`
	// When a response is truncated, it includes a cursor that you can use in a
	// subsequent request to retrieve the next set of activities. If a cursor is not present, this is
	// the final response.
	// For more information, see [Pagination](https://developer.squareup.com/docs/working-with-apis/pagination).
	Cursor *string `json:"cursor,omitempty" url:"cursor,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *ListGiftCardActivitiesResponse) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *ListGiftCardActivitiesResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ListGiftCardActivitiesResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListGiftCardActivitiesResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListGiftCardActivitiesResponse) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Defines the fields that are included in requests to the
// [ListLocations](api-endpoint:Locations-ListLocations) endpoint.
type ListLocationsRequest struct {
	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *ListLocationsRequest) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *ListLocationsRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler ListLocationsRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListLocationsRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListLocationsRequest) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// A request to list `LoyaltyProgram`.
type ListLoyaltyProgramsRequest struct {
	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *ListLoyaltyProgramsRequest) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *ListLoyaltyProgramsRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler ListLoyaltyProgramsRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListLoyaltyProgramsRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListLoyaltyProgramsRequest) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// A response that contains all loyalty programs.
type ListLoyaltyProgramsResponse struct {
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// A list of `LoyaltyProgram` for the merchant.
	Programs []*LoyaltyProgram `json:"programs,omitempty" url:"programs,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *ListLoyaltyProgramsResponse) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *ListLoyaltyProgramsResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ListLoyaltyProgramsResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListLoyaltyProgramsResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListLoyaltyProgramsResponse) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Represents a [ListLoyaltyPromotions](api-endpoint:Loyalty-ListLoyaltyPromotions) response.
// One of `loyalty_promotions`, an empty object, or `errors` is present in the response.
// If additional results are available, the `cursor` field is also present along with `loyalty_promotions`.
type ListLoyaltyPromotionsResponse struct {
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The retrieved loyalty promotions.
	LoyaltyPromotions []*LoyaltyPromotion `json:"loyalty_promotions,omitempty" url:"loyalty_promotions,omitempty"`
	// The cursor to use in your next call to this endpoint to retrieve the next page of results
	// for your original request. This field is present only if the request succeeded and additional
	// results are available. For more information, see [Pagination](https://developer.squareup.com/docs/build-basics/common-api-patterns/pagination).
	Cursor *string `json:"cursor,omitempty" url:"cursor,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *ListLoyaltyPromotionsResponse) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *ListLoyaltyPromotionsResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ListLoyaltyPromotionsResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListLoyaltyPromotionsResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListLoyaltyPromotionsResponse) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

type ListPaymentLinksResponse struct {
	// Errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The list of payment links.
	PaymentLinks []*PaymentLink `json:"payment_links,omitempty" url:"payment_links,omitempty"`
	// When a response is truncated, it includes a cursor that you can use in a subsequent request
	// to retrieve the next set of gift cards. If a cursor is not present, this is the final response.
	// For more information, see [Pagination](https://developer.squareup.com/docs/basics/api101/pagination).
	Cursor *string `json:"cursor,omitempty" url:"cursor,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *ListPaymentLinksResponse) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *ListPaymentLinksResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ListPaymentLinksResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListPaymentLinksResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListPaymentLinksResponse) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Defines the fields that are included in the response body of
// a request to the [ListRefunds](api-endpoint:Transactions-ListRefunds) endpoint.
//
// One of `errors` or `refunds` is present in a given response (never both).
type ListRefundsResponse struct {
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// An array of refunds that match your query.
	Refunds []*Refund `json:"refunds,omitempty" url:"refunds,omitempty"`
	// A pagination cursor for retrieving the next set of results,
	// if any remain. Provide this value as the `cursor` parameter in a subsequent
	// request to this endpoint.
	//
	// See [Paginating results](https://developer.squareup.com/docs/working-with-apis/pagination) for more information.
	Cursor *string `json:"cursor,omitempty" url:"cursor,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *ListRefundsResponse) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *ListRefundsResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ListRefundsResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListRefundsResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListRefundsResponse) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Represents a `ListSites` request.
type ListSitesRequest struct {
	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *ListSitesRequest) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *ListSitesRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler ListSitesRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListSitesRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListSitesRequest) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

type ListTeamMemberBookingProfilesResponse struct {
	// The list of team member booking profiles. The results are returned in the ascending order of the time
	// when the team member booking profiles were last updated. Multiple booking profiles updated at the same time
	// are further sorted in the ascending order of their IDs.
	TeamMemberBookingProfiles []*TeamMemberBookingProfile `json:"team_member_booking_profiles,omitempty" url:"team_member_booking_profiles,omitempty"`
	// The pagination cursor to be used in the subsequent request to get the next page of the results. Stop retrieving the next page of the results when the cursor is not set.
	Cursor *string `json:"cursor,omitempty" url:"cursor,omitempty"`
	// Errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *ListTeamMemberBookingProfilesResponse) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *ListTeamMemberBookingProfilesResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ListTeamMemberBookingProfilesResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListTeamMemberBookingProfilesResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListTeamMemberBookingProfilesResponse) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// The response to a request for a set of `TeamMemberWage` objects. The response contains
// a set of `TeamMemberWage` objects.
type ListTeamMemberWagesResponse struct {
	// A page of `TeamMemberWage` results.
	TeamMemberWages []*TeamMemberWage `json:"team_member_wages,omitempty" url:"team_member_wages,omitempty"`
	// The value supplied in the subsequent request to fetch the next page
	// of `TeamMemberWage` results.
	Cursor *string `json:"cursor,omitempty" url:"cursor,omitempty"`
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *ListTeamMemberWagesResponse) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *ListTeamMemberWagesResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ListTeamMemberWagesResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListTeamMemberWagesResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListTeamMemberWagesResponse) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Defines the fields that are included in the response body of
// a request to the [ListTransactions](api-endpoint:Transactions-ListTransactions) endpoint.
//
// One of `errors` or `transactions` is present in a given response (never both).
type ListTransactionsResponse struct {
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// An array of transactions that match your query.
	Transactions []*Transaction `json:"transactions,omitempty" url:"transactions,omitempty"`
	// A pagination cursor for retrieving the next set of results,
	// if any remain. Provide this value as the `cursor` parameter in a subsequent
	// request to this endpoint.
	//
	// See [Paginating results](https://developer.squareup.com/docs/working-with-apis/pagination) for more information.
	Cursor *string `json:"cursor,omitempty" url:"cursor,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *ListTransactionsResponse) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *ListTransactionsResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ListTransactionsResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListTransactionsResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListTransactionsResponse) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Defines the fields that are included in the response body of
// a request to the [ListWebhookEventTypes](api-endpoint:WebhookSubscriptions-ListWebhookEventTypes) endpoint.
//
// Note: if there are errors processing the request, the event types field will not be
// present.
type ListWebhookEventTypesResponse struct {
	// Information on errors encountered during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The list of event types.
	EventTypes []string `json:"event_types,omitempty" url:"event_types,omitempty"`
	// Contains the metadata of a webhook event type. For more information, see [EventTypeMetadata](entity:EventTypeMetadata).
	Metadata []*EventTypeMetadata `json:"metadata,omitempty" url:"metadata,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *ListWebhookEventTypesResponse) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *ListWebhookEventTypesResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ListWebhookEventTypesResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListWebhookEventTypesResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListWebhookEventTypesResponse) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Defines the fields that are included in the response body of
// a request to the [ListWebhookSubscriptions](api-endpoint:WebhookSubscriptions-ListWebhookSubscriptions) endpoint.
//
// Note: if there are errors processing the request, the subscriptions field will not be
// present.
type ListWebhookSubscriptionsResponse struct {
	// Information on errors encountered during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The requested list of [Subscription](entity:WebhookSubscription)s.
	Subscriptions []*WebhookSubscription `json:"subscriptions,omitempty" url:"subscriptions,omitempty"`
	// The pagination cursor to be used in a subsequent request. If empty,
	// this is the final response.
	//
	// For more information, see [Pagination](https://developer.squareup.com/docs/basics/api101/pagination).
	Cursor *string `json:"cursor,omitempty" url:"cursor,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *ListWebhookSubscriptionsResponse) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *ListWebhookSubscriptionsResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ListWebhookSubscriptionsResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListWebhookSubscriptionsResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListWebhookSubscriptionsResponse) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// The response to a request for a set of `WorkweekConfig` objects. The response contains
// the requested `WorkweekConfig` objects and might contain a set of `Error` objects if
// the request resulted in errors.
type ListWorkweekConfigsResponse struct {
	// A page of `WorkweekConfig` results.
	WorkweekConfigs []*WorkweekConfig `json:"workweek_configs,omitempty" url:"workweek_configs,omitempty"`
	// The value supplied in the subsequent request to fetch the next page of
	// `WorkweekConfig` results.
	Cursor *string `json:"cursor,omitempty" url:"cursor,omitempty"`
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *ListWorkweekConfigsResponse) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *ListWorkweekConfigsResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ListWorkweekConfigsResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListWorkweekConfigsResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListWorkweekConfigsResponse) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// The capabilities a location might have.
type LocationCapability string

const (
	LocationCapabilityCreditCardProcessing LocationCapability = "CREDIT_CARD_PROCESSING"
	LocationCapabilityAutomaticTransfers   LocationCapability = "AUTOMATIC_TRANSFERS"
)

func NewLocationCapabilityFromString(s string) (LocationCapability, error) {
	switch s {
	case "CREDIT_CARD_PROCESSING":
		return LocationCapabilityCreditCardProcessing, nil
	case "AUTOMATIC_TRANSFERS":
		return LocationCapabilityAutomaticTransfers, nil
	}
	var t LocationCapability
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (l LocationCapability) Ptr() *LocationCapability {
	return &l
}

// Published when a [Location](entity:Location) is created.
type LocationCreatedWebhook struct {
	// The ID of the target merchant associated with the event.
	MerchantId *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The ID of the [Location](entity:Location) associated with the event.
	LocationId *string `json:"location_id,omitempty" url:"location_id,omitempty"`
	// The type of event this represents, `"location.created"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// A unique ID for the webhook event.
	EventId *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// Timestamp of when the webhook event was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// Data associated with the event.
	Data *LocationCreatedWebhookData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *LocationCreatedWebhook) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LocationCreatedWebhook) UnmarshalJSON(data []byte) error {
	type unmarshaler LocationCreatedWebhook
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LocationCreatedWebhook(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *LocationCreatedWebhook) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

type LocationCreatedWebhookData struct {
	// Name of the affected object’s type, `"location"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// ID of the updated [Location](entity:Location).
	Id *string `json:"id,omitempty" url:"id,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *LocationCreatedWebhookData) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LocationCreatedWebhookData) UnmarshalJSON(data []byte) error {
	type unmarshaler LocationCreatedWebhookData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LocationCreatedWebhookData(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *LocationCreatedWebhookData) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// A location's status.
type LocationStatus string

const (
	LocationStatusActive   LocationStatus = "ACTIVE"
	LocationStatusInactive LocationStatus = "INACTIVE"
)

func NewLocationStatusFromString(s string) (LocationStatus, error) {
	switch s {
	case "ACTIVE":
		return LocationStatusActive, nil
	case "INACTIVE":
		return LocationStatusInactive, nil
	}
	var t LocationStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (l LocationStatus) Ptr() *LocationStatus {
	return &l
}

// A location's type.
type LocationType string

const (
	LocationTypePhysical LocationType = "PHYSICAL"
	LocationTypeMobile   LocationType = "MOBILE"
)

func NewLocationTypeFromString(s string) (LocationType, error) {
	switch s {
	case "PHYSICAL":
		return LocationTypePhysical, nil
	case "MOBILE":
		return LocationTypeMobile, nil
	}
	var t LocationType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (l LocationType) Ptr() *LocationType {
	return &l
}

// Published when a [Location](entity:Location) is updated.
type LocationUpdatedWebhook struct {
	// The ID of the target merchant associated with the event.
	MerchantId *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The ID of the [Location](entity:Location) associated with the event.
	LocationId *string `json:"location_id,omitempty" url:"location_id,omitempty"`
	// The type of event this represents, `"location.updated"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// A unique ID for the webhook event.
	EventId *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// Timestamp of when the webhook event was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// Data associated with the event.
	Data *LocationUpdatedWebhookData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *LocationUpdatedWebhook) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LocationUpdatedWebhook) UnmarshalJSON(data []byte) error {
	type unmarshaler LocationUpdatedWebhook
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LocationUpdatedWebhook(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *LocationUpdatedWebhook) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

type LocationUpdatedWebhookData struct {
	// Name of the affected object’s type, `"location"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// ID of the updated [Location](entity:Location).
	Id *string `json:"id,omitempty" url:"id,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *LocationUpdatedWebhookData) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LocationUpdatedWebhookData) UnmarshalJSON(data []byte) error {
	type unmarshaler LocationUpdatedWebhookData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LocationUpdatedWebhookData(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *LocationUpdatedWebhookData) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Describes a loyalty account in a [loyalty program](entity:LoyaltyProgram). For more information, see
// [Create and Retrieve Loyalty Accounts](https://developer.squareup.com/docs/loyalty-api/loyalty-accounts).
type LoyaltyAccount struct {
	// The Square-assigned ID of the loyalty account.
	Id *string `json:"id,omitempty" url:"id,omitempty"`
	// The list of mappings that the account is associated with.
	// Currently, a buyer can only be mapped to a loyalty account using
	// a phone number. Therefore, the list can only have one mapping.
	// RETIRED at version 2021-05-13. Replaced by the `mapping` field.
	Mappings []*LoyaltyAccountMapping `json:"mappings,omitempty" url:"mappings,omitempty"`
	// The Square-assigned ID of the [loyalty program](entity:LoyaltyProgram) to which the account belongs.
	ProgramId string `json:"program_id" url:"program_id"`
	// The available point balance in the loyalty account. If points are scheduled to expire, they are listed in the `expiring_point_deadlines` field.
	//
	// Your application should be able to handle loyalty accounts that have a negative point balance (`balance` is less than 0). This might occur if a seller makes a manual adjustment or as a result of a refund or exchange.
	Balance *int `json:"balance,omitempty" url:"balance,omitempty"`
	// The total points accrued during the lifetime of the account.
	LifetimePoints *int `json:"lifetime_points,omitempty" url:"lifetime_points,omitempty"`
	// The Square-assigned ID of the [customer](entity:Customer) that is associated with the account.
	CustomerId *string `json:"customer_id,omitempty" url:"customer_id,omitempty"`
	// The timestamp when the buyer joined the loyalty program, in RFC 3339 format. This field is used to display the **Enrolled On** or **Member Since** date in first-party Square products.
	//
	// If this field is not set in a `CreateLoyaltyAccount` request, Square populates it after the buyer's first action on their account
	// (when `AccumulateLoyaltyPoints` or `CreateLoyaltyReward` is called). In first-party flows, Square populates the field when the buyer agrees to the terms of service in Square Point of Sale.
	//
	// This field is typically specified in a `CreateLoyaltyAccount` request when creating a loyalty account for a buyer who already interacted with their account.
	// For example, you would set this field when migrating accounts from an external system. The timestamp in the request can represent a current or previous date and time, but it cannot be set for the future.
	EnrolledAt *string `json:"enrolled_at,omitempty" url:"enrolled_at,omitempty"`
	// The timestamp when the loyalty account was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The timestamp when the loyalty account was last updated, in RFC 3339 format.
	UpdatedAt *string `json:"updated_at,omitempty" url:"updated_at,omitempty"`
	// The mapping that associates the loyalty account with a buyer. Currently,
	// a loyalty account can only be mapped to a buyer by phone number.
	//
	// To create a loyalty account, you must specify the `mapping` field, with the buyer's phone number
	// in the `phone_number` field.
	Mapping *LoyaltyAccountMapping `json:"mapping,omitempty" url:"mapping,omitempty"`
	// The schedule for when points expire in the loyalty account balance. This field is present only if the account has points that are scheduled to expire.
	//
	// The total number of points in this field equals the number of points in the `balance` field.
	ExpiringPointDeadlines []*LoyaltyAccountExpiringPointDeadline `json:"expiring_point_deadlines,omitempty" url:"expiring_point_deadlines,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *LoyaltyAccount) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LoyaltyAccount) UnmarshalJSON(data []byte) error {
	type unmarshaler LoyaltyAccount
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LoyaltyAccount(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *LoyaltyAccount) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Published when a [loyalty account](entity:LoyaltyAccount) is created.
type LoyaltyAccountCreatedWebhook struct {
	// The ID of the Square seller associated with the event.
	MerchantId *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The type of event. For this event, the value is `loyalty.account.created`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// The unique ID for the event, which is used for
	// [idempotency support](https://developer.squareup.com/docs/webhooks/step4manage#webhooks-best-practices).
	EventId *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// The timestamp of when the webhook event was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The data associated with the event.
	Data *LoyaltyAccountCreatedWebhookData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *LoyaltyAccountCreatedWebhook) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LoyaltyAccountCreatedWebhook) UnmarshalJSON(data []byte) error {
	type unmarshaler LoyaltyAccountCreatedWebhook
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LoyaltyAccountCreatedWebhook(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *LoyaltyAccountCreatedWebhook) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// The data associated with a `loyalty.account.created` webhook event.
type LoyaltyAccountCreatedWebhookData struct {
	// The type of object affected by the event. For this event, the value is `loyalty.account`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// The ID of the affected loyalty account.
	Id *string `json:"id,omitempty" url:"id,omitempty"`
	// The loyalty account that was created.
	Object *LoyaltyAccount `json:"object,omitempty" url:"object,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *LoyaltyAccountCreatedWebhookData) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LoyaltyAccountCreatedWebhookData) UnmarshalJSON(data []byte) error {
	type unmarshaler LoyaltyAccountCreatedWebhookData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LoyaltyAccountCreatedWebhookData(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *LoyaltyAccountCreatedWebhookData) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Published when a [loyalty account](entity:LoyaltyAccount) is deleted.
type LoyaltyAccountDeletedWebhook struct {
	// The ID of the Square seller associated with the event.
	MerchantId *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The type of event. For this event, the value is `loyalty.account.deleted`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// The unique ID for the event, which is used for
	// [idempotency support](https://developer.squareup.com/docs/webhooks/step4manage#webhooks-best-practices).
	EventId *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// The timestamp of when the webhook event was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The data associated with the event.
	Data *LoyaltyAccountDeletedWebhookData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *LoyaltyAccountDeletedWebhook) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LoyaltyAccountDeletedWebhook) UnmarshalJSON(data []byte) error {
	type unmarshaler LoyaltyAccountDeletedWebhook
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LoyaltyAccountDeletedWebhook(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *LoyaltyAccountDeletedWebhook) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// The data associated with a `loyalty.account.deleted` webhook event.
type LoyaltyAccountDeletedWebhookData struct {
	// The type of object affected by the event. For this event, the value is `loyalty.account`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// The ID of the affected loyalty account.
	Id *string `json:"id,omitempty" url:"id,omitempty"`
	// The loyalty account that was deleted.
	Object *LoyaltyAccount `json:"object,omitempty" url:"object,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *LoyaltyAccountDeletedWebhookData) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LoyaltyAccountDeletedWebhookData) UnmarshalJSON(data []byte) error {
	type unmarshaler LoyaltyAccountDeletedWebhookData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LoyaltyAccountDeletedWebhookData(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *LoyaltyAccountDeletedWebhookData) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Represents a set of points for a loyalty account that are scheduled to expire on a specific date.
type LoyaltyAccountExpiringPointDeadline struct {
	// The number of points scheduled to expire at the `expires_at` timestamp.
	Points int `json:"points" url:"points"`
	// The timestamp of when the points are scheduled to expire, in RFC 3339 format.
	ExpiresAt string `json:"expires_at" url:"expires_at"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *LoyaltyAccountExpiringPointDeadline) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LoyaltyAccountExpiringPointDeadline) UnmarshalJSON(data []byte) error {
	type unmarshaler LoyaltyAccountExpiringPointDeadline
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LoyaltyAccountExpiringPointDeadline(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *LoyaltyAccountExpiringPointDeadline) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Represents the mapping that associates a loyalty account with a buyer.
//
// Currently, a loyalty account can only be mapped to a buyer by phone number. For more information, see
// [Loyalty Overview](https://developer.squareup.com/docs/loyalty/overview).
type LoyaltyAccountMapping struct {
	// The Square-assigned ID of the mapping.
	Id *string `json:"id,omitempty" url:"id,omitempty"`
	// The mapping type, which is used with `value` to represent a phone number mapping.
	// RETIRED at version 2021-05-13. When specifying a mapping, use the `phone_number` field instead.
	// See [LoyaltyAccountMappingType](#type-loyaltyaccountmappingtype) for possible values
	Type *LoyaltyAccountMappingType `json:"type,omitempty" url:"type,omitempty"`
	// The mapping value, which is used with `type` to represent a phone number mapping.
	// The value can be a phone number in E.164 format. For example, "+14155551111".
	// RETIRED at version 2021-05-13. When specifying a mapping, use the `phone_number` field instead.
	Value *string `json:"value,omitempty" url:"value,omitempty"`
	// The timestamp when the mapping was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The phone number of the buyer, in E.164 format. For example, "+14155551111".
	PhoneNumber *string `json:"phone_number,omitempty" url:"phone_number,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *LoyaltyAccountMapping) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LoyaltyAccountMapping) UnmarshalJSON(data []byte) error {
	type unmarshaler LoyaltyAccountMapping
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LoyaltyAccountMapping(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *LoyaltyAccountMapping) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// The type of mapping.
type LoyaltyAccountMappingType string

const (
	LoyaltyAccountMappingTypeTypeDoNotUse LoyaltyAccountMappingType = "TYPE_DO_NOT_USE"
	LoyaltyAccountMappingTypePhone        LoyaltyAccountMappingType = "PHONE"
)

func NewLoyaltyAccountMappingTypeFromString(s string) (LoyaltyAccountMappingType, error) {
	switch s {
	case "TYPE_DO_NOT_USE":
		return LoyaltyAccountMappingTypeTypeDoNotUse, nil
	case "PHONE":
		return LoyaltyAccountMappingTypePhone, nil
	}
	var t LoyaltyAccountMappingType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (l LoyaltyAccountMappingType) Ptr() *LoyaltyAccountMappingType {
	return &l
}

// Published when a [loyalty account](entity:LoyaltyAccount) is updated.
type LoyaltyAccountUpdatedWebhook struct {
	// The ID of the Square seller associated with the event.
	MerchantId *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The type of event. For this event, the value is `loyalty.account.updated`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// The unique ID for the event, which is used for
	// [idempotency support](https://developer.squareup.com/docs/webhooks/step4manage#webhooks-best-practices).
	EventId *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// The timestamp of when the webhook event was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The data associated with the event.
	Data *LoyaltyAccountUpdatedWebhookData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *LoyaltyAccountUpdatedWebhook) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LoyaltyAccountUpdatedWebhook) UnmarshalJSON(data []byte) error {
	type unmarshaler LoyaltyAccountUpdatedWebhook
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LoyaltyAccountUpdatedWebhook(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *LoyaltyAccountUpdatedWebhook) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// The data associated with a `loyalty.account.updated` webhook event.
type LoyaltyAccountUpdatedWebhookData struct {
	// The type of object affected by the event. For this event, the value is `loyalty.account`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// The ID of the affected loyalty account.
	Id *string `json:"id,omitempty" url:"id,omitempty"`
	// The loyalty account that was updated.
	Object *LoyaltyAccount `json:"object,omitempty" url:"object,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *LoyaltyAccountUpdatedWebhookData) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LoyaltyAccountUpdatedWebhookData) UnmarshalJSON(data []byte) error {
	type unmarshaler LoyaltyAccountUpdatedWebhookData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LoyaltyAccountUpdatedWebhookData(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *LoyaltyAccountUpdatedWebhookData) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Provides information about a loyalty event.
// For more information, see [Search for Balance-Changing Loyalty Events](https://developer.squareup.com/docs/loyalty-api/loyalty-events).
type LoyaltyEvent struct {
	// The Square-assigned ID of the loyalty event.
	Id string `json:"id" url:"id"`
	// The type of the loyalty event.
	// See [LoyaltyEventType](#type-loyaltyeventtype) for possible values
	Type LoyaltyEventType `json:"type" url:"type"`
	// The timestamp when the event was created, in RFC 3339 format.
	CreatedAt string `json:"created_at" url:"created_at"`
	// Provides metadata when the event `type` is `ACCUMULATE_POINTS`.
	AccumulatePoints *LoyaltyEventAccumulatePoints `json:"accumulate_points,omitempty" url:"accumulate_points,omitempty"`
	// Provides metadata when the event `type` is `CREATE_REWARD`.
	CreateReward *LoyaltyEventCreateReward `json:"create_reward,omitempty" url:"create_reward,omitempty"`
	// Provides metadata when the event `type` is `REDEEM_REWARD`.
	RedeemReward *LoyaltyEventRedeemReward `json:"redeem_reward,omitempty" url:"redeem_reward,omitempty"`
	// Provides metadata when the event `type` is `DELETE_REWARD`.
	DeleteReward *LoyaltyEventDeleteReward `json:"delete_reward,omitempty" url:"delete_reward,omitempty"`
	// Provides metadata when the event `type` is `ADJUST_POINTS`.
	AdjustPoints *LoyaltyEventAdjustPoints `json:"adjust_points,omitempty" url:"adjust_points,omitempty"`
	// The ID of the [loyalty account](entity:LoyaltyAccount) associated with the event.
	LoyaltyAccountId string `json:"loyalty_account_id" url:"loyalty_account_id"`
	// The ID of the [location](entity:Location) where the event occurred.
	LocationId *string `json:"location_id,omitempty" url:"location_id,omitempty"`
	// Defines whether the event was generated by the Square Point of Sale.
	// See [LoyaltyEventSource](#type-loyaltyeventsource) for possible values
	Source LoyaltyEventSource `json:"source" url:"source"`
	// Provides metadata when the event `type` is `EXPIRE_POINTS`.
	ExpirePoints *LoyaltyEventExpirePoints `json:"expire_points,omitempty" url:"expire_points,omitempty"`
	// Provides metadata when the event `type` is `OTHER`.
	OtherEvent *LoyaltyEventOther `json:"other_event,omitempty" url:"other_event,omitempty"`
	// Provides metadata when the event `type` is `ACCUMULATE_PROMOTION_POINTS`.
	AccumulatePromotionPoints *LoyaltyEventAccumulatePromotionPoints `json:"accumulate_promotion_points,omitempty" url:"accumulate_promotion_points,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *LoyaltyEvent) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LoyaltyEvent) UnmarshalJSON(data []byte) error {
	type unmarshaler LoyaltyEvent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LoyaltyEvent(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *LoyaltyEvent) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Provides metadata when the event `type` is `ACCUMULATE_POINTS`.
type LoyaltyEventAccumulatePoints struct {
	// The ID of the [loyalty program](entity:LoyaltyProgram).
	LoyaltyProgramId *string `json:"loyalty_program_id,omitempty" url:"loyalty_program_id,omitempty"`
	// The number of points accumulated by the event.
	Points *int `json:"points,omitempty" url:"points,omitempty"`
	// The ID of the [order](entity:Order) for which the buyer accumulated the points.
	// This field is returned only if the Orders API is used to process orders.
	OrderId *string `json:"order_id,omitempty" url:"order_id,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *LoyaltyEventAccumulatePoints) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LoyaltyEventAccumulatePoints) UnmarshalJSON(data []byte) error {
	type unmarshaler LoyaltyEventAccumulatePoints
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LoyaltyEventAccumulatePoints(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *LoyaltyEventAccumulatePoints) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Provides metadata when the event `type` is `ACCUMULATE_PROMOTION_POINTS`.
type LoyaltyEventAccumulatePromotionPoints struct {
	// The Square-assigned ID of the [loyalty program](entity:LoyaltyProgram).
	LoyaltyProgramId *string `json:"loyalty_program_id,omitempty" url:"loyalty_program_id,omitempty"`
	// The Square-assigned ID of the [loyalty promotion](entity:LoyaltyPromotion).
	LoyaltyPromotionId *string `json:"loyalty_promotion_id,omitempty" url:"loyalty_promotion_id,omitempty"`
	// The number of points earned by the event.
	Points int `json:"points" url:"points"`
	// The ID of the [order](entity:Order) for which the buyer earned the promotion points.
	// Only applications that use the Orders API to process orders can trigger this event.
	OrderId string `json:"order_id" url:"order_id"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *LoyaltyEventAccumulatePromotionPoints) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LoyaltyEventAccumulatePromotionPoints) UnmarshalJSON(data []byte) error {
	type unmarshaler LoyaltyEventAccumulatePromotionPoints
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LoyaltyEventAccumulatePromotionPoints(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *LoyaltyEventAccumulatePromotionPoints) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Provides metadata when the event `type` is `ADJUST_POINTS`.
type LoyaltyEventAdjustPoints struct {
	// The Square-assigned ID of the [loyalty program](entity:LoyaltyProgram).
	LoyaltyProgramId *string `json:"loyalty_program_id,omitempty" url:"loyalty_program_id,omitempty"`
	// The number of points added or removed.
	Points int `json:"points" url:"points"`
	// The reason for the adjustment of points.
	Reason *string `json:"reason,omitempty" url:"reason,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *LoyaltyEventAdjustPoints) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LoyaltyEventAdjustPoints) UnmarshalJSON(data []byte) error {
	type unmarshaler LoyaltyEventAdjustPoints
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LoyaltyEventAdjustPoints(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *LoyaltyEventAdjustPoints) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Provides metadata when the event `type` is `CREATE_REWARD`.
type LoyaltyEventCreateReward struct {
	// The ID of the [loyalty program](entity:LoyaltyProgram).
	LoyaltyProgramId string `json:"loyalty_program_id" url:"loyalty_program_id"`
	// The Square-assigned ID of the created [loyalty reward](entity:LoyaltyReward).
	// This field is returned only if the event source is `LOYALTY_API`.
	RewardId *string `json:"reward_id,omitempty" url:"reward_id,omitempty"`
	// The loyalty points used to create the reward.
	Points int `json:"points" url:"points"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *LoyaltyEventCreateReward) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LoyaltyEventCreateReward) UnmarshalJSON(data []byte) error {
	type unmarshaler LoyaltyEventCreateReward
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LoyaltyEventCreateReward(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *LoyaltyEventCreateReward) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Published when a [loyalty event](entity:LoyaltyEvent) is created.
type LoyaltyEventCreatedWebhook struct {
	// The ID of the Square seller associated with the event.
	MerchantId *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The type of event. For this event, the value is `loyalty.event.created`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// The unique ID for the event, which is used for
	// [idempotency support](https://developer.squareup.com/docs/webhooks/step4manage#webhooks-best-practices).
	EventId *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// The timestamp of when the webhook event was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The data associated with the event.
	Data *LoyaltyEventCreatedWebhookData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *LoyaltyEventCreatedWebhook) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LoyaltyEventCreatedWebhook) UnmarshalJSON(data []byte) error {
	type unmarshaler LoyaltyEventCreatedWebhook
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LoyaltyEventCreatedWebhook(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *LoyaltyEventCreatedWebhook) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// The data associated with a `loyalty.event.created` webhook event.
type LoyaltyEventCreatedWebhookData struct {
	// The type of object affected by the event. For this event, the value is `loyalty.event`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// ID of the affected loyalty event.
	Id *string `json:"id,omitempty" url:"id,omitempty"`
	// The loyalty event that was created.
	Object *LoyaltyEvent `json:"object,omitempty" url:"object,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *LoyaltyEventCreatedWebhookData) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LoyaltyEventCreatedWebhookData) UnmarshalJSON(data []byte) error {
	type unmarshaler LoyaltyEventCreatedWebhookData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LoyaltyEventCreatedWebhookData(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *LoyaltyEventCreatedWebhookData) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Filter events by date time range.
type LoyaltyEventDateTimeFilter struct {
	// The `created_at` date time range used to filter the result.
	CreatedAt *TimeRange `json:"created_at,omitempty" url:"created_at,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *LoyaltyEventDateTimeFilter) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LoyaltyEventDateTimeFilter) UnmarshalJSON(data []byte) error {
	type unmarshaler LoyaltyEventDateTimeFilter
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LoyaltyEventDateTimeFilter(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *LoyaltyEventDateTimeFilter) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Provides metadata when the event `type` is `DELETE_REWARD`.
type LoyaltyEventDeleteReward struct {
	// The ID of the [loyalty program](entity:LoyaltyProgram).
	LoyaltyProgramId string `json:"loyalty_program_id" url:"loyalty_program_id"`
	// The ID of the deleted [loyalty reward](entity:LoyaltyReward).
	// This field is returned only if the event source is `LOYALTY_API`.
	RewardId *string `json:"reward_id,omitempty" url:"reward_id,omitempty"`
	// The number of points returned to the loyalty account.
	Points int `json:"points" url:"points"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *LoyaltyEventDeleteReward) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LoyaltyEventDeleteReward) UnmarshalJSON(data []byte) error {
	type unmarshaler LoyaltyEventDeleteReward
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LoyaltyEventDeleteReward(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *LoyaltyEventDeleteReward) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Provides metadata when the event `type` is `EXPIRE_POINTS`.
type LoyaltyEventExpirePoints struct {
	// The Square-assigned ID of the [loyalty program](entity:LoyaltyProgram).
	LoyaltyProgramId string `json:"loyalty_program_id" url:"loyalty_program_id"`
	// The number of points expired.
	Points int `json:"points" url:"points"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *LoyaltyEventExpirePoints) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LoyaltyEventExpirePoints) UnmarshalJSON(data []byte) error {
	type unmarshaler LoyaltyEventExpirePoints
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LoyaltyEventExpirePoints(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *LoyaltyEventExpirePoints) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// The filtering criteria. If the request specifies multiple filters,
// the endpoint uses a logical AND to evaluate them.
type LoyaltyEventFilter struct {
	// Filter events by loyalty account.
	LoyaltyAccountFilter *LoyaltyEventLoyaltyAccountFilter `json:"loyalty_account_filter,omitempty" url:"loyalty_account_filter,omitempty"`
	// Filter events by event type.
	TypeFilter *LoyaltyEventTypeFilter `json:"type_filter,omitempty" url:"type_filter,omitempty"`
	// Filter events by date time range.
	// For each range, the start time is inclusive and the end time
	// is exclusive.
	DateTimeFilter *LoyaltyEventDateTimeFilter `json:"date_time_filter,omitempty" url:"date_time_filter,omitempty"`
	// Filter events by location.
	LocationFilter *LoyaltyEventLocationFilter `json:"location_filter,omitempty" url:"location_filter,omitempty"`
	// Filter events by the order associated with the event.
	OrderFilter *LoyaltyEventOrderFilter `json:"order_filter,omitempty" url:"order_filter,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *LoyaltyEventFilter) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LoyaltyEventFilter) UnmarshalJSON(data []byte) error {
	type unmarshaler LoyaltyEventFilter
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LoyaltyEventFilter(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *LoyaltyEventFilter) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Filter events by location.
type LoyaltyEventLocationFilter struct {
	// The [location](entity:Location) IDs for loyalty events to query.
	// If multiple values are specified, the endpoint uses
	// a logical OR to combine them.
	LocationIds []string `json:"location_ids,omitempty" url:"location_ids,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *LoyaltyEventLocationFilter) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LoyaltyEventLocationFilter) UnmarshalJSON(data []byte) error {
	type unmarshaler LoyaltyEventLocationFilter
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LoyaltyEventLocationFilter(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *LoyaltyEventLocationFilter) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Filter events by loyalty account.
type LoyaltyEventLoyaltyAccountFilter struct {
	// The ID of the [loyalty account](entity:LoyaltyAccount) associated with loyalty events.
	LoyaltyAccountId string `json:"loyalty_account_id" url:"loyalty_account_id"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *LoyaltyEventLoyaltyAccountFilter) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LoyaltyEventLoyaltyAccountFilter) UnmarshalJSON(data []byte) error {
	type unmarshaler LoyaltyEventLoyaltyAccountFilter
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LoyaltyEventLoyaltyAccountFilter(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *LoyaltyEventLoyaltyAccountFilter) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Filter events by the order associated with the event.
type LoyaltyEventOrderFilter struct {
	// The ID of the [order](entity:Order) associated with the event.
	OrderId string `json:"order_id" url:"order_id"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *LoyaltyEventOrderFilter) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LoyaltyEventOrderFilter) UnmarshalJSON(data []byte) error {
	type unmarshaler LoyaltyEventOrderFilter
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LoyaltyEventOrderFilter(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *LoyaltyEventOrderFilter) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Provides metadata when the event `type` is `OTHER`.
type LoyaltyEventOther struct {
	// The Square-assigned ID of the [loyalty program](entity:LoyaltyProgram).
	LoyaltyProgramId string `json:"loyalty_program_id" url:"loyalty_program_id"`
	// The number of points added or removed.
	Points int `json:"points" url:"points"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *LoyaltyEventOther) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LoyaltyEventOther) UnmarshalJSON(data []byte) error {
	type unmarshaler LoyaltyEventOther
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LoyaltyEventOther(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *LoyaltyEventOther) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Provides metadata when the event `type` is `REDEEM_REWARD`.
type LoyaltyEventRedeemReward struct {
	// The ID of the [loyalty program](entity:LoyaltyProgram).
	LoyaltyProgramId string `json:"loyalty_program_id" url:"loyalty_program_id"`
	// The ID of the redeemed [loyalty reward](entity:LoyaltyReward).
	// This field is returned only if the event source is `LOYALTY_API`.
	RewardId *string `json:"reward_id,omitempty" url:"reward_id,omitempty"`
	// The ID of the [order](entity:Order) that redeemed the reward.
	// This field is returned only if the Orders API is used to process orders.
	OrderId *string `json:"order_id,omitempty" url:"order_id,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *LoyaltyEventRedeemReward) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LoyaltyEventRedeemReward) UnmarshalJSON(data []byte) error {
	type unmarshaler LoyaltyEventRedeemReward
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LoyaltyEventRedeemReward(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *LoyaltyEventRedeemReward) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Defines whether the event was generated by the Square Point of Sale.
type LoyaltyEventSource string

const (
	LoyaltyEventSourceSourceDoNotUse LoyaltyEventSource = "SOURCE_DO_NOT_USE"
	LoyaltyEventSourceSquare         LoyaltyEventSource = "SQUARE"
	LoyaltyEventSourceLoyaltyApi     LoyaltyEventSource = "LOYALTY_API"
)

func NewLoyaltyEventSourceFromString(s string) (LoyaltyEventSource, error) {
	switch s {
	case "SOURCE_DO_NOT_USE":
		return LoyaltyEventSourceSourceDoNotUse, nil
	case "SQUARE":
		return LoyaltyEventSourceSquare, nil
	case "LOYALTY_API":
		return LoyaltyEventSourceLoyaltyApi, nil
	}
	var t LoyaltyEventSource
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (l LoyaltyEventSource) Ptr() *LoyaltyEventSource {
	return &l
}

// The type of the loyalty event.
type LoyaltyEventType string

const (
	LoyaltyEventTypeTypeDoNotUse              LoyaltyEventType = "TYPE_DO_NOT_USE"
	LoyaltyEventTypeCreateAccount             LoyaltyEventType = "CREATE_ACCOUNT"
	LoyaltyEventTypeAccumulatePoints          LoyaltyEventType = "ACCUMULATE_POINTS"
	LoyaltyEventTypeCreateReward              LoyaltyEventType = "CREATE_REWARD"
	LoyaltyEventTypeRedeemReward              LoyaltyEventType = "REDEEM_REWARD"
	LoyaltyEventTypeDeleteReward              LoyaltyEventType = "DELETE_REWARD"
	LoyaltyEventTypeAdjustPoints              LoyaltyEventType = "ADJUST_POINTS"
	LoyaltyEventTypeExpirePoints              LoyaltyEventType = "EXPIRE_POINTS"
	LoyaltyEventTypeOther                     LoyaltyEventType = "OTHER"
	LoyaltyEventTypeAccumulatePromotionPoints LoyaltyEventType = "ACCUMULATE_PROMOTION_POINTS"
)

func NewLoyaltyEventTypeFromString(s string) (LoyaltyEventType, error) {
	switch s {
	case "TYPE_DO_NOT_USE":
		return LoyaltyEventTypeTypeDoNotUse, nil
	case "CREATE_ACCOUNT":
		return LoyaltyEventTypeCreateAccount, nil
	case "ACCUMULATE_POINTS":
		return LoyaltyEventTypeAccumulatePoints, nil
	case "CREATE_REWARD":
		return LoyaltyEventTypeCreateReward, nil
	case "REDEEM_REWARD":
		return LoyaltyEventTypeRedeemReward, nil
	case "DELETE_REWARD":
		return LoyaltyEventTypeDeleteReward, nil
	case "ADJUST_POINTS":
		return LoyaltyEventTypeAdjustPoints, nil
	case "EXPIRE_POINTS":
		return LoyaltyEventTypeExpirePoints, nil
	case "OTHER":
		return LoyaltyEventTypeOther, nil
	case "ACCUMULATE_PROMOTION_POINTS":
		return LoyaltyEventTypeAccumulatePromotionPoints, nil
	}
	var t LoyaltyEventType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (l LoyaltyEventType) Ptr() *LoyaltyEventType {
	return &l
}

// Filter events by event type.
type LoyaltyEventTypeFilter struct {
	// The loyalty event types used to filter the result.
	// If multiple values are specified, the endpoint uses a
	// logical OR to combine them.
	// See [LoyaltyEventType](#type-loyaltyeventtype) for possible values
	Types []LoyaltyEventType `json:"types,omitempty" url:"types,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *LoyaltyEventTypeFilter) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LoyaltyEventTypeFilter) UnmarshalJSON(data []byte) error {
	type unmarshaler LoyaltyEventTypeFilter
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LoyaltyEventTypeFilter(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *LoyaltyEventTypeFilter) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Represents a Square loyalty program. Loyalty programs define how buyers can earn points and redeem points for rewards.
// Square sellers can have only one loyalty program, which is created and managed from the Seller Dashboard.
// For more information, see [Loyalty Program Overview](https://developer.squareup.com/docs/loyalty/overview).
type LoyaltyProgram struct {
	// The Square-assigned ID of the loyalty program. Updates to
	// the loyalty program do not modify the identifier.
	Id string `json:"id" url:"id"`
	// Whether the program is currently active.
	// See [LoyaltyProgramStatus](#type-loyaltyprogramstatus) for possible values
	Status LoyaltyProgramStatus `json:"status" url:"status"`
	// The list of rewards for buyers, sorted by ascending points.
	RewardTiers []*LoyaltyProgramRewardTier `json:"reward_tiers,omitempty" url:"reward_tiers,omitempty"`
	// If present, details for how points expire.
	ExpirationPolicy *LoyaltyProgramExpirationPolicy `json:"expiration_policy,omitempty" url:"expiration_policy,omitempty"`
	// A cosmetic name for the “points” currency.
	Terminology *LoyaltyProgramTerminology `json:"terminology,omitempty" url:"terminology,omitempty"`
	// The [locations](entity:Location) at which the program is active.
	LocationIds []string `json:"location_ids,omitempty" url:"location_ids,omitempty"`
	// The timestamp when the program was created, in RFC 3339 format.
	CreatedAt string `json:"created_at" url:"created_at"`
	// The timestamp when the reward was last updated, in RFC 3339 format.
	UpdatedAt string `json:"updated_at" url:"updated_at"`
	// Defines how buyers can earn loyalty points from the base loyalty program.
	// To check for associated [loyalty promotions](entity:LoyaltyPromotion) that enable
	// buyers to earn extra points, call [ListLoyaltyPromotions](api-endpoint:Loyalty-ListLoyaltyPromotions).
	AccrualRules []*LoyaltyProgramAccrualRule `json:"accrual_rules,omitempty" url:"accrual_rules,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *LoyaltyProgram) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LoyaltyProgram) UnmarshalJSON(data []byte) error {
	type unmarshaler LoyaltyProgram
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LoyaltyProgram(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *LoyaltyProgram) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Represents an accrual rule, which defines how buyers can earn points from the base [loyalty program](entity:LoyaltyProgram).
type LoyaltyProgramAccrualRule struct {
	// The type of the accrual rule that defines how buyers can earn points.
	// See [LoyaltyProgramAccrualRuleType](#type-loyaltyprogramaccrualruletype) for possible values
	AccrualType LoyaltyProgramAccrualRuleType `json:"accrual_type" url:"accrual_type"`
	// The number of points that
	// buyers earn based on the `accrual_type`.
	Points *int `json:"points,omitempty" url:"points,omitempty"`
	// When the accrual rule is visit-based (`accrual_type` is `VISIT`),
	// this field indicates the minimum purchase required during the visit to
	// quality for the reward.
	VisitMinimumAmountMoney *Money `json:"visit_minimum_amount_money,omitempty" url:"visit_minimum_amount_money,omitempty"`
	// When the accrual rule is spend-based (`accrual_type` is `SPEND`),
	// this field indicates the amount that a buyer must spend
	// to earn the points. For example,
	// suppose the accrual rule is "earn 1 point for every $10 you spend".
	// Then, buyer earns a point for every $10 they spend. If
	// buyer spends $105, the buyer earns 10 points.
	SpendAmountMoney *Money `json:"spend_amount_money,omitempty" url:"spend_amount_money,omitempty"`
	// When the accrual rule is item-based or category-based, this field specifies the ID
	// of the [catalog object](entity:CatalogObject) that buyers can purchase to earn points.
	// If `accrual_type` is `ITEM_VARIATION`, the object is an item variation.
	// If `accrual_type` is `CATEGORY`, the object is a category.
	CatalogObjectId *string `json:"catalog_object_id,omitempty" url:"catalog_object_id,omitempty"`
	// When the accrual rule is spend-based (`accrual_type` is `SPEND`), this field
	// lists the IDs of any `CATEGORY` catalog objects that are excluded from points accrual.
	//
	// You can use the [BatchRetrieveCatalogObjects](api-endpoint:Catalog-BatchRetrieveCatalogObjects)
	// endpoint to retrieve information about the excluded categories.
	ExcludedCategoryIds []string `json:"excluded_category_ids,omitempty" url:"excluded_category_ids,omitempty"`
	// When the accrual rule is spend-based (`accrual_type` is `SPEND`), this field
	// lists the IDs of any `ITEM_VARIATION` catalog objects that are excluded from points accrual.
	//
	// You can use the [BatchRetrieveCatalogObjects](api-endpoint:Catalog-BatchRetrieveCatalogObjects)
	// endpoint to retrieve information about the excluded item variations.
	ExcludedItemVariationIds []string `json:"excluded_item_variation_ids,omitempty" url:"excluded_item_variation_ids,omitempty"`
	// Additional data for rules with the `VISIT` accrual type.
	VisitData *LoyaltyProgramAccrualRuleVisitData `json:"visit_data,omitempty" url:"visit_data,omitempty"`
	// Additional data for rules with the `SPEND` accrual type.
	SpendData *LoyaltyProgramAccrualRuleSpendData `json:"spend_data,omitempty" url:"spend_data,omitempty"`
	// Additional data for rules with the `ITEM_VARIATION` accrual type.
	ItemVariationData *LoyaltyProgramAccrualRuleItemVariationData `json:"item_variation_data,omitempty" url:"item_variation_data,omitempty"`
	// Additional data for rules with the `CATEGORY` accrual type.
	CategoryData *LoyaltyProgramAccrualRuleCategoryData `json:"category_data,omitempty" url:"category_data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *LoyaltyProgramAccrualRule) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LoyaltyProgramAccrualRule) UnmarshalJSON(data []byte) error {
	type unmarshaler LoyaltyProgramAccrualRule
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LoyaltyProgramAccrualRule(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *LoyaltyProgramAccrualRule) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Represents additional data for rules with the `CATEGORY` accrual type.
type LoyaltyProgramAccrualRuleCategoryData struct {
	// The ID of the `CATEGORY` [catalog object](entity:CatalogObject) that buyers can purchase to earn
	// points.
	CategoryId string `json:"category_id" url:"category_id"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *LoyaltyProgramAccrualRuleCategoryData) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LoyaltyProgramAccrualRuleCategoryData) UnmarshalJSON(data []byte) error {
	type unmarshaler LoyaltyProgramAccrualRuleCategoryData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LoyaltyProgramAccrualRuleCategoryData(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *LoyaltyProgramAccrualRuleCategoryData) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Represents additional data for rules with the `ITEM_VARIATION` accrual type.
type LoyaltyProgramAccrualRuleItemVariationData struct {
	// The ID of the `ITEM_VARIATION` [catalog object](entity:CatalogObject) that buyers can purchase to earn
	// points.
	ItemVariationId string `json:"item_variation_id" url:"item_variation_id"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *LoyaltyProgramAccrualRuleItemVariationData) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LoyaltyProgramAccrualRuleItemVariationData) UnmarshalJSON(data []byte) error {
	type unmarshaler LoyaltyProgramAccrualRuleItemVariationData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LoyaltyProgramAccrualRuleItemVariationData(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *LoyaltyProgramAccrualRuleItemVariationData) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Represents additional data for rules with the `SPEND` accrual type.
type LoyaltyProgramAccrualRuleSpendData struct {
	// The amount that buyers must spend to earn points.
	// For example, given an "Earn 1 point for every $10 spent" accrual rule, a buyer who spends $105 earns 10 points.
	AmountMoney *Money `json:"amount_money,omitempty" url:"amount_money,omitempty"`
	// The IDs of any `CATEGORY` catalog objects that are excluded from points accrual.
	//
	// You can use the [BatchRetrieveCatalogObjects](api-endpoint:Catalog-BatchRetrieveCatalogObjects)
	// endpoint to retrieve information about the excluded categories.
	ExcludedCategoryIds []string `json:"excluded_category_ids,omitempty" url:"excluded_category_ids,omitempty"`
	// The IDs of any `ITEM_VARIATION` catalog objects that are excluded from points accrual.
	//
	// You can use the [BatchRetrieveCatalogObjects](api-endpoint:Catalog-BatchRetrieveCatalogObjects)
	// endpoint to retrieve information about the excluded item variations.
	ExcludedItemVariationIds []string `json:"excluded_item_variation_ids,omitempty" url:"excluded_item_variation_ids,omitempty"`
	// Indicates how taxes should be treated when calculating the purchase amount used for points accrual.
	// See [LoyaltyProgramAccrualRuleTaxMode](#type-loyaltyprogramaccrualruletaxmode) for possible values
	TaxMode LoyaltyProgramAccrualRuleTaxMode `json:"tax_mode" url:"tax_mode"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *LoyaltyProgramAccrualRuleSpendData) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LoyaltyProgramAccrualRuleSpendData) UnmarshalJSON(data []byte) error {
	type unmarshaler LoyaltyProgramAccrualRuleSpendData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LoyaltyProgramAccrualRuleSpendData(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *LoyaltyProgramAccrualRuleSpendData) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Indicates how taxes should be treated when calculating the purchase amount used for loyalty points accrual.
// This setting applies only to `SPEND` accrual rules or `VISIT` accrual rules that have a minimum spend requirement.
type LoyaltyProgramAccrualRuleTaxMode string

const (
	LoyaltyProgramAccrualRuleTaxModeTaxModeDoNotUse LoyaltyProgramAccrualRuleTaxMode = "TAX_MODE_DO_NOT_USE"
	LoyaltyProgramAccrualRuleTaxModeBeforeTax       LoyaltyProgramAccrualRuleTaxMode = "BEFORE_TAX"
	LoyaltyProgramAccrualRuleTaxModeAfterTax        LoyaltyProgramAccrualRuleTaxMode = "AFTER_TAX"
)

func NewLoyaltyProgramAccrualRuleTaxModeFromString(s string) (LoyaltyProgramAccrualRuleTaxMode, error) {
	switch s {
	case "TAX_MODE_DO_NOT_USE":
		return LoyaltyProgramAccrualRuleTaxModeTaxModeDoNotUse, nil
	case "BEFORE_TAX":
		return LoyaltyProgramAccrualRuleTaxModeBeforeTax, nil
	case "AFTER_TAX":
		return LoyaltyProgramAccrualRuleTaxModeAfterTax, nil
	}
	var t LoyaltyProgramAccrualRuleTaxMode
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (l LoyaltyProgramAccrualRuleTaxMode) Ptr() *LoyaltyProgramAccrualRuleTaxMode {
	return &l
}

// The type of the accrual rule that defines how buyers can earn points.
type LoyaltyProgramAccrualRuleType string

const (
	LoyaltyProgramAccrualRuleTypeTypeDoNotUse  LoyaltyProgramAccrualRuleType = "TYPE_DO_NOT_USE"
	LoyaltyProgramAccrualRuleTypeVisit         LoyaltyProgramAccrualRuleType = "VISIT"
	LoyaltyProgramAccrualRuleTypeSpend         LoyaltyProgramAccrualRuleType = "SPEND"
	LoyaltyProgramAccrualRuleTypeItemVariation LoyaltyProgramAccrualRuleType = "ITEM_VARIATION"
	LoyaltyProgramAccrualRuleTypeCategory      LoyaltyProgramAccrualRuleType = "CATEGORY"
)

func NewLoyaltyProgramAccrualRuleTypeFromString(s string) (LoyaltyProgramAccrualRuleType, error) {
	switch s {
	case "TYPE_DO_NOT_USE":
		return LoyaltyProgramAccrualRuleTypeTypeDoNotUse, nil
	case "VISIT":
		return LoyaltyProgramAccrualRuleTypeVisit, nil
	case "SPEND":
		return LoyaltyProgramAccrualRuleTypeSpend, nil
	case "ITEM_VARIATION":
		return LoyaltyProgramAccrualRuleTypeItemVariation, nil
	case "CATEGORY":
		return LoyaltyProgramAccrualRuleTypeCategory, nil
	}
	var t LoyaltyProgramAccrualRuleType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (l LoyaltyProgramAccrualRuleType) Ptr() *LoyaltyProgramAccrualRuleType {
	return &l
}

// Represents additional data for rules with the `VISIT` accrual type.
type LoyaltyProgramAccrualRuleVisitData struct {
	// The minimum purchase required during the visit to quality for points.
	MinimumAmountMoney *Money `json:"minimum_amount_money,omitempty" url:"minimum_amount_money,omitempty"`
	// Indicates how taxes should be treated when calculating the purchase amount to determine whether the visit qualifies for points.
	// This setting applies only if `minimum_amount_money` is specified.
	// See [LoyaltyProgramAccrualRuleTaxMode](#type-loyaltyprogramaccrualruletaxmode) for possible values
	TaxMode LoyaltyProgramAccrualRuleTaxMode `json:"tax_mode" url:"tax_mode"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *LoyaltyProgramAccrualRuleVisitData) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LoyaltyProgramAccrualRuleVisitData) UnmarshalJSON(data []byte) error {
	type unmarshaler LoyaltyProgramAccrualRuleVisitData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LoyaltyProgramAccrualRuleVisitData(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *LoyaltyProgramAccrualRuleVisitData) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Published when a [loyalty program](entity:LoyaltyProgram) is created.
type LoyaltyProgramCreatedWebhook struct {
	// The ID of the Square seller associated with the event.
	MerchantId *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The type of event. For this event, the value is `loyalty.program.created`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// The unique ID for the event, which is used for
	// [idempotency support](https://developer.squareup.com/docs/webhooks/step4manage#webhooks-best-practices).
	EventId *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// The timestamp of when the webhook event was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The data associated with the event.
	Data *LoyaltyProgramCreatedWebhookData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *LoyaltyProgramCreatedWebhook) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LoyaltyProgramCreatedWebhook) UnmarshalJSON(data []byte) error {
	type unmarshaler LoyaltyProgramCreatedWebhook
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LoyaltyProgramCreatedWebhook(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *LoyaltyProgramCreatedWebhook) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// The data associated with a `loyalty.program.created` webhook event.
type LoyaltyProgramCreatedWebhookData struct {
	// The type of object affected by the event. For this event, the value is `loyalty.program`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// The ID of the created loyalty program.
	Id *string `json:"id,omitempty" url:"id,omitempty"`
	// An object that contains the loyalty program that was created.
	Object *LoyaltyProgramCreatedWebhookObject `json:"object,omitempty" url:"object,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *LoyaltyProgramCreatedWebhookData) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LoyaltyProgramCreatedWebhookData) UnmarshalJSON(data []byte) error {
	type unmarshaler LoyaltyProgramCreatedWebhookData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LoyaltyProgramCreatedWebhookData(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *LoyaltyProgramCreatedWebhookData) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// An object that contains the loyalty program associated with a `loyalty.program.created` webhook event.
type LoyaltyProgramCreatedWebhookObject struct {
	// The loyalty program that was created.
	LoyaltyProgram *LoyaltyProgram `json:"loyalty_program,omitempty" url:"loyalty_program,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *LoyaltyProgramCreatedWebhookObject) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LoyaltyProgramCreatedWebhookObject) UnmarshalJSON(data []byte) error {
	type unmarshaler LoyaltyProgramCreatedWebhookObject
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LoyaltyProgramCreatedWebhookObject(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *LoyaltyProgramCreatedWebhookObject) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Describes when the loyalty program expires.
type LoyaltyProgramExpirationPolicy struct {
	// The number of months before points expire, in `P[n]M` RFC 3339 duration format. For example, a value of `P12M` represents a duration of 12 months.
	// Points are valid through the last day of the month in which they are scheduled to expire. For example, with a `P12M` duration, points earned on July 6, 2020 expire on August 1, 2021.
	ExpirationDuration string `json:"expiration_duration" url:"expiration_duration"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *LoyaltyProgramExpirationPolicy) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LoyaltyProgramExpirationPolicy) UnmarshalJSON(data []byte) error {
	type unmarshaler LoyaltyProgramExpirationPolicy
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LoyaltyProgramExpirationPolicy(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *LoyaltyProgramExpirationPolicy) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Provides details about the reward tier discount. DEPRECATED at version 2020-12-16. Discount details
// are now defined using a catalog pricing rule and other catalog objects. For more information, see
// [Getting discount details for a reward tier](https://developer.squareup.com/docs/loyalty-api/loyalty-rewards#get-discount-details).
type LoyaltyProgramRewardDefinition struct {
	// Indicates the scope of the reward tier. DEPRECATED at version 2020-12-16. You can find this information in the
	// `discount_target_scope` field of the `PRICING_RULE` catalog object and the `product_set_data` field of the `PRODUCT_SET`
	// catalog object referenced by the pricing rule. For `ORDER` scopes, the target scope is `WHOLE_PURCHASE` and `all_products`
	// is true. For `ITEM_VARIATION` and `CATEGORY` scopes, the target scope is `LINE_ITEM` and `product_ids_any` is a list of
	// catalog object IDs of the given type.
	// See [LoyaltyProgramRewardDefinitionScope](#type-loyaltyprogramrewarddefinitionscope) for possible values
	Scope LoyaltyProgramRewardDefinitionScope `json:"scope" url:"scope"`
	// The type of discount the reward tier offers. DEPRECATED at version 2020-12-16. You can find this information
	// in the `discount_data.discount_type` field of the `DISCOUNT` catalog object referenced by the pricing rule.
	// See [LoyaltyProgramRewardDefinitionType](#type-loyaltyprogramrewarddefinitiontype) for possible values
	DiscountType LoyaltyProgramRewardDefinitionType `json:"discount_type" url:"discount_type"`
	// The fixed percentage of the discount. Present if `discount_type` is `FIXED_PERCENTAGE`.
	// For example, a 7.25% off discount will be represented as "7.25". DEPRECATED at version 2020-12-16. You can find this
	// information in the `discount_data.percentage` field of the `DISCOUNT` catalog object referenced by the pricing rule.
	PercentageDiscount *string `json:"percentage_discount,omitempty" url:"percentage_discount,omitempty"`
	// The list of catalog objects to which this reward can be applied. They are either all item-variation ids or category ids, depending on the `type` field.
	// DEPRECATED at version 2020-12-16. You can find this information in the `product_set_data.product_ids_any` field
	// of the `PRODUCT_SET` catalog object referenced by the pricing rule.
	CatalogObjectIds []string `json:"catalog_object_ids,omitempty" url:"catalog_object_ids,omitempty"`
	// The amount of the discount. Present if `discount_type` is `FIXED_AMOUNT`. For example, $5 off.
	// DEPRECATED at version 2020-12-16. You can find this information in the `discount_data.amount_money` field of the
	// `DISCOUNT` catalog object referenced by the pricing rule.
	FixedDiscountMoney *Money `json:"fixed_discount_money,omitempty" url:"fixed_discount_money,omitempty"`
	// When `discount_type` is `FIXED_PERCENTAGE`, the maximum discount amount that can be applied.
	// DEPRECATED at version 2020-12-16. You can find this information in the `discount_data.maximum_amount_money` field
	// of the `DISCOUNT` catalog object referenced by the the pricing rule.
	MaxDiscountMoney *Money `json:"max_discount_money,omitempty" url:"max_discount_money,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *LoyaltyProgramRewardDefinition) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LoyaltyProgramRewardDefinition) UnmarshalJSON(data []byte) error {
	type unmarshaler LoyaltyProgramRewardDefinition
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LoyaltyProgramRewardDefinition(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *LoyaltyProgramRewardDefinition) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Indicates the scope of the reward tier. DEPRECATED at version 2020-12-16. Discount details
// are now defined using a catalog pricing rule and other catalog objects. For more information, see
// [Getting discount details for a reward tier](https://developer.squareup.com/docs/loyalty-api/loyalty-rewards#get-discount-details).
type LoyaltyProgramRewardDefinitionScope string

const (
	LoyaltyProgramRewardDefinitionScopeScopeDoNotUse LoyaltyProgramRewardDefinitionScope = "SCOPE_DO_NOT_USE"
	LoyaltyProgramRewardDefinitionScopeOrder         LoyaltyProgramRewardDefinitionScope = "ORDER"
	LoyaltyProgramRewardDefinitionScopeItemVariation LoyaltyProgramRewardDefinitionScope = "ITEM_VARIATION"
	LoyaltyProgramRewardDefinitionScopeCategory      LoyaltyProgramRewardDefinitionScope = "CATEGORY"
)

func NewLoyaltyProgramRewardDefinitionScopeFromString(s string) (LoyaltyProgramRewardDefinitionScope, error) {
	switch s {
	case "SCOPE_DO_NOT_USE":
		return LoyaltyProgramRewardDefinitionScopeScopeDoNotUse, nil
	case "ORDER":
		return LoyaltyProgramRewardDefinitionScopeOrder, nil
	case "ITEM_VARIATION":
		return LoyaltyProgramRewardDefinitionScopeItemVariation, nil
	case "CATEGORY":
		return LoyaltyProgramRewardDefinitionScopeCategory, nil
	}
	var t LoyaltyProgramRewardDefinitionScope
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (l LoyaltyProgramRewardDefinitionScope) Ptr() *LoyaltyProgramRewardDefinitionScope {
	return &l
}

// The type of discount the reward tier offers. DEPRECATED at version 2020-12-16. Discount details
// are now defined using a catalog pricing rule and other catalog objects. For more information, see
// [Getting discount details for a reward tier](https://developer.squareup.com/docs/loyalty-api/loyalty-rewards#get-discount-details).
type LoyaltyProgramRewardDefinitionType string

const (
	LoyaltyProgramRewardDefinitionTypeTypeDoNotUse    LoyaltyProgramRewardDefinitionType = "TYPE_DO_NOT_USE"
	LoyaltyProgramRewardDefinitionTypeFixedAmount     LoyaltyProgramRewardDefinitionType = "FIXED_AMOUNT"
	LoyaltyProgramRewardDefinitionTypeFixedPercentage LoyaltyProgramRewardDefinitionType = "FIXED_PERCENTAGE"
)

func NewLoyaltyProgramRewardDefinitionTypeFromString(s string) (LoyaltyProgramRewardDefinitionType, error) {
	switch s {
	case "TYPE_DO_NOT_USE":
		return LoyaltyProgramRewardDefinitionTypeTypeDoNotUse, nil
	case "FIXED_AMOUNT":
		return LoyaltyProgramRewardDefinitionTypeFixedAmount, nil
	case "FIXED_PERCENTAGE":
		return LoyaltyProgramRewardDefinitionTypeFixedPercentage, nil
	}
	var t LoyaltyProgramRewardDefinitionType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (l LoyaltyProgramRewardDefinitionType) Ptr() *LoyaltyProgramRewardDefinitionType {
	return &l
}

// Represents a reward tier in a loyalty program. A reward tier defines how buyers can redeem points for a reward, such as the number of points required and the value and scope of the discount. A loyalty program can offer multiple reward tiers.
type LoyaltyProgramRewardTier struct {
	// The Square-assigned ID of the reward tier.
	Id string `json:"id" url:"id"`
	// The points exchanged for the reward tier.
	Points int `json:"points" url:"points"`
	// The name of the reward tier.
	Name string `json:"name" url:"name"`
	// Provides details about the reward tier definition.
	// DEPRECATED at version 2020-12-16. Replaced by the `pricing_rule_reference` field.
	Definition *LoyaltyProgramRewardDefinition `json:"definition,omitempty" url:"definition,omitempty"`
	// The timestamp when the reward tier was created, in RFC 3339 format.
	CreatedAt string `json:"created_at" url:"created_at"`
	// A reference to the specific version of a `PRICING_RULE` catalog object that contains information about the reward tier discount.
	//
	// Use `object_id` and `catalog_version` with the [RetrieveCatalogObject](api-endpoint:Catalog-RetrieveCatalogObject) endpoint
	// to get discount details. Make sure to set `include_related_objects` to true in the request to retrieve all catalog objects
	// that define the discount. For more information, see [Getting discount details for a reward tier](https://developer.squareup.com/docs/loyalty-api/loyalty-rewards#get-discount-details).
	PricingRuleReference *CatalogObjectReference `json:"pricing_rule_reference,omitempty" url:"pricing_rule_reference,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *LoyaltyProgramRewardTier) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LoyaltyProgramRewardTier) UnmarshalJSON(data []byte) error {
	type unmarshaler LoyaltyProgramRewardTier
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LoyaltyProgramRewardTier(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *LoyaltyProgramRewardTier) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Indicates whether the program is currently active.
type LoyaltyProgramStatus string

const (
	LoyaltyProgramStatusStatusDoNotUse LoyaltyProgramStatus = "STATUS_DO_NOT_USE"
	LoyaltyProgramStatusInactive       LoyaltyProgramStatus = "INACTIVE"
	LoyaltyProgramStatusActive         LoyaltyProgramStatus = "ACTIVE"
)

func NewLoyaltyProgramStatusFromString(s string) (LoyaltyProgramStatus, error) {
	switch s {
	case "STATUS_DO_NOT_USE":
		return LoyaltyProgramStatusStatusDoNotUse, nil
	case "INACTIVE":
		return LoyaltyProgramStatusInactive, nil
	case "ACTIVE":
		return LoyaltyProgramStatusActive, nil
	}
	var t LoyaltyProgramStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (l LoyaltyProgramStatus) Ptr() *LoyaltyProgramStatus {
	return &l
}

// Represents the naming used for loyalty points.
type LoyaltyProgramTerminology struct {
	// A singular unit for a point (for example, 1 point is called 1 star).
	One string `json:"one" url:"one"`
	// A plural unit for point (for example, 10 points is called 10 stars).
	Other string `json:"other" url:"other"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *LoyaltyProgramTerminology) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LoyaltyProgramTerminology) UnmarshalJSON(data []byte) error {
	type unmarshaler LoyaltyProgramTerminology
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LoyaltyProgramTerminology(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *LoyaltyProgramTerminology) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Published when a [loyalty program](entity:LoyaltyProgram) is updated.
type LoyaltyProgramUpdatedWebhook struct {
	// The ID of the Square seller associated with the event.
	MerchantId *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The type of event. For this event, the value is `loyalty.program.updated`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// The unique ID for the event, which is used for
	// [idempotency support](https://developer.squareup.com/docs/webhooks/step4manage#webhooks-best-practices).
	EventId *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// The timestamp of when the webhook event was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The data associated with the event.
	Data *LoyaltyProgramUpdatedWebhookData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *LoyaltyProgramUpdatedWebhook) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LoyaltyProgramUpdatedWebhook) UnmarshalJSON(data []byte) error {
	type unmarshaler LoyaltyProgramUpdatedWebhook
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LoyaltyProgramUpdatedWebhook(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *LoyaltyProgramUpdatedWebhook) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// The data associated with a `loyalty.program.updated` webhook event.
type LoyaltyProgramUpdatedWebhookData struct {
	// The type of object affected by the event. For this event, the value is `loyalty.program`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// The ID of the affected loyalty program.
	Id *string `json:"id,omitempty" url:"id,omitempty"`
	// The loyalty program that was updated.
	Object *LoyaltyProgram `json:"object,omitempty" url:"object,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *LoyaltyProgramUpdatedWebhookData) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LoyaltyProgramUpdatedWebhookData) UnmarshalJSON(data []byte) error {
	type unmarshaler LoyaltyProgramUpdatedWebhookData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LoyaltyProgramUpdatedWebhookData(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *LoyaltyProgramUpdatedWebhookData) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Represents a promotion for a [loyalty program](entity:LoyaltyProgram). Loyalty promotions enable buyers
// to earn extra points on top of those earned from the base program.
//
// A loyalty program can have a maximum of 10 loyalty promotions with an `ACTIVE` or `SCHEDULED` status.
type LoyaltyPromotion struct {
	// The Square-assigned ID of the promotion.
	Id *string `json:"id,omitempty" url:"id,omitempty"`
	// The name of the promotion.
	Name string `json:"name" url:"name"`
	// The points incentive for the promotion. This field defines whether promotion points
	// are earned by multiplying base program points or by adding a specified number of points.
	Incentive *LoyaltyPromotionIncentive `json:"incentive,omitempty" url:"incentive,omitempty"`
	// The scheduling information that defines when purchases can qualify to earn points from an `ACTIVE` promotion.
	AvailableTime *LoyaltyPromotionAvailableTimeData `json:"available_time,omitempty" url:"available_time,omitempty"`
	// The number of times a buyer can earn promotion points during a specified interval.
	// If not specified, buyers can trigger the promotion an unlimited number of times.
	TriggerLimit *LoyaltyPromotionTriggerLimit `json:"trigger_limit,omitempty" url:"trigger_limit,omitempty"`
	// The current status of the promotion.
	// See [LoyaltyPromotionStatus](#type-loyaltypromotionstatus) for possible values
	Status *LoyaltyPromotionStatus `json:"status,omitempty" url:"status,omitempty"`
	// The timestamp of when the promotion was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The timestamp of when the promotion was canceled, in RFC 3339 format.
	CanceledAt *string `json:"canceled_at,omitempty" url:"canceled_at,omitempty"`
	// The timestamp when the promotion was last updated, in RFC 3339 format.
	UpdatedAt *string `json:"updated_at,omitempty" url:"updated_at,omitempty"`
	// The ID of the [loyalty program](entity:LoyaltyProgram) associated with the promotion.
	LoyaltyProgramId *string `json:"loyalty_program_id,omitempty" url:"loyalty_program_id,omitempty"`
	// The minimum purchase amount required to earn promotion points. If specified, this amount is positive.
	MinimumSpendAmountMoney *Money `json:"minimum_spend_amount_money,omitempty" url:"minimum_spend_amount_money,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *LoyaltyPromotion) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LoyaltyPromotion) UnmarshalJSON(data []byte) error {
	type unmarshaler LoyaltyPromotion
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LoyaltyPromotion(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *LoyaltyPromotion) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Represents scheduling information that determines when purchases can qualify to earn points
// from a [loyalty promotion](entity:LoyaltyPromotion).
type LoyaltyPromotionAvailableTimeData struct {
	// The date that the promotion starts, in `YYYY-MM-DD` format. Square populates this field
	// based on the provided `time_periods`.
	StartDate *string `json:"start_date,omitempty" url:"start_date,omitempty"`
	// The date that the promotion ends, in `YYYY-MM-DD` format. Square populates this field
	// based on the provided `time_periods`. If an end date is not specified, an `ACTIVE` promotion
	// remains available until it is canceled.
	EndDate *string `json:"end_date,omitempty" url:"end_date,omitempty"`
	// A list of [iCalendar (RFC 5545) events](https://tools.ietf.org/html/rfc5545#section-3.6.1)
	// (`VEVENT`). Each event represents an available time period per day or days of the week.
	// A day can have a maximum of one available time period.
	//
	// Only `DTSTART`, `DURATION`, and `RRULE` are supported. `DTSTART` and `DURATION` are required and
	// timestamps must be in local (unzoned) time format. Include `RRULE` to specify recurring promotions,
	// an end date (using the `UNTIL` keyword), or both. For more information, see
	// [Available time](https://developer.squareup.com/docs/loyalty-api/loyalty-promotions#available-time).
	//
	// Note that `BEGIN:VEVENT` and `END:VEVENT` are optional in a `CreateLoyaltyPromotion` request
	// but are always included in the response.
	TimePeriods []string `json:"time_periods,omitempty" url:"time_periods,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *LoyaltyPromotionAvailableTimeData) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LoyaltyPromotionAvailableTimeData) UnmarshalJSON(data []byte) error {
	type unmarshaler LoyaltyPromotionAvailableTimeData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LoyaltyPromotionAvailableTimeData(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *LoyaltyPromotionAvailableTimeData) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Published when a [loyalty promotion](entity:LoyaltyPromotion) is created.
type LoyaltyPromotionCreatedWebhook struct {
	// The ID of the Square seller associated with the event.
	MerchantId *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The type of event. For this event, the value is `loyalty.promotion.created`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// The unique ID for the event, which is used for
	// [idempotency support](https://developer.squareup.com/docs/webhooks/step4manage#webhooks-best-practices).
	EventId *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// The timestamp of when the webhook event was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The data associated with the event.
	Data *LoyaltyPromotionCreatedWebhookData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *LoyaltyPromotionCreatedWebhook) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LoyaltyPromotionCreatedWebhook) UnmarshalJSON(data []byte) error {
	type unmarshaler LoyaltyPromotionCreatedWebhook
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LoyaltyPromotionCreatedWebhook(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *LoyaltyPromotionCreatedWebhook) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// The data associated with a `loyalty.promotion.created` webhook event.
type LoyaltyPromotionCreatedWebhookData struct {
	// The type of object affected by the event. For this event, the value is `loyalty.promotion`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// The ID of the affected loyalty promotion.
	Id *string `json:"id,omitempty" url:"id,omitempty"`
	// The loyalty promotion that was created.
	Object *LoyaltyPromotion `json:"object,omitempty" url:"object,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *LoyaltyPromotionCreatedWebhookData) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LoyaltyPromotionCreatedWebhookData) UnmarshalJSON(data []byte) error {
	type unmarshaler LoyaltyPromotionCreatedWebhookData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LoyaltyPromotionCreatedWebhookData(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *LoyaltyPromotionCreatedWebhookData) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Represents how points for a [loyalty promotion](entity:LoyaltyPromotion) are calculated,
// either by multiplying the points earned from the base program or by adding a specified number
// of points to the points earned from the base program.
type LoyaltyPromotionIncentive struct {
	// The type of points incentive.
	// See [LoyaltyPromotionIncentiveType](#type-loyaltypromotionincentivetype) for possible values
	Type LoyaltyPromotionIncentiveType `json:"type" url:"type"`
	// Additional data for a `POINTS_MULTIPLIER` incentive type.
	PointsMultiplierData *LoyaltyPromotionIncentivePointsMultiplierData `json:"points_multiplier_data,omitempty" url:"points_multiplier_data,omitempty"`
	// Additional data for a `POINTS_ADDITION` incentive type.
	PointsAdditionData *LoyaltyPromotionIncentivePointsAdditionData `json:"points_addition_data,omitempty" url:"points_addition_data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *LoyaltyPromotionIncentive) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LoyaltyPromotionIncentive) UnmarshalJSON(data []byte) error {
	type unmarshaler LoyaltyPromotionIncentive
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LoyaltyPromotionIncentive(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *LoyaltyPromotionIncentive) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Represents the metadata for a `POINTS_ADDITION` type of [loyalty promotion incentive](entity:LoyaltyPromotionIncentive).
type LoyaltyPromotionIncentivePointsAdditionData struct {
	// The number of additional points to earn each time the promotion is triggered. For example,
	// suppose a purchase qualifies for 5 points from the base loyalty program. If the purchase also
	// qualifies for a `POINTS_ADDITION` promotion incentive with a `points_addition` of 3, the buyer
	// earns a total of 8 points (5 program points + 3 promotion points = 8 points).
	PointsAddition int `json:"points_addition" url:"points_addition"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *LoyaltyPromotionIncentivePointsAdditionData) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LoyaltyPromotionIncentivePointsAdditionData) UnmarshalJSON(data []byte) error {
	type unmarshaler LoyaltyPromotionIncentivePointsAdditionData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LoyaltyPromotionIncentivePointsAdditionData(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *LoyaltyPromotionIncentivePointsAdditionData) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Represents the metadata for a `POINTS_MULTIPLIER` type of [loyalty promotion incentive](entity:LoyaltyPromotionIncentive).
type LoyaltyPromotionIncentivePointsMultiplierData struct {
	// The multiplier used to calculate the number of points earned each time the promotion
	// is triggered. For example, suppose a purchase qualifies for 5 points from the base loyalty program.
	// If the purchase also qualifies for a `POINTS_MULTIPLIER` promotion incentive with a `points_multiplier`
	// of 3, the buyer earns a total of 15 points (5 program points x 3 promotion multiplier = 15 points).
	PointsMultiplier int `json:"points_multiplier" url:"points_multiplier"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *LoyaltyPromotionIncentivePointsMultiplierData) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LoyaltyPromotionIncentivePointsMultiplierData) UnmarshalJSON(data []byte) error {
	type unmarshaler LoyaltyPromotionIncentivePointsMultiplierData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LoyaltyPromotionIncentivePointsMultiplierData(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *LoyaltyPromotionIncentivePointsMultiplierData) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Indicates the type of points incentive for a [loyalty promotion](entity:LoyaltyPromotion),
// which is used to determine how buyers can earn points from the promotion.
type LoyaltyPromotionIncentiveType string

const (
	LoyaltyPromotionIncentiveTypeTypeDoNotUse     LoyaltyPromotionIncentiveType = "TYPE_DO_NOT_USE"
	LoyaltyPromotionIncentiveTypePointsMultiplier LoyaltyPromotionIncentiveType = "POINTS_MULTIPLIER"
	LoyaltyPromotionIncentiveTypePointsAddition   LoyaltyPromotionIncentiveType = "POINTS_ADDITION"
)

func NewLoyaltyPromotionIncentiveTypeFromString(s string) (LoyaltyPromotionIncentiveType, error) {
	switch s {
	case "TYPE_DO_NOT_USE":
		return LoyaltyPromotionIncentiveTypeTypeDoNotUse, nil
	case "POINTS_MULTIPLIER":
		return LoyaltyPromotionIncentiveTypePointsMultiplier, nil
	case "POINTS_ADDITION":
		return LoyaltyPromotionIncentiveTypePointsAddition, nil
	}
	var t LoyaltyPromotionIncentiveType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (l LoyaltyPromotionIncentiveType) Ptr() *LoyaltyPromotionIncentiveType {
	return &l
}

// Indicates the status of a [loyalty promotion](entity:LoyaltyPromotion).
type LoyaltyPromotionStatus string

const (
	LoyaltyPromotionStatusTypeDoNotUse LoyaltyPromotionStatus = "TYPE_DO_NOT_USE"
	LoyaltyPromotionStatusUpcoming     LoyaltyPromotionStatus = "UPCOMING"
	LoyaltyPromotionStatusActive       LoyaltyPromotionStatus = "ACTIVE"
	LoyaltyPromotionStatusEnded        LoyaltyPromotionStatus = "ENDED"
	LoyaltyPromotionStatusCanceled     LoyaltyPromotionStatus = "CANCELED"
	LoyaltyPromotionStatusScheduled    LoyaltyPromotionStatus = "SCHEDULED"
)

func NewLoyaltyPromotionStatusFromString(s string) (LoyaltyPromotionStatus, error) {
	switch s {
	case "TYPE_DO_NOT_USE":
		return LoyaltyPromotionStatusTypeDoNotUse, nil
	case "UPCOMING":
		return LoyaltyPromotionStatusUpcoming, nil
	case "ACTIVE":
		return LoyaltyPromotionStatusActive, nil
	case "ENDED":
		return LoyaltyPromotionStatusEnded, nil
	case "CANCELED":
		return LoyaltyPromotionStatusCanceled, nil
	case "SCHEDULED":
		return LoyaltyPromotionStatusScheduled, nil
	}
	var t LoyaltyPromotionStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (l LoyaltyPromotionStatus) Ptr() *LoyaltyPromotionStatus {
	return &l
}

// Represents the number of times a buyer can earn points during a [loyalty promotion](entity:LoyaltyPromotion).
// If this field is not set, buyers can trigger the promotion an unlimited number of times to earn points during
// the time that the promotion is available.
//
// A purchase that is disqualified from earning points because of this limit might qualify for another active promotion.
type LoyaltyPromotionTriggerLimit struct {
	// The maximum number of times a buyer can trigger the promotion during the specified `interval`.
	Times int `json:"times" url:"times"`
	// The time period the limit applies to.
	// See [LoyaltyPromotionTriggerLimitInterval](#type-loyaltypromotiontriggerlimitinterval) for possible values
	Interval *LoyaltyPromotionTriggerLimitInterval `json:"interval,omitempty" url:"interval,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *LoyaltyPromotionTriggerLimit) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LoyaltyPromotionTriggerLimit) UnmarshalJSON(data []byte) error {
	type unmarshaler LoyaltyPromotionTriggerLimit
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LoyaltyPromotionTriggerLimit(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *LoyaltyPromotionTriggerLimit) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Indicates the time period that the [trigger limit](entity:LoyaltyPromotionTriggerLimit) applies to,
// which is used to determine the number of times a buyer can earn points for a [loyalty promotion](entity:LoyaltyPromotion).
type LoyaltyPromotionTriggerLimitInterval string

const (
	LoyaltyPromotionTriggerLimitIntervalTypeDoNotUse LoyaltyPromotionTriggerLimitInterval = "TYPE_DO_NOT_USE"
	LoyaltyPromotionTriggerLimitIntervalAllTime      LoyaltyPromotionTriggerLimitInterval = "ALL_TIME"
	LoyaltyPromotionTriggerLimitIntervalDay          LoyaltyPromotionTriggerLimitInterval = "DAY"
)

func NewLoyaltyPromotionTriggerLimitIntervalFromString(s string) (LoyaltyPromotionTriggerLimitInterval, error) {
	switch s {
	case "TYPE_DO_NOT_USE":
		return LoyaltyPromotionTriggerLimitIntervalTypeDoNotUse, nil
	case "ALL_TIME":
		return LoyaltyPromotionTriggerLimitIntervalAllTime, nil
	case "DAY":
		return LoyaltyPromotionTriggerLimitIntervalDay, nil
	}
	var t LoyaltyPromotionTriggerLimitInterval
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (l LoyaltyPromotionTriggerLimitInterval) Ptr() *LoyaltyPromotionTriggerLimitInterval {
	return &l
}

// Published when a [loyalty promotion](entity:LoyaltyPromotion) is updated. This event is
// invoked only when a loyalty promotion is canceled.
type LoyaltyPromotionUpdatedWebhook struct {
	// The ID of the Square seller associated with the event.
	MerchantId *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The type of event. For this event, the value is `loyalty.promotion.updated`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// The unique ID for the event, which is used for
	// [idempotency support](https://developer.squareup.com/docs/webhooks/step4manage#webhooks-best-practices).
	EventId *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// The timestamp of when the event was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The data associated with the event.
	Data *LoyaltyPromotionUpdatedWebhookData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *LoyaltyPromotionUpdatedWebhook) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LoyaltyPromotionUpdatedWebhook) UnmarshalJSON(data []byte) error {
	type unmarshaler LoyaltyPromotionUpdatedWebhook
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LoyaltyPromotionUpdatedWebhook(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *LoyaltyPromotionUpdatedWebhook) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// The data associated with a `loyalty.promotion.updated` webhook event.
type LoyaltyPromotionUpdatedWebhookData struct {
	// The type of object affected by the event. For this event, the value is `loyalty.promotion`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// The ID of the affected loyalty promotion.
	Id *string `json:"id,omitempty" url:"id,omitempty"`
	// The loyalty promotion that was updated.
	Object *LoyaltyPromotion `json:"object,omitempty" url:"object,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *LoyaltyPromotionUpdatedWebhookData) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LoyaltyPromotionUpdatedWebhookData) UnmarshalJSON(data []byte) error {
	type unmarshaler LoyaltyPromotionUpdatedWebhookData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LoyaltyPromotionUpdatedWebhookData(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *LoyaltyPromotionUpdatedWebhookData) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Represents a contract to redeem loyalty points for a [reward tier](entity:LoyaltyProgramRewardTier) discount. Loyalty rewards can be in an ISSUED, REDEEMED, or DELETED state.
// For more information, see [Manage loyalty rewards](https://developer.squareup.com/docs/loyalty-api/loyalty-rewards).
type LoyaltyReward struct {
	// The Square-assigned ID of the loyalty reward.
	Id *string `json:"id,omitempty" url:"id,omitempty"`
	// The status of a loyalty reward.
	// See [LoyaltyRewardStatus](#type-loyaltyrewardstatus) for possible values
	Status *LoyaltyRewardStatus `json:"status,omitempty" url:"status,omitempty"`
	// The Square-assigned ID of the [loyalty account](entity:LoyaltyAccount) to which the reward belongs.
	LoyaltyAccountId string `json:"loyalty_account_id" url:"loyalty_account_id"`
	// The Square-assigned ID of the [reward tier](entity:LoyaltyProgramRewardTier) used to create the reward.
	RewardTierId string `json:"reward_tier_id" url:"reward_tier_id"`
	// The number of loyalty points used for the reward.
	Points *int `json:"points,omitempty" url:"points,omitempty"`
	// The Square-assigned ID of the [order](entity:Order) to which the reward is attached.
	OrderId *string `json:"order_id,omitempty" url:"order_id,omitempty"`
	// The timestamp when the reward was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The timestamp when the reward was last updated, in RFC 3339 format.
	UpdatedAt *string `json:"updated_at,omitempty" url:"updated_at,omitempty"`
	// The timestamp when the reward was redeemed, in RFC 3339 format.
	RedeemedAt *string `json:"redeemed_at,omitempty" url:"redeemed_at,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *LoyaltyReward) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LoyaltyReward) UnmarshalJSON(data []byte) error {
	type unmarshaler LoyaltyReward
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LoyaltyReward(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *LoyaltyReward) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// The status of the loyalty reward.
type LoyaltyRewardStatus string

const (
	LoyaltyRewardStatusStatusDoNotUse LoyaltyRewardStatus = "STATUS_DO_NOT_USE"
	LoyaltyRewardStatusIssued         LoyaltyRewardStatus = "ISSUED"
	LoyaltyRewardStatusRedeemed       LoyaltyRewardStatus = "REDEEMED"
	LoyaltyRewardStatusDeleted        LoyaltyRewardStatus = "DELETED"
)

func NewLoyaltyRewardStatusFromString(s string) (LoyaltyRewardStatus, error) {
	switch s {
	case "STATUS_DO_NOT_USE":
		return LoyaltyRewardStatusStatusDoNotUse, nil
	case "ISSUED":
		return LoyaltyRewardStatusIssued, nil
	case "REDEEMED":
		return LoyaltyRewardStatusRedeemed, nil
	case "DELETED":
		return LoyaltyRewardStatusDeleted, nil
	}
	var t LoyaltyRewardStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (l LoyaltyRewardStatus) Ptr() *LoyaltyRewardStatus {
	return &l
}

// Represents a unit of measurement to use with a quantity, such as ounces
// or inches. Exactly one of the following fields are required: `custom_unit`,
// `area_unit`, `length_unit`, `volume_unit`, and `weight_unit`.
type MeasurementUnit struct {
	// A custom unit of measurement defined by the seller using the Point of Sale
	// app or ad-hoc as an order line item.
	CustomUnit *MeasurementUnitCustom `json:"custom_unit,omitempty" url:"custom_unit,omitempty"`
	// Represents a standard area unit.
	// See [MeasurementUnitArea](#type-measurementunitarea) for possible values
	AreaUnit *MeasurementUnitArea `json:"area_unit,omitempty" url:"area_unit,omitempty"`
	// Represents a standard length unit.
	// See [MeasurementUnitLength](#type-measurementunitlength) for possible values
	LengthUnit *MeasurementUnitLength `json:"length_unit,omitempty" url:"length_unit,omitempty"`
	// Represents a standard volume unit.
	// See [MeasurementUnitVolume](#type-measurementunitvolume) for possible values
	VolumeUnit *MeasurementUnitVolume `json:"volume_unit,omitempty" url:"volume_unit,omitempty"`
	// Represents a standard unit of weight or mass.
	// See [MeasurementUnitWeight](#type-measurementunitweight) for possible values
	WeightUnit *MeasurementUnitWeight `json:"weight_unit,omitempty" url:"weight_unit,omitempty"`
	// Reserved for API integrations that lack the ability to specify a real measurement unit
	// See [MeasurementUnitGeneric](#type-measurementunitgeneric) for possible values
	GenericUnit *MeasurementUnitGeneric `json:"generic_unit,omitempty" url:"generic_unit,omitempty"`
	// Represents a standard unit of time.
	// See [MeasurementUnitTime](#type-measurementunittime) for possible values
	TimeUnit *MeasurementUnitTime `json:"time_unit,omitempty" url:"time_unit,omitempty"`
	// Represents the type of the measurement unit.
	// See [MeasurementUnitUnitType](#type-measurementunitunittype) for possible values
	Type *MeasurementUnitUnitType `json:"type,omitempty" url:"type,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (m *MeasurementUnit) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *MeasurementUnit) UnmarshalJSON(data []byte) error {
	type unmarshaler MeasurementUnit
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = MeasurementUnit(value)

	extraProperties, err := core.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties

	m._rawJSON = json.RawMessage(data)
	return nil
}

func (m *MeasurementUnit) String() string {
	if len(m._rawJSON) > 0 {
		if value, err := core.StringifyJSON(m._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

// Unit of area used to measure a quantity.
type MeasurementUnitArea string

const (
	MeasurementUnitAreaInvalidArea            MeasurementUnitArea = "INVALID_AREA"
	MeasurementUnitAreaImperialAcre           MeasurementUnitArea = "IMPERIAL_ACRE"
	MeasurementUnitAreaImperialSquareInch     MeasurementUnitArea = "IMPERIAL_SQUARE_INCH"
	MeasurementUnitAreaImperialSquareFoot     MeasurementUnitArea = "IMPERIAL_SQUARE_FOOT"
	MeasurementUnitAreaImperialSquareYard     MeasurementUnitArea = "IMPERIAL_SQUARE_YARD"
	MeasurementUnitAreaImperialSquareMile     MeasurementUnitArea = "IMPERIAL_SQUARE_MILE"
	MeasurementUnitAreaMetricSquareCentimeter MeasurementUnitArea = "METRIC_SQUARE_CENTIMETER"
	MeasurementUnitAreaMetricSquareMeter      MeasurementUnitArea = "METRIC_SQUARE_METER"
	MeasurementUnitAreaMetricSquareKilometer  MeasurementUnitArea = "METRIC_SQUARE_KILOMETER"
)

func NewMeasurementUnitAreaFromString(s string) (MeasurementUnitArea, error) {
	switch s {
	case "INVALID_AREA":
		return MeasurementUnitAreaInvalidArea, nil
	case "IMPERIAL_ACRE":
		return MeasurementUnitAreaImperialAcre, nil
	case "IMPERIAL_SQUARE_INCH":
		return MeasurementUnitAreaImperialSquareInch, nil
	case "IMPERIAL_SQUARE_FOOT":
		return MeasurementUnitAreaImperialSquareFoot, nil
	case "IMPERIAL_SQUARE_YARD":
		return MeasurementUnitAreaImperialSquareYard, nil
	case "IMPERIAL_SQUARE_MILE":
		return MeasurementUnitAreaImperialSquareMile, nil
	case "METRIC_SQUARE_CENTIMETER":
		return MeasurementUnitAreaMetricSquareCentimeter, nil
	case "METRIC_SQUARE_METER":
		return MeasurementUnitAreaMetricSquareMeter, nil
	case "METRIC_SQUARE_KILOMETER":
		return MeasurementUnitAreaMetricSquareKilometer, nil
	}
	var t MeasurementUnitArea
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (m MeasurementUnitArea) Ptr() *MeasurementUnitArea {
	return &m
}

// The information needed to define a custom unit, provided by the seller.
type MeasurementUnitCustom struct {
	// The name of the custom unit, for example "bushel".
	Name string `json:"name" url:"name"`
	// The abbreviation of the custom unit, such as "bsh" (bushel). This appears
	// in the cart for the Point of Sale app, and in reports.
	Abbreviation string `json:"abbreviation" url:"abbreviation"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (m *MeasurementUnitCustom) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *MeasurementUnitCustom) UnmarshalJSON(data []byte) error {
	type unmarshaler MeasurementUnitCustom
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = MeasurementUnitCustom(value)

	extraProperties, err := core.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties

	m._rawJSON = json.RawMessage(data)
	return nil
}

func (m *MeasurementUnitCustom) String() string {
	if len(m._rawJSON) > 0 {
		if value, err := core.StringifyJSON(m._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

type MeasurementUnitGeneric string

const (
	MeasurementUnitGenericInvalidGenericUnit MeasurementUnitGeneric = "INVALID_GENERIC_UNIT"
	MeasurementUnitGenericUnit               MeasurementUnitGeneric = "UNIT"
)

func NewMeasurementUnitGenericFromString(s string) (MeasurementUnitGeneric, error) {
	switch s {
	case "INVALID_GENERIC_UNIT":
		return MeasurementUnitGenericInvalidGenericUnit, nil
	case "UNIT":
		return MeasurementUnitGenericUnit, nil
	}
	var t MeasurementUnitGeneric
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (m MeasurementUnitGeneric) Ptr() *MeasurementUnitGeneric {
	return &m
}

// The unit of length used to measure a quantity.
type MeasurementUnitLength string

const (
	MeasurementUnitLengthInvalidLength    MeasurementUnitLength = "INVALID_LENGTH"
	MeasurementUnitLengthImperialInch     MeasurementUnitLength = "IMPERIAL_INCH"
	MeasurementUnitLengthImperialFoot     MeasurementUnitLength = "IMPERIAL_FOOT"
	MeasurementUnitLengthImperialYard     MeasurementUnitLength = "IMPERIAL_YARD"
	MeasurementUnitLengthImperialMile     MeasurementUnitLength = "IMPERIAL_MILE"
	MeasurementUnitLengthMetricMillimeter MeasurementUnitLength = "METRIC_MILLIMETER"
	MeasurementUnitLengthMetricCentimeter MeasurementUnitLength = "METRIC_CENTIMETER"
	MeasurementUnitLengthMetricMeter      MeasurementUnitLength = "METRIC_METER"
	MeasurementUnitLengthMetricKilometer  MeasurementUnitLength = "METRIC_KILOMETER"
)

func NewMeasurementUnitLengthFromString(s string) (MeasurementUnitLength, error) {
	switch s {
	case "INVALID_LENGTH":
		return MeasurementUnitLengthInvalidLength, nil
	case "IMPERIAL_INCH":
		return MeasurementUnitLengthImperialInch, nil
	case "IMPERIAL_FOOT":
		return MeasurementUnitLengthImperialFoot, nil
	case "IMPERIAL_YARD":
		return MeasurementUnitLengthImperialYard, nil
	case "IMPERIAL_MILE":
		return MeasurementUnitLengthImperialMile, nil
	case "METRIC_MILLIMETER":
		return MeasurementUnitLengthMetricMillimeter, nil
	case "METRIC_CENTIMETER":
		return MeasurementUnitLengthMetricCentimeter, nil
	case "METRIC_METER":
		return MeasurementUnitLengthMetricMeter, nil
	case "METRIC_KILOMETER":
		return MeasurementUnitLengthMetricKilometer, nil
	}
	var t MeasurementUnitLength
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (m MeasurementUnitLength) Ptr() *MeasurementUnitLength {
	return &m
}

// Unit of time used to measure a quantity (a duration).
type MeasurementUnitTime string

const (
	MeasurementUnitTimeInvalidTime        MeasurementUnitTime = "INVALID_TIME"
	MeasurementUnitTimeGenericMillisecond MeasurementUnitTime = "GENERIC_MILLISECOND"
	MeasurementUnitTimeGenericSecond      MeasurementUnitTime = "GENERIC_SECOND"
	MeasurementUnitTimeGenericMinute      MeasurementUnitTime = "GENERIC_MINUTE"
	MeasurementUnitTimeGenericHour        MeasurementUnitTime = "GENERIC_HOUR"
	MeasurementUnitTimeGenericDay         MeasurementUnitTime = "GENERIC_DAY"
)

func NewMeasurementUnitTimeFromString(s string) (MeasurementUnitTime, error) {
	switch s {
	case "INVALID_TIME":
		return MeasurementUnitTimeInvalidTime, nil
	case "GENERIC_MILLISECOND":
		return MeasurementUnitTimeGenericMillisecond, nil
	case "GENERIC_SECOND":
		return MeasurementUnitTimeGenericSecond, nil
	case "GENERIC_MINUTE":
		return MeasurementUnitTimeGenericMinute, nil
	case "GENERIC_HOUR":
		return MeasurementUnitTimeGenericHour, nil
	case "GENERIC_DAY":
		return MeasurementUnitTimeGenericDay, nil
	}
	var t MeasurementUnitTime
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (m MeasurementUnitTime) Ptr() *MeasurementUnitTime {
	return &m
}

// Describes the type of this unit and indicates which field contains the unit information. This is an ‘open’ enum.
type MeasurementUnitUnitType string

const (
	MeasurementUnitUnitTypeInvalidType MeasurementUnitUnitType = "INVALID_TYPE"
	MeasurementUnitUnitTypeTypeCustom  MeasurementUnitUnitType = "TYPE_CUSTOM"
	MeasurementUnitUnitTypeTypeArea    MeasurementUnitUnitType = "TYPE_AREA"
	MeasurementUnitUnitTypeTypeLength  MeasurementUnitUnitType = "TYPE_LENGTH"
	MeasurementUnitUnitTypeTypeVolume  MeasurementUnitUnitType = "TYPE_VOLUME"
	MeasurementUnitUnitTypeTypeWeight  MeasurementUnitUnitType = "TYPE_WEIGHT"
	MeasurementUnitUnitTypeTypeTime    MeasurementUnitUnitType = "TYPE_TIME"
	MeasurementUnitUnitTypeTypeGeneric MeasurementUnitUnitType = "TYPE_GENERIC"
)

func NewMeasurementUnitUnitTypeFromString(s string) (MeasurementUnitUnitType, error) {
	switch s {
	case "INVALID_TYPE":
		return MeasurementUnitUnitTypeInvalidType, nil
	case "TYPE_CUSTOM":
		return MeasurementUnitUnitTypeTypeCustom, nil
	case "TYPE_AREA":
		return MeasurementUnitUnitTypeTypeArea, nil
	case "TYPE_LENGTH":
		return MeasurementUnitUnitTypeTypeLength, nil
	case "TYPE_VOLUME":
		return MeasurementUnitUnitTypeTypeVolume, nil
	case "TYPE_WEIGHT":
		return MeasurementUnitUnitTypeTypeWeight, nil
	case "TYPE_TIME":
		return MeasurementUnitUnitTypeTypeTime, nil
	case "TYPE_GENERIC":
		return MeasurementUnitUnitTypeTypeGeneric, nil
	}
	var t MeasurementUnitUnitType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (m MeasurementUnitUnitType) Ptr() *MeasurementUnitUnitType {
	return &m
}

// The unit of volume used to measure a quantity.
type MeasurementUnitVolume string

const (
	MeasurementUnitVolumeInvalidVolume     MeasurementUnitVolume = "INVALID_VOLUME"
	MeasurementUnitVolumeGenericFluidOunce MeasurementUnitVolume = "GENERIC_FLUID_OUNCE"
	MeasurementUnitVolumeGenericShot       MeasurementUnitVolume = "GENERIC_SHOT"
	MeasurementUnitVolumeGenericCup        MeasurementUnitVolume = "GENERIC_CUP"
	MeasurementUnitVolumeGenericPint       MeasurementUnitVolume = "GENERIC_PINT"
	MeasurementUnitVolumeGenericQuart      MeasurementUnitVolume = "GENERIC_QUART"
	MeasurementUnitVolumeGenericGallon     MeasurementUnitVolume = "GENERIC_GALLON"
	MeasurementUnitVolumeImperialCubicInch MeasurementUnitVolume = "IMPERIAL_CUBIC_INCH"
	MeasurementUnitVolumeImperialCubicFoot MeasurementUnitVolume = "IMPERIAL_CUBIC_FOOT"
	MeasurementUnitVolumeImperialCubicYard MeasurementUnitVolume = "IMPERIAL_CUBIC_YARD"
	MeasurementUnitVolumeMetricMilliliter  MeasurementUnitVolume = "METRIC_MILLILITER"
	MeasurementUnitVolumeMetricLiter       MeasurementUnitVolume = "METRIC_LITER"
)

func NewMeasurementUnitVolumeFromString(s string) (MeasurementUnitVolume, error) {
	switch s {
	case "INVALID_VOLUME":
		return MeasurementUnitVolumeInvalidVolume, nil
	case "GENERIC_FLUID_OUNCE":
		return MeasurementUnitVolumeGenericFluidOunce, nil
	case "GENERIC_SHOT":
		return MeasurementUnitVolumeGenericShot, nil
	case "GENERIC_CUP":
		return MeasurementUnitVolumeGenericCup, nil
	case "GENERIC_PINT":
		return MeasurementUnitVolumeGenericPint, nil
	case "GENERIC_QUART":
		return MeasurementUnitVolumeGenericQuart, nil
	case "GENERIC_GALLON":
		return MeasurementUnitVolumeGenericGallon, nil
	case "IMPERIAL_CUBIC_INCH":
		return MeasurementUnitVolumeImperialCubicInch, nil
	case "IMPERIAL_CUBIC_FOOT":
		return MeasurementUnitVolumeImperialCubicFoot, nil
	case "IMPERIAL_CUBIC_YARD":
		return MeasurementUnitVolumeImperialCubicYard, nil
	case "METRIC_MILLILITER":
		return MeasurementUnitVolumeMetricMilliliter, nil
	case "METRIC_LITER":
		return MeasurementUnitVolumeMetricLiter, nil
	}
	var t MeasurementUnitVolume
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (m MeasurementUnitVolume) Ptr() *MeasurementUnitVolume {
	return &m
}

// Unit of weight used to measure a quantity.
type MeasurementUnitWeight string

const (
	MeasurementUnitWeightInvalidWeight       MeasurementUnitWeight = "INVALID_WEIGHT"
	MeasurementUnitWeightImperialWeightOunce MeasurementUnitWeight = "IMPERIAL_WEIGHT_OUNCE"
	MeasurementUnitWeightImperialPound       MeasurementUnitWeight = "IMPERIAL_POUND"
	MeasurementUnitWeightImperialStone       MeasurementUnitWeight = "IMPERIAL_STONE"
	MeasurementUnitWeightMetricMilligram     MeasurementUnitWeight = "METRIC_MILLIGRAM"
	MeasurementUnitWeightMetricGram          MeasurementUnitWeight = "METRIC_GRAM"
	MeasurementUnitWeightMetricKilogram      MeasurementUnitWeight = "METRIC_KILOGRAM"
)

func NewMeasurementUnitWeightFromString(s string) (MeasurementUnitWeight, error) {
	switch s {
	case "INVALID_WEIGHT":
		return MeasurementUnitWeightInvalidWeight, nil
	case "IMPERIAL_WEIGHT_OUNCE":
		return MeasurementUnitWeightImperialWeightOunce, nil
	case "IMPERIAL_POUND":
		return MeasurementUnitWeightImperialPound, nil
	case "IMPERIAL_STONE":
		return MeasurementUnitWeightImperialStone, nil
	case "METRIC_MILLIGRAM":
		return MeasurementUnitWeightMetricMilligram, nil
	case "METRIC_GRAM":
		return MeasurementUnitWeightMetricGram, nil
	case "METRIC_KILOGRAM":
		return MeasurementUnitWeightMetricKilogram, nil
	}
	var t MeasurementUnitWeight
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (m MeasurementUnitWeight) Ptr() *MeasurementUnitWeight {
	return &m
}

// Represents a business that sells with Square.
type Merchant struct {
	// The Square-issued ID of the merchant.
	Id *string `json:"id,omitempty" url:"id,omitempty"`
	// The name of the merchant's overall business.
	BusinessName *string `json:"business_name,omitempty" url:"business_name,omitempty"`
	// The country code associated with the merchant, in the two-letter format of ISO 3166. For example, `US` or `JP`.
	// See [Country](#type-country) for possible values
	Country Country `json:"country" url:"country"`
	// The code indicating the [language preferences](https://developer.squareup.com/docs/build-basics/general-considerations/language-preferences) of the merchant, in [BCP 47 format](https://tools.ietf.org/html/bcp47#appendix-A). For example, `en-US` or `fr-CA`.
	LanguageCode *string `json:"language_code,omitempty" url:"language_code,omitempty"`
	// The currency associated with the merchant, in ISO 4217 format. For example, the currency code for US dollars is `USD`.
	// See [Currency](#type-currency) for possible values
	Currency *Currency `json:"currency,omitempty" url:"currency,omitempty"`
	// The merchant's status.
	// See [MerchantStatus](#type-merchantstatus) for possible values
	Status *MerchantStatus `json:"status,omitempty" url:"status,omitempty"`
	// The ID of the [main `Location`](https://developer.squareup.com/docs/locations-api#about-the-main-location) for this merchant.
	MainLocationId *string `json:"main_location_id,omitempty" url:"main_location_id,omitempty"`
	// The time when the merchant was created, in RFC 3339 format.
	// For more information, see [Working with Dates](https://developer.squareup.com/docs/build-basics/working-with-dates).
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (m *Merchant) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *Merchant) UnmarshalJSON(data []byte) error {
	type unmarshaler Merchant
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = Merchant(value)

	extraProperties, err := core.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties

	m._rawJSON = json.RawMessage(data)
	return nil
}

func (m *Merchant) String() string {
	if len(m._rawJSON) > 0 {
		if value, err := core.StringifyJSON(m._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

type MerchantStatus string

const (
	MerchantStatusActive   MerchantStatus = "ACTIVE"
	MerchantStatusInactive MerchantStatus = "INACTIVE"
)

func NewMerchantStatusFromString(s string) (MerchantStatus, error) {
	switch s {
	case "ACTIVE":
		return MerchantStatusActive, nil
	case "INACTIVE":
		return MerchantStatusInactive, nil
	}
	var t MerchantStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (m MerchantStatus) Ptr() *MerchantStatus {
	return &m
}

// Represents an amount of money. `Money` fields can be signed or unsigned.
// Fields that do not explicitly define whether they are signed or unsigned are
// considered unsigned and can only hold positive amounts. For signed fields, the
// sign of the value indicates the purpose of the money transfer. See
// [Working with Monetary Amounts](https://developer.squareup.com/docs/build-basics/working-with-monetary-amounts)
// for more information.
type Money struct {
	// The amount of money, in the smallest denomination of the currency
	// indicated by `currency`. For example, when `currency` is `USD`, `amount` is
	// in cents. Monetary amounts can be positive or negative. See the specific
	// field description to determine the meaning of the sign in a particular case.
	Amount *int64 `json:"amount,omitempty" url:"amount,omitempty"`
	// The type of currency, in **ISO 4217 format**. For example, the currency
	// code for US dollars is `USD`.
	//
	// See [Currency](entity:Currency) for possible values.
	// See [Currency](#type-currency) for possible values
	Currency *Currency `json:"currency,omitempty" url:"currency,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (m *Money) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *Money) UnmarshalJSON(data []byte) error {
	type unmarshaler Money
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = Money(value)

	extraProperties, err := core.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties

	m._rawJSON = json.RawMessage(data)
	return nil
}

func (m *Money) String() string {
	if len(m._rawJSON) > 0 {
		if value, err := core.StringifyJSON(m._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

// Published when a merchant/application revokes all access tokens and refresh tokens granted to an application.
type OauthAuthorizationRevokedWebhook struct {
	// The ID of the target merchant associated with the event.
	MerchantId *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The type of event this represents, `"oauth.authorization.revoked"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// A unique ID for the webhook event.
	EventId *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// Timestamp of when the webhook event was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// Data associated with the event.
	Data *OauthAuthorizationRevokedWebhookData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (o *OauthAuthorizationRevokedWebhook) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OauthAuthorizationRevokedWebhook) UnmarshalJSON(data []byte) error {
	type unmarshaler OauthAuthorizationRevokedWebhook
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OauthAuthorizationRevokedWebhook(value)

	extraProperties, err := core.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties

	o._rawJSON = json.RawMessage(data)
	return nil
}

func (o *OauthAuthorizationRevokedWebhook) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

type OauthAuthorizationRevokedWebhookData struct {
	// Name of the affected object’s type, `"revocation"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// Not applicable, revocation is not an object
	Id *string `json:"id,omitempty" url:"id,omitempty"`
	// An object containing information about revocation event.
	Object *OauthAuthorizationRevokedWebhookObject `json:"object,omitempty" url:"object,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (o *OauthAuthorizationRevokedWebhookData) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OauthAuthorizationRevokedWebhookData) UnmarshalJSON(data []byte) error {
	type unmarshaler OauthAuthorizationRevokedWebhookData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OauthAuthorizationRevokedWebhookData(value)

	extraProperties, err := core.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties

	o._rawJSON = json.RawMessage(data)
	return nil
}

func (o *OauthAuthorizationRevokedWebhookData) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

type OauthAuthorizationRevokedWebhookObject struct {
	// The revocation event.
	Revocation *OauthAuthorizationRevokedWebhookRevocationObject `json:"revocation,omitempty" url:"revocation,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (o *OauthAuthorizationRevokedWebhookObject) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OauthAuthorizationRevokedWebhookObject) UnmarshalJSON(data []byte) error {
	type unmarshaler OauthAuthorizationRevokedWebhookObject
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OauthAuthorizationRevokedWebhookObject(value)

	extraProperties, err := core.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties

	o._rawJSON = json.RawMessage(data)
	return nil
}

func (o *OauthAuthorizationRevokedWebhookObject) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

type OauthAuthorizationRevokedWebhookRevocationObject struct {
	// Timestamp of when the revocation event occurred, in RFC 3339 format.
	RevokedAt *string `json:"revoked_at,omitempty" url:"revoked_at,omitempty"`
	// Type of client that performed the revocation, either APPLICATION, MERCHANT, or SQUARE.
	// See [OauthAuthorizationRevokedWebhookRevokerType](#type-oauthauthorizationrevokedwebhookrevokertype) for possible values
	RevokerType *OauthAuthorizationRevokedWebhookRevokerType `json:"revoker_type,omitempty" url:"revoker_type,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (o *OauthAuthorizationRevokedWebhookRevocationObject) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OauthAuthorizationRevokedWebhookRevocationObject) UnmarshalJSON(data []byte) error {
	type unmarshaler OauthAuthorizationRevokedWebhookRevocationObject
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OauthAuthorizationRevokedWebhookRevocationObject(value)

	extraProperties, err := core.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties

	o._rawJSON = json.RawMessage(data)
	return nil
}

func (o *OauthAuthorizationRevokedWebhookRevocationObject) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// Defines the possible types for the revoking client.
type OauthAuthorizationRevokedWebhookRevokerType string

const (
	OauthAuthorizationRevokedWebhookRevokerTypeApplication OauthAuthorizationRevokedWebhookRevokerType = "APPLICATION"
	OauthAuthorizationRevokedWebhookRevokerTypeMerchant    OauthAuthorizationRevokedWebhookRevokerType = "MERCHANT"
	OauthAuthorizationRevokedWebhookRevokerTypeSquare      OauthAuthorizationRevokedWebhookRevokerType = "SQUARE"
)

func NewOauthAuthorizationRevokedWebhookRevokerTypeFromString(s string) (OauthAuthorizationRevokedWebhookRevokerType, error) {
	switch s {
	case "APPLICATION":
		return OauthAuthorizationRevokedWebhookRevokerTypeApplication, nil
	case "MERCHANT":
		return OauthAuthorizationRevokedWebhookRevokerTypeMerchant, nil
	case "SQUARE":
		return OauthAuthorizationRevokedWebhookRevokerTypeSquare, nil
	}
	var t OauthAuthorizationRevokedWebhookRevokerType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (o OauthAuthorizationRevokedWebhookRevokerType) Ptr() *OauthAuthorizationRevokedWebhookRevokerType {
	return &o
}

type OauthScope string

const (
	// **HTTP Method**: `GET`
	//
	// Grants read access to bank account information associated with the targeted
	// Square account. For example, to call the Connect v1 ListBankAccounts endpoint.
	OauthScopeBankAccountsRead OauthScope = "BANK_ACCOUNTS_READ"
	// **HTTP Method**: `GET`
	//
	// Grants read access to cash drawer shift information. For example, to call the
	// ListCashDrawerShifts endpoint.
	OauthScopeCashDrawerRead OauthScope = "CASH_DRAWER_READ"
	// **HTTP Method**: `GET`
	//
	// Grants read access to customer information. For example, to call the
	// ListCustomers endpoint.
	OauthScopeCustomersRead OauthScope = "CUSTOMERS_READ"
	// **HTTP Method**: `POST`, `PUT`, `DELETE`
	//
	// Grants write access to customer information. For example, to create and update
	// customer profiles.
	OauthScopeCustomersWrite OauthScope = "CUSTOMERS_WRITE"
	// **HTTP Method**: `POST`, `GET`
	//
	// Grants read/write access to device credentials information. For example, to
	// call the CreateDeviceCode endpoint.
	OauthScopeDeviceCredentialManagement OauthScope = "DEVICE_CREDENTIAL_MANAGEMENT"
	// **HTTP Method**: `GET`
	//
	// Grants read access to employee profile information. For example, to call the
	// Connect v1 Employees API.
	OauthScopeEmployeesRead OauthScope = "EMPLOYEES_READ"
	// **HTTP Method**: `POST`, `PUT`, `DELETE`
	//
	// Grants write access to employee profile information. For example, to create
	// and modify employee profiles.
	OauthScopeEmployeesWrite OauthScope = "EMPLOYEES_WRITE"
	// **HTTP Method**: `GET`
	//
	// Grants read access to inventory information. For example, to call the
	// RetrieveInventoryCount endpoint.
	OauthScopeInventoryRead OauthScope = "INVENTORY_READ"
	// **HTTP Method**: `POST`, `PUT`, `DELETE`
	//
	// Grants write access to inventory information. For example, to call the
	// BatchChangeInventory endpoint.
	OauthScopeInventoryWrite OauthScope = "INVENTORY_WRITE"
	// **HTTP Method**: `GET`
	//
	// Grants read access to business and location information. For example, to
	// obtain a location ID for subsequent activity.
	OauthScopeItemsRead OauthScope = "ITEMS_READ"
	// **HTTP Method**: `POST`, `PUT`, `DELETE`
	//
	// Grants write access to product catalog information. For example, to modify or
	// add to a product catalog.
	OauthScopeItemsWrite OauthScope = "ITEMS_WRITE"
	// **HTTP Method**: `GET`
	//
	// Grants read access to loyalty information. For example, to call the
	// ListLoyaltyPrograms endpoint.
	OauthScopeLoyaltyRead OauthScope = "LOYALTY_READ"
	// **HTTP Method**: `POST`, `PUT`, `DELETE`
	//
	// Grants write access to loyalty information. For example, to call the
	// CreateLoyaltyAccount endpoint.
	OauthScopeLoyaltyWrite OauthScope = "LOYALTY_WRITE"
	// **HTTP Method**: `GET`
	//
	// Grants read access to business and location information. For example, to
	// obtain a location ID for subsequent activity.
	OauthScopeMerchantProfileRead OauthScope = "MERCHANT_PROFILE_READ"
	// **HTTP Method**: `GET`
	//
	// Grants read access to order information. For example, to call the
	// BatchRetrieveOrders endpoint.
	OauthScopeOrdersRead OauthScope = "ORDERS_READ"
	// **HTTP Method**: `POST`, `PUT`, `DELETE`
	//
	// Grants write access to order information. For example, to call the
	// CreateCheckout endpoint.
	OauthScopeOrdersWrite OauthScope = "ORDERS_WRITE"
	// **HTTP Method**: `GET`
	//
	// Grants read access to transaction and refund information. For example, to call
	// the RetrieveTransaction endpoint.
	OauthScopePaymentsRead OauthScope = "PAYMENTS_READ"
	// **HTTP Method**: `POST`, `PUT`, `DELETE`
	//
	// Grants write access to transaction and refunds information. For example, to
	// process payments with the Payments or Checkout API.
	OauthScopePaymentsWrite OauthScope = "PAYMENTS_WRITE"
	// **HTTP Method**: `POST`, `PUT`, `DELETE`
	//
	// Allow third party applications to deduct a portion of each transaction amount.
	// **Required** to use multiparty transaction functionality with the Payments
	// API.
	OauthScopePaymentsWriteAdditionalRecipients OauthScope = "PAYMENTS_WRITE_ADDITIONAL_RECIPIENTS"
	// **HTTP Method**: `POST`, `PUT`, `DELETE`
	//
	// Grants write access to payments and refunds information. For example, to
	// process in-person payments.
	OauthScopePaymentsWriteInPerson OauthScope = "PAYMENTS_WRITE_IN_PERSON"
	// **HTTP Method**: `GET`
	//
	// Grants read access to settlement (deposit) information. For example, to call
	// the Connect v1 ListSettlements endpoint.
	OauthScopeSettlementsRead OauthScope = "SETTLEMENTS_READ"
	// **HTTP Method**: `GET`
	//
	// Grants read access to employee timecard information. For example, to call the
	// Connect v2 SearchShifts endpoint.
	OauthScopeTimecardsRead OauthScope = "TIMECARDS_READ"
	// **HTTP Method**: `POST`, `PUT`, `DELETE`
	//
	// Grants write access to employee shift information. For example, to create
	// and modify employee shifts.
	OauthScopeTimecardsWrite OauthScope = "TIMECARDS_WRITE"
	// **HTTP Method**: `GET`
	//
	// Grants read access to employee timecard settings information. For example, to
	// call the GetBreakType endpoint.
	OauthScopeTimecardsSettingsRead OauthScope = "TIMECARDS_SETTINGS_READ"
	// **HTTP Method**: `POST`, `PUT`, `DELETE`
	//
	// Grants write access to employee timecard settings information. For example, to
	// call the UpdateBreakType endpoint.
	OauthScopeTimecardsSettingsWrite OauthScope = "TIMECARDS_SETTINGS_WRITE"
	// **HTTP Method**: `GET`, `POST`
	//
	// Grants read access to booking information. For example, to call the
	// RetrieveBooking endpoint.
	OauthScopeAppointmentsRead OauthScope = "APPOINTMENTS_READ"
	// **HTTP Method**: `POST`, `PUT`, `DELETE`
	//
	// Grants write access to booking information. For example, to call the CreateBooking endpoint.
	OauthScopeAppointmentsWrite OauthScope = "APPOINTMENTS_WRITE"
	// **HTTP Method**: `GET`
	//
	// Grants read access to booking business settings. For example, to call the
	// ListTeamMemberBookingProfiles endpoint.
	OauthScopeAppointmentsBusinessSettingsRead OauthScope = "APPOINTMENTS_BUSINESS_SETTINGS_READ"
	// **HTTP Method**: `GET`, `POST`
	//
	// Grants read access to invoice information. For example, to call the ListInvoices endpoint.
	OauthScopeInvoicesRead OauthScope = "INVOICES_READ"
	// **HTTP Method**: `POST`, `PUT`, `DELETE`
	//
	// Grants write access to invoice information. For example, to call the CreateInvoice endpoint.
	OauthScopeInvoicesWrite OauthScope = "INVOICES_WRITE"
	// **HTTP Method**: `GET`, `POST`
	//
	// Grants read access to subscription information. For example, to call the RetrieveSubscription
	// endpoint.
	OauthScopeSubscriptionsRead OauthScope = "SUBSCRIPTIONS_READ"
	// **HTTP Method**: `POST`, `PUT`, `DELETE`
	//
	// Grants write access to subscription information. For example, to call the CreateSubscription
	// endpoint.
	OauthScopeSubscriptionsWrite OauthScope = "SUBSCRIPTIONS_WRITE"
	// **HTTP Method**: `GET`
	//
	// Grants read access to dispute information. For example, to call the RetrieveDispute
	// endpoint.
	OauthScopeDisputesRead OauthScope = "DISPUTES_READ"
	// **HTTP Method**: `POST`, `PUT`, `DELETE`
	//
	// Grants write access to dispute information. For example, to call the SubmitEvidence
	// endpoint.
	OauthScopeDisputesWrite OauthScope = "DISPUTES_WRITE"
	// **HTTP Method**: `GET`, `POST`
	//
	// Grants read access to gift card information. For example, to call the RetrieveGiftCard
	// endpoint.
	OauthScopeGiftcardsRead OauthScope = "GIFTCARDS_READ"
	// **HTTP Method**: `POST`, `PUT`, `DELETE`
	//
	// Grants write access to gift card information. For example, to call the CreateGiftCard
	// endpoint.
	OauthScopeGiftcardsWrite OauthScope = "GIFTCARDS_WRITE"
	// **HTTP Method**: `POST`, `PUT`, `DELETE`
	//
	// Write access to ECOM online store snippets on published websites.
	OauthScopeOnlineStoreSnippetsWrite OauthScope = "ONLINE_STORE_SNIPPETS_WRITE"
	// **HTTP Method**: `GET`, `POST`
	//
	// Read access to ECOM online store snippets on published websites.
	OauthScopeOnlineStoreSnippetsRead OauthScope = "ONLINE_STORE_SNIPPETS_READ"
	// **HTTP Method**: `GET`, `POST`
	//
	// Read access to ECOM online store site details.
	OauthScopeOnlineStoreSiteRead OauthScope = "ONLINE_STORE_SITE_READ"
	// **HTTP Method**: `POST`, `PUT`, `DELETE`
	//
	// Allows the developer to process payments on behalf of a seller using a shared on file payment method.
	OauthScopePaymentsWriteSharedOnfile OauthScope = "PAYMENTS_WRITE_SHARED_ONFILE"
	// **HTTP Method**: `GET`, `POST`
	//
	// Grants read access to all of a seller's booking information, calendar, and business details.
	// This permission must be accompanied by the `APPOINTMENTS_READ` permission.
	OauthScopeAppointmentsAllRead OauthScope = "APPOINTMENTS_ALL_READ"
	// **HTTP Method**: `POST`, `PUT`, `DELETE`
	//
	// Grants write access to all booking details, including double-booking a seller.
	// This permission must be accompanied by the `APPOINTMENTS_WRITE` permission.
	OauthScopeAppointmentsAllWrite OauthScope = "APPOINTMENTS_ALL_WRITE"
	// **HTTP Method**: `POST`, `PUT`
	//
	// Grants write access to business and location information. For example, to create a new location or
	// update the business hours at an existing location.
	OauthScopeMerchantProfileWrite OauthScope = "MERCHANT_PROFILE_WRITE"
	// **HTTP Method**: `GET`, `POST`
	//
	// Grants read access to vendor information, for example, when calling the
	// `RetrieveVendor` endpoint.
	OauthScopeVendorRead OauthScope = "VENDOR_READ"
	// **HTTP Method**: `POST`, `PUT`, `DELETE`
	//
	// Grants write access to vendor information, for example, when calling the
	// `BulkUpdateVendors` endpoint.
	OauthScopeVendorWrite OauthScope = "VENDOR_WRITE"
	// **HTTP Method**: `GET`
	//
	// Grants read access to payouts and payout entries information. For example,
	// to call the Connect v2 `ListPayouts` endpoint.
	OauthScopePayoutsRead OauthScope = "PAYOUTS_READ"
	// **HTTP Method**: `GET`
	//
	// Grants read access to reservation information, for example, when calling the
	// `RetrieveReservation` endpoint.
	OauthScopeReservationsRead OauthScope = "RESERVATIONS_READ"
	// **HTTP Method**: `POST`, `PUT`, `DELETE`
	//
	// Grants write access to reservation information, for example, when calling the
	// `CreateReservation` endpoint.
	OauthScopeReservationsWrite OauthScope = "RESERVATIONS_WRITE"
)

func NewOauthScopeFromString(s string) (OauthScope, error) {
	switch s {
	case "BANK_ACCOUNTS_READ":
		return OauthScopeBankAccountsRead, nil
	case "CASH_DRAWER_READ":
		return OauthScopeCashDrawerRead, nil
	case "CUSTOMERS_READ":
		return OauthScopeCustomersRead, nil
	case "CUSTOMERS_WRITE":
		return OauthScopeCustomersWrite, nil
	case "DEVICE_CREDENTIAL_MANAGEMENT":
		return OauthScopeDeviceCredentialManagement, nil
	case "EMPLOYEES_READ":
		return OauthScopeEmployeesRead, nil
	case "EMPLOYEES_WRITE":
		return OauthScopeEmployeesWrite, nil
	case "INVENTORY_READ":
		return OauthScopeInventoryRead, nil
	case "INVENTORY_WRITE":
		return OauthScopeInventoryWrite, nil
	case "ITEMS_READ":
		return OauthScopeItemsRead, nil
	case "ITEMS_WRITE":
		return OauthScopeItemsWrite, nil
	case "LOYALTY_READ":
		return OauthScopeLoyaltyRead, nil
	case "LOYALTY_WRITE":
		return OauthScopeLoyaltyWrite, nil
	case "MERCHANT_PROFILE_READ":
		return OauthScopeMerchantProfileRead, nil
	case "ORDERS_READ":
		return OauthScopeOrdersRead, nil
	case "ORDERS_WRITE":
		return OauthScopeOrdersWrite, nil
	case "PAYMENTS_READ":
		return OauthScopePaymentsRead, nil
	case "PAYMENTS_WRITE":
		return OauthScopePaymentsWrite, nil
	case "PAYMENTS_WRITE_ADDITIONAL_RECIPIENTS":
		return OauthScopePaymentsWriteAdditionalRecipients, nil
	case "PAYMENTS_WRITE_IN_PERSON":
		return OauthScopePaymentsWriteInPerson, nil
	case "SETTLEMENTS_READ":
		return OauthScopeSettlementsRead, nil
	case "TIMECARDS_READ":
		return OauthScopeTimecardsRead, nil
	case "TIMECARDS_WRITE":
		return OauthScopeTimecardsWrite, nil
	case "TIMECARDS_SETTINGS_READ":
		return OauthScopeTimecardsSettingsRead, nil
	case "TIMECARDS_SETTINGS_WRITE":
		return OauthScopeTimecardsSettingsWrite, nil
	case "APPOINTMENTS_READ":
		return OauthScopeAppointmentsRead, nil
	case "APPOINTMENTS_WRITE":
		return OauthScopeAppointmentsWrite, nil
	case "APPOINTMENTS_BUSINESS_SETTINGS_READ":
		return OauthScopeAppointmentsBusinessSettingsRead, nil
	case "INVOICES_READ":
		return OauthScopeInvoicesRead, nil
	case "INVOICES_WRITE":
		return OauthScopeInvoicesWrite, nil
	case "SUBSCRIPTIONS_READ":
		return OauthScopeSubscriptionsRead, nil
	case "SUBSCRIPTIONS_WRITE":
		return OauthScopeSubscriptionsWrite, nil
	case "DISPUTES_READ":
		return OauthScopeDisputesRead, nil
	case "DISPUTES_WRITE":
		return OauthScopeDisputesWrite, nil
	case "GIFTCARDS_READ":
		return OauthScopeGiftcardsRead, nil
	case "GIFTCARDS_WRITE":
		return OauthScopeGiftcardsWrite, nil
	case "ONLINE_STORE_SNIPPETS_WRITE":
		return OauthScopeOnlineStoreSnippetsWrite, nil
	case "ONLINE_STORE_SNIPPETS_READ":
		return OauthScopeOnlineStoreSnippetsRead, nil
	case "ONLINE_STORE_SITE_READ":
		return OauthScopeOnlineStoreSiteRead, nil
	case "PAYMENTS_WRITE_SHARED_ONFILE":
		return OauthScopePaymentsWriteSharedOnfile, nil
	case "APPOINTMENTS_ALL_READ":
		return OauthScopeAppointmentsAllRead, nil
	case "APPOINTMENTS_ALL_WRITE":
		return OauthScopeAppointmentsAllWrite, nil
	case "MERCHANT_PROFILE_WRITE":
		return OauthScopeMerchantProfileWrite, nil
	case "VENDOR_READ":
		return OauthScopeVendorRead, nil
	case "VENDOR_WRITE":
		return OauthScopeVendorWrite, nil
	case "PAYOUTS_READ":
		return OauthScopePayoutsRead, nil
	case "RESERVATIONS_READ":
		return OauthScopeReservationsRead, nil
	case "RESERVATIONS_WRITE":
		return OauthScopeReservationsWrite, nil
	}
	var t OauthScope
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (o OauthScope) Ptr() *OauthScope {
	return &o
}

// Contains all information related to a single order to process with Square,
// including line items that specify the products to purchase. `Order` objects also
// include information about any associated tenders, refunds, and returns.
//
// All Connect V2 Transactions have all been converted to Orders including all associated
// itemization data.
type Order struct {
	// The order's unique ID.
	Id *string `json:"id,omitempty" url:"id,omitempty"`
	// The ID of the seller location that this order is associated with.
	LocationId string `json:"location_id" url:"location_id"`
	// A client-specified ID to associate an entity in another system
	// with this order.
	ReferenceId *string `json:"reference_id,omitempty" url:"reference_id,omitempty"`
	// The origination details of the order.
	Source *OrderSource `json:"source,omitempty" url:"source,omitempty"`
	// The ID of the [customer](entity:Customer) associated with the order.
	//
	// **IMPORTANT:** You should specify a `customer_id` if you want the corresponding payment transactions
	// to be explicitly linked to the customer in the Seller Dashboard. If this field is omitted, the
	// `customer_id` assigned to any underlying `Payment` objects is ignored and might result in the
	// creation of new [instant profiles](https://developer.squareup.com/docs/customers-api/what-it-does#instant-profiles).
	CustomerId *string `json:"customer_id,omitempty" url:"customer_id,omitempty"`
	// The line items included in the order.
	LineItems []*OrderLineItem `json:"line_items,omitempty" url:"line_items,omitempty"`
	// The list of all taxes associated with the order.
	//
	// Taxes can be scoped to either `ORDER` or `LINE_ITEM`. For taxes with `LINE_ITEM` scope, an
	// `OrderLineItemAppliedTax` must be added to each line item that the tax applies to. For taxes
	// with `ORDER` scope, the server generates an `OrderLineItemAppliedTax` for every line item.
	//
	// On reads, each tax in the list includes the total amount of that tax applied to the order.
	//
	// **IMPORTANT**: If `LINE_ITEM` scope is set on any taxes in this field, using the deprecated
	// `line_items.taxes` field results in an error. Use `line_items.applied_taxes`
	// instead.
	Taxes []*OrderLineItemTax `json:"taxes,omitempty" url:"taxes,omitempty"`
	// The list of all discounts associated with the order.
	//
	// Discounts can be scoped to either `ORDER` or `LINE_ITEM`. For discounts scoped to `LINE_ITEM`,
	// an `OrderLineItemAppliedDiscount` must be added to each line item that the discount applies to.
	// For discounts with `ORDER` scope, the server generates an `OrderLineItemAppliedDiscount`
	// for every line item.
	//
	// **IMPORTANT**: If `LINE_ITEM` scope is set on any discounts in this field, using the deprecated
	// `line_items.discounts` field results in an error. Use `line_items.applied_discounts`
	// instead.
	Discounts []*OrderLineItemDiscount `json:"discounts,omitempty" url:"discounts,omitempty"`
	// A list of service charges applied to the order.
	ServiceCharges []*OrderServiceCharge `json:"service_charges,omitempty" url:"service_charges,omitempty"`
	// Details about order fulfillment.
	//
	// Orders can only be created with at most one fulfillment. However, orders returned
	// by the API might contain multiple fulfillments.
	Fulfillments []*OrderFulfillment `json:"fulfillments,omitempty" url:"fulfillments,omitempty"`
	// A collection of items from sale orders being returned in this one. Normally part of an
	// itemized return or exchange. There is exactly one `Return` object per sale `Order` being
	// referenced.
	Returns []*OrderReturn `json:"returns,omitempty" url:"returns,omitempty"`
	// The rollup of the returned money amounts.
	ReturnAmounts *OrderMoneyAmounts `json:"return_amounts,omitempty" url:"return_amounts,omitempty"`
	// The net money amounts (sale money - return money).
	NetAmounts *OrderMoneyAmounts `json:"net_amounts,omitempty" url:"net_amounts,omitempty"`
	// A positive rounding adjustment to the total of the order. This adjustment is commonly
	// used to apply cash rounding when the minimum unit of account is smaller than the lowest physical
	// denomination of the currency.
	RoundingAdjustment *OrderRoundingAdjustment `json:"rounding_adjustment,omitempty" url:"rounding_adjustment,omitempty"`
	// The tenders that were used to pay for the order.
	Tenders []*Tender `json:"tenders,omitempty" url:"tenders,omitempty"`
	// The refunds that are part of this order.
	Refunds []*Refund `json:"refunds,omitempty" url:"refunds,omitempty"`
	// Application-defined data attached to this order. Metadata fields are intended
	// to store descriptive references or associations with an entity in another system or store brief
	// information about the object. Square does not process this field; it only stores and returns it
	// in relevant API calls. Do not use metadata to store any sensitive information (such as personally
	// identifiable information or card details).
	//
	// Keys written by applications must be 60 characters or less and must be in the character set
	// `[a-zA-Z0-9_-]`. Entries can also include metadata generated by Square. These keys are prefixed
	// with a namespace, separated from the key with a ':' character.
	//
	// Values have a maximum length of 255 characters.
	//
	// An application can have up to 10 entries per metadata field.
	//
	// Entries written by applications are private and can only be read or modified by the same
	// application.
	//
	// For more information, see [Metadata](https://developer.squareup.com/docs/build-basics/metadata).
	Metadata map[string]string `json:"metadata,omitempty" url:"metadata,omitempty"`
	// The timestamp for when the order was created, in RFC 3339 format (for example, "2016-09-04T23:59:33.123Z").
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The timestamp for when the order was last updated, in RFC 3339 format (for example, "2016-09-04T23:59:33.123Z").
	UpdatedAt *string `json:"updated_at,omitempty" url:"updated_at,omitempty"`
	// The timestamp for when the order reached a terminal [state](entity:OrderState), in RFC 3339 format (for example "2016-09-04T23:59:33.123Z").
	ClosedAt *string `json:"closed_at,omitempty" url:"closed_at,omitempty"`
	// The current state of the order.
	// See [OrderState](#type-orderstate) for possible values
	State *OrderState `json:"state,omitempty" url:"state,omitempty"`
	// The version number, which is incremented each time an update is committed to the order.
	// Orders not created through the API do not include a version number and
	// therefore cannot be updated.
	//
	// [Read more about working with versions](https://developer.squareup.com/docs/orders-api/manage-orders#update-orders).
	Version *int `json:"version,omitempty" url:"version,omitempty"`
	// The total amount of money to collect for the order.
	TotalMoney *Money `json:"total_money,omitempty" url:"total_money,omitempty"`
	// The total amount of tax money to collect for the order.
	TotalTaxMoney *Money `json:"total_tax_money,omitempty" url:"total_tax_money,omitempty"`
	// The total amount of discount money to collect for the order.
	TotalDiscountMoney *Money `json:"total_discount_money,omitempty" url:"total_discount_money,omitempty"`
	// The total amount of tip money to collect for the order.
	TotalTipMoney *Money `json:"total_tip_money,omitempty" url:"total_tip_money,omitempty"`
	// The total amount of money collected in service charges for the order.
	//
	// Note: `total_service_charge_money` is the sum of `applied_money` fields for each individual
	// service charge. Therefore, `total_service_charge_money` only includes inclusive tax amounts,
	// not additive tax amounts.
	TotalServiceChargeMoney *Money `json:"total_service_charge_money,omitempty" url:"total_service_charge_money,omitempty"`
	// A short-term identifier for the order (such as a customer first name,
	// table number, or auto-generated order number that resets daily).
	TicketName *string `json:"ticket_name,omitempty" url:"ticket_name,omitempty"`
	// Pricing options for an order. The options affect how the order's price is calculated.
	// They can be used, for example, to apply automatic price adjustments that are based on
	// preconfigured [pricing rules](entity:CatalogPricingRule).
	PricingOptions *OrderPricingOptions `json:"pricing_options,omitempty" url:"pricing_options,omitempty"`
	// A set-like list of Rewards that have been added to the Order.
	Rewards []*OrderReward `json:"rewards,omitempty" url:"rewards,omitempty"`
	// The net amount of money due on the order.
	NetAmountDueMoney *Money `json:"net_amount_due_money,omitempty" url:"net_amount_due_money,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (o *Order) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *Order) UnmarshalJSON(data []byte) error {
	type unmarshaler Order
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = Order(value)

	extraProperties, err := core.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties

	o._rawJSON = json.RawMessage(data)
	return nil
}

func (o *Order) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

type OrderCreated struct {
	// The order's unique ID.
	OrderId *string `json:"order_id,omitempty" url:"order_id,omitempty"`
	// The version number, which is incremented each time an update is committed to the order.
	// Orders that were not created through the API do not include a version number and
	// therefore cannot be updated.
	//
	// [Read more about working with versions.](https://developer.squareup.com/docs/orders-api/manage-orders#update-orders)
	Version *int `json:"version,omitempty" url:"version,omitempty"`
	// The ID of the seller location that this order is associated with.
	LocationId *string `json:"location_id,omitempty" url:"location_id,omitempty"`
	// The state of the order.
	// See [OrderState](#type-orderstate) for possible values
	State *OrderState `json:"state,omitempty" url:"state,omitempty"`
	// The timestamp for when the order was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (o *OrderCreated) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OrderCreated) UnmarshalJSON(data []byte) error {
	type unmarshaler OrderCreated
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OrderCreated(value)

	extraProperties, err := core.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties

	o._rawJSON = json.RawMessage(data)
	return nil
}

func (o *OrderCreated) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

type OrderCreatedObject struct {
	// Information about the created order.
	OrderCreated *OrderCreated `json:"order_created,omitempty" url:"order_created,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (o *OrderCreatedObject) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OrderCreatedObject) UnmarshalJSON(data []byte) error {
	type unmarshaler OrderCreatedObject
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OrderCreatedObject(value)

	extraProperties, err := core.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties

	o._rawJSON = json.RawMessage(data)
	return nil
}

func (o *OrderCreatedObject) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// Published when an [Order](entity:Order) is created. This event is
// triggered only by the [CreateOrder](api-endpoint:Orders-CreateOrder) endpoint call.
//
// Creating an order in the Point of Sale app will **not** publish this event.
type OrderCreatedWebhook struct {
	// The ID of the target merchant associated with the event.
	MerchantId *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The type of event this represents, `"order.created"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// A unique ID for the webhook event.
	EventId *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// Timestamp of when the webhook event was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// Data associated with the event.
	Data *OrderCreatedWebhookData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (o *OrderCreatedWebhook) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OrderCreatedWebhook) UnmarshalJSON(data []byte) error {
	type unmarshaler OrderCreatedWebhook
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OrderCreatedWebhook(value)

	extraProperties, err := core.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties

	o._rawJSON = json.RawMessage(data)
	return nil
}

func (o *OrderCreatedWebhook) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

type OrderCreatedWebhookData struct {
	// Name of the affected object’s type, `"order"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// ID of the affected order.
	Id *string `json:"id,omitempty" url:"id,omitempty"`
	// An object containing information about the created Order.
	Object *OrderCreatedObject `json:"object,omitempty" url:"object,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (o *OrderCreatedWebhookData) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OrderCreatedWebhookData) UnmarshalJSON(data []byte) error {
	type unmarshaler OrderCreatedWebhookData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OrderCreatedWebhookData(value)

	extraProperties, err := core.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties

	o._rawJSON = json.RawMessage(data)
	return nil
}

func (o *OrderCreatedWebhookData) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// A lightweight description of an [order](entity:Order) that is returned when
// `returned_entries` is `true` on a [SearchOrdersRequest](api-endpoint:Orders-SearchOrders).
type OrderEntry struct {
	// The ID of the order.
	OrderId *string `json:"order_id,omitempty" url:"order_id,omitempty"`
	// The version number, which is incremented each time an update is committed to the order.
	// Orders that were not created through the API do not include a version number and
	// therefore cannot be updated.
	//
	// [Read more about working with versions.](https://developer.squareup.com/docs/orders-api/manage-orders#update-orders)
	Version *int `json:"version,omitempty" url:"version,omitempty"`
	// The location ID the order belongs to.
	LocationId *string `json:"location_id,omitempty" url:"location_id,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (o *OrderEntry) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OrderEntry) UnmarshalJSON(data []byte) error {
	type unmarshaler OrderEntry
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OrderEntry(value)

	extraProperties, err := core.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties

	o._rawJSON = json.RawMessage(data)
	return nil
}

func (o *OrderEntry) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// Contains details about how to fulfill this order.
type OrderFulfillment struct {
	// A unique ID that identifies the fulfillment only within this order.
	Uid *string `json:"uid,omitempty" url:"uid,omitempty"`
	// The type of the fulfillment.
	// See [OrderFulfillmentType](#type-orderfulfillmenttype) for possible values
	Type *OrderFulfillmentType `json:"type,omitempty" url:"type,omitempty"`
	// The state of the fulfillment.
	// See [OrderFulfillmentState](#type-orderfulfillmentstate) for possible values
	State *OrderFulfillmentState `json:"state,omitempty" url:"state,omitempty"`
	// Describes what order line items this fulfillment applies to.
	// It can be `ALL` or `ENTRY_LIST` with a supplied list of fulfillment entries.
	// See [OrderFulfillmentFulfillmentLineItemApplication](#type-orderfulfillmentfulfillmentlineitemapplication) for possible values
	LineItemApplication *OrderFulfillmentFulfillmentLineItemApplication `json:"line_item_application,omitempty" url:"line_item_application,omitempty"`
	// A list of entries pertaining to the fulfillment of an order. Each entry must reference
	// a valid `uid` for an order line item in the `line_item_uid` field, as well as a `quantity` to
	// fulfill.
	//
	// Multiple entries can reference the same line item `uid`, as long as the total quantity among
	// all fulfillment entries referencing a single line item does not exceed the quantity of the
	// order's line item itself.
	//
	// An order cannot be marked as `COMPLETED` before all fulfillments are `COMPLETED`,
	// `CANCELED`, or `FAILED`. Fulfillments can be created and completed independently
	// before order completion.
	Entries []*OrderFulfillmentFulfillmentEntry `json:"entries,omitempty" url:"entries,omitempty"`
	// Application-defined data attached to this fulfillment. Metadata fields are intended
	// to store descriptive references or associations with an entity in another system or store brief
	// information about the object. Square does not process this field; it only stores and returns it
	// in relevant API calls. Do not use metadata to store any sensitive information (such as personally
	// identifiable information or card details).
	//
	// Keys written by applications must be 60 characters or less and must be in the character set
	// `[a-zA-Z0-9_-]`. Entries can also include metadata generated by Square. These keys are prefixed
	// with a namespace, separated from the key with a ':' character.
	//
	// Values have a maximum length of 255 characters.
	//
	// An application can have up to 10 entries per metadata field.
	//
	// Entries written by applications are private and can only be read or modified by the same
	// application.
	//
	// For more information, see [Metadata](https://developer.squareup.com/docs/build-basics/metadata).
	Metadata map[string]string `json:"metadata,omitempty" url:"metadata,omitempty"`
	// Contains details for a pickup fulfillment. These details are required when the fulfillment
	// type is `PICKUP`.
	PickupDetails *OrderFulfillmentPickupDetails `json:"pickup_details,omitempty" url:"pickup_details,omitempty"`
	// Contains details for a shipment fulfillment. These details are required when the fulfillment type
	// is `SHIPMENT`.
	//
	// A shipment fulfillment's relationship to fulfillment `state`:
	// `PROPOSED`: A shipment is requested.
	// `RESERVED`: Fulfillment accepted. Shipment processing.
	// `PREPARED`: Shipment packaged. Shipping label created.
	// `COMPLETED`: Package has been shipped.
	// `CANCELED`: Shipment has been canceled.
	// `FAILED`: Shipment has failed.
	ShipmentDetails *OrderFulfillmentShipmentDetails `json:"shipment_details,omitempty" url:"shipment_details,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (o *OrderFulfillment) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OrderFulfillment) UnmarshalJSON(data []byte) error {
	type unmarshaler OrderFulfillment
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OrderFulfillment(value)

	extraProperties, err := core.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties

	o._rawJSON = json.RawMessage(data)
	return nil
}

func (o *OrderFulfillment) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// Links an order line item to a fulfillment. Each entry must reference
// a valid `uid` for an order line item in the `line_item_uid` field, as well as a `quantity` to
// fulfill.
type OrderFulfillmentFulfillmentEntry struct {
	// A unique ID that identifies the fulfillment entry only within this order.
	Uid *string `json:"uid,omitempty" url:"uid,omitempty"`
	// The `uid` from the order line item.
	LineItemUid string `json:"line_item_uid" url:"line_item_uid"`
	// The quantity of the line item being fulfilled, formatted as a decimal number.
	// For example, `"3"`.
	//
	// Fulfillments for line items with a `quantity_unit` can have non-integer quantities.
	// For example, `"1.70000"`.
	Quantity string `json:"quantity" url:"quantity"`
	// Application-defined data attached to this fulfillment entry. Metadata fields are intended
	// to store descriptive references or associations with an entity in another system or store brief
	// information about the object. Square does not process this field; it only stores and returns it
	// in relevant API calls. Do not use metadata to store any sensitive information (such as personally
	// identifiable information or card details).
	//
	// Keys written by applications must be 60 characters or less and must be in the character set
	// `[a-zA-Z0-9_-]`. Entries can also include metadata generated by Square. These keys are prefixed
	// with a namespace, separated from the key with a ':' character.
	//
	// Values have a maximum length of 255 characters.
	//
	// An application can have up to 10 entries per metadata field.
	//
	// Entries written by applications are private and can only be read or modified by the same
	// application.
	//
	// For more information, see [Metadata](https://developer.squareup.com/docs/build-basics/metadata).
	Metadata map[string]string `json:"metadata,omitempty" url:"metadata,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (o *OrderFulfillmentFulfillmentEntry) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OrderFulfillmentFulfillmentEntry) UnmarshalJSON(data []byte) error {
	type unmarshaler OrderFulfillmentFulfillmentEntry
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OrderFulfillmentFulfillmentEntry(value)

	extraProperties, err := core.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties

	o._rawJSON = json.RawMessage(data)
	return nil
}

func (o *OrderFulfillmentFulfillmentEntry) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// The `line_item_application` describes what order line items this fulfillment applies
// to. It can be `ALL` or `ENTRY_LIST` with a supplied list of fulfillment entries.
type OrderFulfillmentFulfillmentLineItemApplication string

const (
	OrderFulfillmentFulfillmentLineItemApplicationUnknownApplication OrderFulfillmentFulfillmentLineItemApplication = "UNKNOWN_APPLICATION"
	OrderFulfillmentFulfillmentLineItemApplicationAll                OrderFulfillmentFulfillmentLineItemApplication = "ALL"
	OrderFulfillmentFulfillmentLineItemApplicationEntryList          OrderFulfillmentFulfillmentLineItemApplication = "ENTRY_LIST"
)

func NewOrderFulfillmentFulfillmentLineItemApplicationFromString(s string) (OrderFulfillmentFulfillmentLineItemApplication, error) {
	switch s {
	case "UNKNOWN_APPLICATION":
		return OrderFulfillmentFulfillmentLineItemApplicationUnknownApplication, nil
	case "ALL":
		return OrderFulfillmentFulfillmentLineItemApplicationAll, nil
	case "ENTRY_LIST":
		return OrderFulfillmentFulfillmentLineItemApplicationEntryList, nil
	}
	var t OrderFulfillmentFulfillmentLineItemApplication
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (o OrderFulfillmentFulfillmentLineItemApplication) Ptr() *OrderFulfillmentFulfillmentLineItemApplication {
	return &o
}

// Contains details necessary to fulfill a pickup order.
type OrderFulfillmentPickupDetails struct {
	// Information about the person to pick up this fulfillment from a physical
	// location.
	Recipient *OrderFulfillmentRecipient `json:"recipient,omitempty" url:"recipient,omitempty"`
	// The [timestamp](https://developer.squareup.com/docs/build-basics/working-with-dates)
	// indicating when this fulfillment expires if it is not accepted. The timestamp must be in RFC 3339 format
	// (for example, "2016-09-04T23:59:33.123Z"). The expiration time can only be set up to 7 days in the future.
	// If `expires_at` is not set, this pickup fulfillment is automatically accepted when
	// placed.
	ExpiresAt *string `json:"expires_at,omitempty" url:"expires_at,omitempty"`
	// The duration of time after which an open and accepted pickup fulfillment
	// is automatically moved to the `COMPLETED` state. The duration must be in RFC 3339
	// format (for example, "P1W3D").
	//
	// If not set, this pickup fulfillment remains accepted until it is canceled or completed.
	AutoCompleteDuration *string `json:"auto_complete_duration,omitempty" url:"auto_complete_duration,omitempty"`
	// The schedule type of the pickup fulfillment. Defaults to `SCHEDULED`.
	// See [OrderFulfillmentPickupDetailsScheduleType](#type-orderfulfillmentpickupdetailsscheduletype) for possible values
	ScheduleType *OrderFulfillmentPickupDetailsScheduleType `json:"schedule_type,omitempty" url:"schedule_type,omitempty"`
	// The [timestamp](https://developer.squareup.com/docs/build-basics/working-with-dates)
	// that represents the start of the pickup window. Must be in RFC 3339 timestamp format, e.g.,
	// "2016-09-04T23:59:33.123Z".
	//
	// For fulfillments with the schedule type `ASAP`, this is automatically set
	// to the current time plus the expected duration to prepare the fulfillment.
	PickupAt *string `json:"pickup_at,omitempty" url:"pickup_at,omitempty"`
	// The window of time in which the order should be picked up after the `pickup_at` timestamp.
	// Must be in RFC 3339 duration format, e.g., "P1W3D". Can be used as an
	// informational guideline for merchants.
	PickupWindowDuration *string `json:"pickup_window_duration,omitempty" url:"pickup_window_duration,omitempty"`
	// The duration of time it takes to prepare this fulfillment.
	// The duration must be in RFC 3339 format (for example, "P1W3D").
	PrepTimeDuration *string `json:"prep_time_duration,omitempty" url:"prep_time_duration,omitempty"`
	// A note to provide additional instructions about the pickup
	// fulfillment displayed in the Square Point of Sale application and set by the API.
	Note *string `json:"note,omitempty" url:"note,omitempty"`
	// The [timestamp](https://developer.squareup.com/docs/build-basics/working-with-dates)
	// indicating when the fulfillment was placed. The timestamp must be in RFC 3339 format
	// (for example, "2016-09-04T23:59:33.123Z").
	PlacedAt *string `json:"placed_at,omitempty" url:"placed_at,omitempty"`
	// The [timestamp](https://developer.squareup.com/docs/build-basics/working-with-dates)
	// indicating when the fulfillment was accepted. The timestamp must be in RFC 3339 format
	// (for example, "2016-09-04T23:59:33.123Z").
	AcceptedAt *string `json:"accepted_at,omitempty" url:"accepted_at,omitempty"`
	// The [timestamp](https://developer.squareup.com/docs/build-basics/working-with-dates)
	// indicating when the fulfillment was rejected. The timestamp must be in RFC 3339 format
	// (for example, "2016-09-04T23:59:33.123Z").
	RejectedAt *string `json:"rejected_at,omitempty" url:"rejected_at,omitempty"`
	// The [timestamp](https://developer.squareup.com/docs/build-basics/working-with-dates)
	// indicating when the fulfillment is marked as ready for pickup. The timestamp must be in RFC 3339 format
	// (for example, "2016-09-04T23:59:33.123Z").
	ReadyAt *string `json:"ready_at,omitempty" url:"ready_at,omitempty"`
	// The [timestamp](https://developer.squareup.com/docs/build-basics/working-with-dates)
	// indicating when the fulfillment expired. The timestamp must be in RFC 3339 format
	// (for example, "2016-09-04T23:59:33.123Z").
	ExpiredAt *string `json:"expired_at,omitempty" url:"expired_at,omitempty"`
	// The [timestamp](https://developer.squareup.com/docs/build-basics/working-with-dates)
	// indicating when the fulfillment was picked up by the recipient. The timestamp must be in RFC 3339 format
	// (for example, "2016-09-04T23:59:33.123Z").
	PickedUpAt *string `json:"picked_up_at,omitempty" url:"picked_up_at,omitempty"`
	// The [timestamp](https://developer.squareup.com/docs/build-basics/working-with-dates)
	// indicating when the fulfillment was canceled. The timestamp must be in RFC 3339 format
	// (for example, "2016-09-04T23:59:33.123Z").
	CanceledAt *string `json:"canceled_at,omitempty" url:"canceled_at,omitempty"`
	// A description of why the pickup was canceled. The maximum length: 100 characters.
	CancelReason *string `json:"cancel_reason,omitempty" url:"cancel_reason,omitempty"`
	// If set to `true`, indicates that this pickup order is for curbside pickup, not in-store pickup.
	IsCurbsidePickup *bool `json:"is_curbside_pickup,omitempty" url:"is_curbside_pickup,omitempty"`
	// Specific details for curbside pickup. These details can only be populated if `is_curbside_pickup` is set to `true`.
	CurbsidePickupDetails *OrderFulfillmentPickupDetailsCurbsidePickupDetails `json:"curbside_pickup_details,omitempty" url:"curbside_pickup_details,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (o *OrderFulfillmentPickupDetails) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OrderFulfillmentPickupDetails) UnmarshalJSON(data []byte) error {
	type unmarshaler OrderFulfillmentPickupDetails
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OrderFulfillmentPickupDetails(value)

	extraProperties, err := core.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties

	o._rawJSON = json.RawMessage(data)
	return nil
}

func (o *OrderFulfillmentPickupDetails) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// Specific details for curbside pickup.
type OrderFulfillmentPickupDetailsCurbsidePickupDetails struct {
	// Specific details for curbside pickup, such as parking number and vehicle model.
	CurbsideDetails *string `json:"curbside_details,omitempty" url:"curbside_details,omitempty"`
	// The [timestamp](https://developer.squareup.com/docs/build-basics/working-with-dates)
	// indicating when the buyer arrived and is waiting for pickup. The timestamp must be in RFC 3339 format
	// (for example, "2016-09-04T23:59:33.123Z").
	BuyerArrivedAt *string `json:"buyer_arrived_at,omitempty" url:"buyer_arrived_at,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (o *OrderFulfillmentPickupDetailsCurbsidePickupDetails) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OrderFulfillmentPickupDetailsCurbsidePickupDetails) UnmarshalJSON(data []byte) error {
	type unmarshaler OrderFulfillmentPickupDetailsCurbsidePickupDetails
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OrderFulfillmentPickupDetailsCurbsidePickupDetails(value)

	extraProperties, err := core.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties

	o._rawJSON = json.RawMessage(data)
	return nil
}

func (o *OrderFulfillmentPickupDetailsCurbsidePickupDetails) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// The schedule type of the pickup fulfillment.
type OrderFulfillmentPickupDetailsScheduleType string

const (
	OrderFulfillmentPickupDetailsScheduleTypeFulfillmentPickupDetailsScheduleTypeDoNotUse OrderFulfillmentPickupDetailsScheduleType = "FULFILLMENT_PICKUP_DETAILS_SCHEDULE_TYPE_DO_NOT_USE"
	OrderFulfillmentPickupDetailsScheduleTypeScheduled                                    OrderFulfillmentPickupDetailsScheduleType = "SCHEDULED"
	OrderFulfillmentPickupDetailsScheduleTypeAsap                                         OrderFulfillmentPickupDetailsScheduleType = "ASAP"
)

func NewOrderFulfillmentPickupDetailsScheduleTypeFromString(s string) (OrderFulfillmentPickupDetailsScheduleType, error) {
	switch s {
	case "FULFILLMENT_PICKUP_DETAILS_SCHEDULE_TYPE_DO_NOT_USE":
		return OrderFulfillmentPickupDetailsScheduleTypeFulfillmentPickupDetailsScheduleTypeDoNotUse, nil
	case "SCHEDULED":
		return OrderFulfillmentPickupDetailsScheduleTypeScheduled, nil
	case "ASAP":
		return OrderFulfillmentPickupDetailsScheduleTypeAsap, nil
	}
	var t OrderFulfillmentPickupDetailsScheduleType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (o OrderFulfillmentPickupDetailsScheduleType) Ptr() *OrderFulfillmentPickupDetailsScheduleType {
	return &o
}

// Information about the fulfillment recipient.
type OrderFulfillmentRecipient struct {
	// The ID of the customer associated with the fulfillment.
	//
	// If `customer_id` is provided, the fulfillment recipient's `display_name`,
	// `email_address`, and `phone_number` are automatically populated from the
	// targeted customer profile. If these fields are set in the request, the request
	// values override the information from the customer profile. If the
	// targeted customer profile does not contain the necessary information and
	// these fields are left unset, the request results in an error.
	CustomerId *string `json:"customer_id,omitempty" url:"customer_id,omitempty"`
	// The display name of the fulfillment recipient. This field is required.
	//
	// If provided, the display name overrides the corresponding customer profile value
	// indicated by `customer_id`.
	DisplayName *string `json:"display_name,omitempty" url:"display_name,omitempty"`
	// The email address of the fulfillment recipient.
	//
	// If provided, the email address overrides the corresponding customer profile value
	// indicated by `customer_id`.
	EmailAddress *string `json:"email_address,omitempty" url:"email_address,omitempty"`
	// The phone number of the fulfillment recipient. This field is required.
	//
	// If provided, the phone number overrides the corresponding customer profile value
	// indicated by `customer_id`.
	PhoneNumber *string `json:"phone_number,omitempty" url:"phone_number,omitempty"`
	// The address of the fulfillment recipient. This field is required.
	//
	// If provided, the address overrides the corresponding customer profile value
	// indicated by `customer_id`.
	Address *Address `json:"address,omitempty" url:"address,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (o *OrderFulfillmentRecipient) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OrderFulfillmentRecipient) UnmarshalJSON(data []byte) error {
	type unmarshaler OrderFulfillmentRecipient
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OrderFulfillmentRecipient(value)

	extraProperties, err := core.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties

	o._rawJSON = json.RawMessage(data)
	return nil
}

func (o *OrderFulfillmentRecipient) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// Contains the details necessary to fulfill a shipment order.
type OrderFulfillmentShipmentDetails struct {
	// Information about the person to receive this shipment fulfillment.
	Recipient *OrderFulfillmentRecipient `json:"recipient,omitempty" url:"recipient,omitempty"`
	// The shipping carrier being used to ship this fulfillment (such as UPS, FedEx, or USPS).
	Carrier *string `json:"carrier,omitempty" url:"carrier,omitempty"`
	// A note with additional information for the shipping carrier.
	ShippingNote *string `json:"shipping_note,omitempty" url:"shipping_note,omitempty"`
	// A description of the type of shipping product purchased from the carrier
	// (such as First Class, Priority, or Express).
	ShippingType *string `json:"shipping_type,omitempty" url:"shipping_type,omitempty"`
	// The reference number provided by the carrier to track the shipment's progress.
	TrackingNumber *string `json:"tracking_number,omitempty" url:"tracking_number,omitempty"`
	// A link to the tracking webpage on the carrier's website.
	TrackingUrl *string `json:"tracking_url,omitempty" url:"tracking_url,omitempty"`
	// The [timestamp](https://developer.squareup.com/docs/build-basics/working-with-dates)
	// indicating when the shipment was requested. The timestamp must be in RFC 3339 format
	// (for example, "2016-09-04T23:59:33.123Z").
	PlacedAt *string `json:"placed_at,omitempty" url:"placed_at,omitempty"`
	// The [timestamp](https://developer.squareup.com/docs/build-basics/working-with-dates)
	// indicating when this fulfillment was moved to the `RESERVED` state, which indicates that preparation
	// of this shipment has begun. The timestamp must be in RFC 3339 format (for example, "2016-09-04T23:59:33.123Z").
	InProgressAt *string `json:"in_progress_at,omitempty" url:"in_progress_at,omitempty"`
	// The [timestamp](https://developer.squareup.com/docs/build-basics/working-with-dates)
	// indicating when this fulfillment was moved to the `PREPARED` state, which indicates that the
	// fulfillment is packaged. The timestamp must be in RFC 3339 format (for example, "2016-09-04T23:59:33.123Z").
	PackagedAt *string `json:"packaged_at,omitempty" url:"packaged_at,omitempty"`
	// The [timestamp](https://developer.squareup.com/docs/build-basics/working-with-dates)
	// indicating when the shipment is expected to be delivered to the shipping carrier.
	// The timestamp must be in RFC 3339 format (for example, "2016-09-04T23:59:33.123Z").
	ExpectedShippedAt *string `json:"expected_shipped_at,omitempty" url:"expected_shipped_at,omitempty"`
	// The [timestamp](https://developer.squareup.com/docs/build-basics/working-with-dates)
	// indicating when this fulfillment was moved to the `COMPLETED` state, which indicates that
	// the fulfillment has been given to the shipping carrier. The timestamp must be in RFC 3339 format
	// (for example, "2016-09-04T23:59:33.123Z").
	ShippedAt *string `json:"shipped_at,omitempty" url:"shipped_at,omitempty"`
	// The [timestamp](https://developer.squareup.com/docs/build-basics/working-with-dates)
	// indicating the shipment was canceled.
	// The timestamp must be in RFC 3339 format (for example, "2016-09-04T23:59:33.123Z").
	CanceledAt *string `json:"canceled_at,omitempty" url:"canceled_at,omitempty"`
	// A description of why the shipment was canceled.
	CancelReason *string `json:"cancel_reason,omitempty" url:"cancel_reason,omitempty"`
	// The [timestamp](https://developer.squareup.com/docs/build-basics/working-with-dates)
	// indicating when the shipment failed to be completed. The timestamp must be in RFC 3339 format
	// (for example, "2016-09-04T23:59:33.123Z").
	FailedAt *string `json:"failed_at,omitempty" url:"failed_at,omitempty"`
	// A description of why the shipment failed to be completed.
	FailureReason *string `json:"failure_reason,omitempty" url:"failure_reason,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (o *OrderFulfillmentShipmentDetails) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OrderFulfillmentShipmentDetails) UnmarshalJSON(data []byte) error {
	type unmarshaler OrderFulfillmentShipmentDetails
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OrderFulfillmentShipmentDetails(value)

	extraProperties, err := core.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties

	o._rawJSON = json.RawMessage(data)
	return nil
}

func (o *OrderFulfillmentShipmentDetails) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// The current state of this fulfillment.
type OrderFulfillmentState string

const (
	OrderFulfillmentStateFulfillmentStateDoNotUse OrderFulfillmentState = "FULFILLMENT_STATE_DO_NOT_USE"
	OrderFulfillmentStateProposed                 OrderFulfillmentState = "PROPOSED"
	OrderFulfillmentStateReserved                 OrderFulfillmentState = "RESERVED"
	OrderFulfillmentStatePrepared                 OrderFulfillmentState = "PREPARED"
	OrderFulfillmentStateCompleted                OrderFulfillmentState = "COMPLETED"
	OrderFulfillmentStateCanceled                 OrderFulfillmentState = "CANCELED"
	OrderFulfillmentStateFailed                   OrderFulfillmentState = "FAILED"
)

func NewOrderFulfillmentStateFromString(s string) (OrderFulfillmentState, error) {
	switch s {
	case "FULFILLMENT_STATE_DO_NOT_USE":
		return OrderFulfillmentStateFulfillmentStateDoNotUse, nil
	case "PROPOSED":
		return OrderFulfillmentStateProposed, nil
	case "RESERVED":
		return OrderFulfillmentStateReserved, nil
	case "PREPARED":
		return OrderFulfillmentStatePrepared, nil
	case "COMPLETED":
		return OrderFulfillmentStateCompleted, nil
	case "CANCELED":
		return OrderFulfillmentStateCanceled, nil
	case "FAILED":
		return OrderFulfillmentStateFailed, nil
	}
	var t OrderFulfillmentState
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (o OrderFulfillmentState) Ptr() *OrderFulfillmentState {
	return &o
}

// The type of fulfillment.
type OrderFulfillmentType string

const (
	OrderFulfillmentTypeFulfillmentTypeDoNotUse OrderFulfillmentType = "FULFILLMENT_TYPE_DO_NOT_USE"
	OrderFulfillmentTypeCustom                  OrderFulfillmentType = "CUSTOM"
	OrderFulfillmentTypePickup                  OrderFulfillmentType = "PICKUP"
	OrderFulfillmentTypeManagedDelivery         OrderFulfillmentType = "MANAGED_DELIVERY"
	OrderFulfillmentTypeShipment                OrderFulfillmentType = "SHIPMENT"
	OrderFulfillmentTypeDigital                 OrderFulfillmentType = "DIGITAL"
	OrderFulfillmentTypeDelivery                OrderFulfillmentType = "DELIVERY"
	OrderFulfillmentTypeSimple                  OrderFulfillmentType = "SIMPLE"
)

func NewOrderFulfillmentTypeFromString(s string) (OrderFulfillmentType, error) {
	switch s {
	case "FULFILLMENT_TYPE_DO_NOT_USE":
		return OrderFulfillmentTypeFulfillmentTypeDoNotUse, nil
	case "CUSTOM":
		return OrderFulfillmentTypeCustom, nil
	case "PICKUP":
		return OrderFulfillmentTypePickup, nil
	case "MANAGED_DELIVERY":
		return OrderFulfillmentTypeManagedDelivery, nil
	case "SHIPMENT":
		return OrderFulfillmentTypeShipment, nil
	case "DIGITAL":
		return OrderFulfillmentTypeDigital, nil
	case "DELIVERY":
		return OrderFulfillmentTypeDelivery, nil
	case "SIMPLE":
		return OrderFulfillmentTypeSimple, nil
	}
	var t OrderFulfillmentType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (o OrderFulfillmentType) Ptr() *OrderFulfillmentType {
	return &o
}

type OrderFulfillmentUpdated struct {
	// The order's unique ID.
	OrderId *string `json:"order_id,omitempty" url:"order_id,omitempty"`
	// The version number, which is incremented each time an update is committed to the order.
	// Orders that were not created through the API do not include a version number and
	// therefore cannot be updated.
	//
	// [Read more about working with versions.](https://developer.squareup.com/docs/orders-api/manage-orders#update-orders)
	Version *int `json:"version,omitempty" url:"version,omitempty"`
	// The ID of the seller location that this order is associated with.
	LocationId *string `json:"location_id,omitempty" url:"location_id,omitempty"`
	// The state of the order.
	// See [OrderState](#type-orderstate) for possible values
	State *OrderState `json:"state,omitempty" url:"state,omitempty"`
	// The timestamp for when the order was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The timestamp for when the order was last updated, in RFC 3339 format.
	UpdatedAt *string `json:"updated_at,omitempty" url:"updated_at,omitempty"`
	// The fulfillments that were updated with this version change.
	FulfillmentUpdate []*OrderFulfillmentUpdatedUpdate `json:"fulfillment_update,omitempty" url:"fulfillment_update,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (o *OrderFulfillmentUpdated) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OrderFulfillmentUpdated) UnmarshalJSON(data []byte) error {
	type unmarshaler OrderFulfillmentUpdated
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OrderFulfillmentUpdated(value)

	extraProperties, err := core.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties

	o._rawJSON = json.RawMessage(data)
	return nil
}

func (o *OrderFulfillmentUpdated) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

type OrderFulfillmentUpdatedObject struct {
	// Information about the updated order fulfillment.
	OrderFulfillmentUpdated *OrderFulfillmentUpdated `json:"order_fulfillment_updated,omitempty" url:"order_fulfillment_updated,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (o *OrderFulfillmentUpdatedObject) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OrderFulfillmentUpdatedObject) UnmarshalJSON(data []byte) error {
	type unmarshaler OrderFulfillmentUpdatedObject
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OrderFulfillmentUpdatedObject(value)

	extraProperties, err := core.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties

	o._rawJSON = json.RawMessage(data)
	return nil
}

func (o *OrderFulfillmentUpdatedObject) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// Information about fulfillment updates.
type OrderFulfillmentUpdatedUpdate struct {
	// A unique ID that identifies the fulfillment only within this order.
	FulfillmentUid *string `json:"fulfillment_uid,omitempty" url:"fulfillment_uid,omitempty"`
	// The state of the fulfillment before the change.
	// The state is not populated if the fulfillment is created with this new `Order` version.
	OldState *OrderFulfillmentState `json:"old_state,omitempty" url:"old_state,omitempty"`
	// The state of the fulfillment after the change. The state might be equal to `old_state` if a non-state
	// field was changed on the fulfillment (such as the tracking number).
	NewState *OrderFulfillmentState `json:"new_state,omitempty" url:"new_state,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (o *OrderFulfillmentUpdatedUpdate) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OrderFulfillmentUpdatedUpdate) UnmarshalJSON(data []byte) error {
	type unmarshaler OrderFulfillmentUpdatedUpdate
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OrderFulfillmentUpdatedUpdate(value)

	extraProperties, err := core.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties

	o._rawJSON = json.RawMessage(data)
	return nil
}

func (o *OrderFulfillmentUpdatedUpdate) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// Published when an [OrderFulfillment](entity:OrderFulfillment)
// is created or updated. This event is triggered only by the
// [UpdateOrder](api-endpoint:Orders-UpdateOrder) endpoint call.
type OrderFulfillmentUpdatedWebhook struct {
	// The ID of the target merchant associated with the event.
	MerchantId *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The type of event this represents, `"order.fulfillment.updated"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// A unique ID for the webhook event.
	EventId *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// Timestamp of when the webhook event was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// Data associated with the event.
	Data *OrderFulfillmentUpdatedWebhookData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (o *OrderFulfillmentUpdatedWebhook) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OrderFulfillmentUpdatedWebhook) UnmarshalJSON(data []byte) error {
	type unmarshaler OrderFulfillmentUpdatedWebhook
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OrderFulfillmentUpdatedWebhook(value)

	extraProperties, err := core.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties

	o._rawJSON = json.RawMessage(data)
	return nil
}

func (o *OrderFulfillmentUpdatedWebhook) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

type OrderFulfillmentUpdatedWebhookData struct {
	// Name of the affected object’s type, `"order"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// ID of the affected order.
	Id *string `json:"id,omitempty" url:"id,omitempty"`
	// An object containing information about the updated Order.
	Object *OrderFulfillmentUpdatedObject `json:"object,omitempty" url:"object,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (o *OrderFulfillmentUpdatedWebhookData) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OrderFulfillmentUpdatedWebhookData) UnmarshalJSON(data []byte) error {
	type unmarshaler OrderFulfillmentUpdatedWebhookData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OrderFulfillmentUpdatedWebhookData(value)

	extraProperties, err := core.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties

	o._rawJSON = json.RawMessage(data)
	return nil
}

func (o *OrderFulfillmentUpdatedWebhookData) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// Represents a line item in an order. Each line item describes a different
// product to purchase, with its own quantity and price details.
type OrderLineItem struct {
	// A unique ID that identifies the line item only within this order.
	Uid *string `json:"uid,omitempty" url:"uid,omitempty"`
	// The name of the line item.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// The quantity purchased, formatted as a decimal number.
	// For example, `"3"`.
	//
	// Line items with a quantity of `"0"` are automatically removed
	// when paying for or otherwise completing the order.
	//
	// Line items with a `quantity_unit` can have non-integer quantities.
	// For example, `"1.70000"`.
	Quantity string `json:"quantity" url:"quantity"`
	// The unit and precision that this line item's quantity is measured in.
	QuantityUnit *OrderQuantityUnit `json:"quantity_unit,omitempty" url:"quantity_unit,omitempty"`
	// The note of the line item.
	Note *string `json:"note,omitempty" url:"note,omitempty"`
	// The [CatalogItemVariation](entity:CatalogItemVariation) ID applied to this line item.
	CatalogObjectId *string `json:"catalog_object_id,omitempty" url:"catalog_object_id,omitempty"`
	// The version of the catalog object that this line item references.
	CatalogVersion *int64 `json:"catalog_version,omitempty" url:"catalog_version,omitempty"`
	// The name of the variation applied to this line item.
	VariationName *string `json:"variation_name,omitempty" url:"variation_name,omitempty"`
	// The type of line item: an itemized sale, a non-itemized sale (custom amount), or the
	// activation or reloading of a gift card.
	// See [OrderLineItemItemType](#type-orderlineitemitemtype) for possible values
	ItemType *OrderLineItemItemType `json:"item_type,omitempty" url:"item_type,omitempty"`
	// Application-defined data attached to this line item. Metadata fields are intended
	// to store descriptive references or associations with an entity in another system or store brief
	// information about the object. Square does not process this field; it only stores and returns it
	// in relevant API calls. Do not use metadata to store any sensitive information (such as personally
	// identifiable information or card details).
	//
	// Keys written by applications must be 60 characters or less and must be in the character set
	// `[a-zA-Z0-9_-]`. Entries can also include metadata generated by Square. These keys are prefixed
	// with a namespace, separated from the key with a ':' character.
	//
	// Values have a maximum length of 255 characters.
	//
	// An application can have up to 10 entries per metadata field.
	//
	// Entries written by applications are private and can only be read or modified by the same
	// application.
	//
	// For more information, see [Metadata](https://developer.squareup.com/docs/build-basics/metadata).
	Metadata map[string]string `json:"metadata,omitempty" url:"metadata,omitempty"`
	// The [CatalogModifier](entity:CatalogModifier)s applied to this line item.
	Modifiers []*OrderLineItemModifier `json:"modifiers,omitempty" url:"modifiers,omitempty"`
	// The list of references to taxes applied to this line item. Each
	// `OrderLineItemAppliedTax` has a `tax_uid` that references the `uid` of a
	// top-level `OrderLineItemTax` applied to the line item. On reads, the
	// amount applied is populated.
	//
	// An `OrderLineItemAppliedTax` is automatically created on every line
	// item for all `ORDER` scoped taxes added to the order. `OrderLineItemAppliedTax`
	// records for `LINE_ITEM` scoped taxes must be added in requests for the tax
	// to apply to any line items.
	//
	// To change the amount of a tax, modify the referenced top-level tax.
	AppliedTaxes []*OrderLineItemAppliedTax `json:"applied_taxes,omitempty" url:"applied_taxes,omitempty"`
	// The list of references to discounts applied to this line item. Each
	// `OrderLineItemAppliedDiscount` has a `discount_uid` that references the `uid` of a top-level
	// `OrderLineItemDiscounts` applied to the line item. On reads, the amount
	// applied is populated.
	//
	// An `OrderLineItemAppliedDiscount` is automatically created on every line item for all
	// `ORDER` scoped discounts that are added to the order. `OrderLineItemAppliedDiscount` records
	// for `LINE_ITEM` scoped discounts must be added in requests for the discount to apply to any
	// line items.
	//
	// To change the amount of a discount, modify the referenced top-level discount.
	AppliedDiscounts []*OrderLineItemAppliedDiscount `json:"applied_discounts,omitempty" url:"applied_discounts,omitempty"`
	// The base price for a single unit of the line item.
	BasePriceMoney *Money `json:"base_price_money,omitempty" url:"base_price_money,omitempty"`
	// The total price of all item variations sold in this line item.
	// The price is calculated as `base_price_money` multiplied by `quantity`.
	// It does not include modifiers.
	VariationTotalPriceMoney *Money `json:"variation_total_price_money,omitempty" url:"variation_total_price_money,omitempty"`
	// The amount of money made in gross sales for this line item.
	// The amount is calculated as the sum of the variation's total price and each modifier's total price.
	GrossSalesMoney *Money `json:"gross_sales_money,omitempty" url:"gross_sales_money,omitempty"`
	// The total amount of tax money to collect for the line item.
	TotalTaxMoney *Money `json:"total_tax_money,omitempty" url:"total_tax_money,omitempty"`
	// The total amount of discount money to collect for the line item.
	TotalDiscountMoney *Money `json:"total_discount_money,omitempty" url:"total_discount_money,omitempty"`
	// The total amount of money to collect for this line item.
	TotalMoney *Money `json:"total_money,omitempty" url:"total_money,omitempty"`
	// Describes pricing adjustments that are blocked from manual and
	// automatic application to a line item. For more information, see
	// [Apply Taxes and Discounts](https://developer.squareup.com/docs/orders-api/apply-taxes-and-discounts).
	PricingBlocklists *OrderLineItemPricingBlocklists `json:"pricing_blocklists,omitempty" url:"pricing_blocklists,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (o *OrderLineItem) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OrderLineItem) UnmarshalJSON(data []byte) error {
	type unmarshaler OrderLineItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OrderLineItem(value)

	extraProperties, err := core.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties

	o._rawJSON = json.RawMessage(data)
	return nil
}

func (o *OrderLineItem) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// Represents an applied portion of a discount to a line item in an order.
//
// Order scoped discounts have automatically applied discounts present for each line item.
// Line-item scoped discounts must have applied discounts added manually for any applicable line
// items. The corresponding applied money is automatically computed based on participating
// line items.
type OrderLineItemAppliedDiscount struct {
	// A unique ID that identifies the applied discount only within this order.
	Uid *string `json:"uid,omitempty" url:"uid,omitempty"`
	// The `uid` of the discount that the applied discount represents. It must
	// reference a discount present in the `order.discounts` field.
	//
	// This field is immutable. To change which discounts apply to a line item,
	// you must delete the discount and re-add it as a new `OrderLineItemAppliedDiscount`.
	DiscountUid string `json:"discount_uid" url:"discount_uid"`
	// The amount of money applied by the discount to the line item.
	AppliedMoney *Money `json:"applied_money,omitempty" url:"applied_money,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (o *OrderLineItemAppliedDiscount) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OrderLineItemAppliedDiscount) UnmarshalJSON(data []byte) error {
	type unmarshaler OrderLineItemAppliedDiscount
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OrderLineItemAppliedDiscount(value)

	extraProperties, err := core.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties

	o._rawJSON = json.RawMessage(data)
	return nil
}

func (o *OrderLineItemAppliedDiscount) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// Represents an applied portion of a tax to a line item in an order.
//
// Order-scoped taxes automatically include the applied taxes in each line item.
// Line item taxes must be referenced from any applicable line items.
// The corresponding applied money is automatically computed, based on the
// set of participating line items.
type OrderLineItemAppliedTax struct {
	// A unique ID that identifies the applied tax only within this order.
	Uid *string `json:"uid,omitempty" url:"uid,omitempty"`
	// The `uid` of the tax for which this applied tax represents. It must reference
	// a tax present in the `order.taxes` field.
	//
	// This field is immutable. To change which taxes apply to a line item, delete and add a new
	// `OrderLineItemAppliedTax`.
	TaxUid string `json:"tax_uid" url:"tax_uid"`
	// The amount of money applied by the tax to the line item.
	AppliedMoney *Money `json:"applied_money,omitempty" url:"applied_money,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (o *OrderLineItemAppliedTax) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OrderLineItemAppliedTax) UnmarshalJSON(data []byte) error {
	type unmarshaler OrderLineItemAppliedTax
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OrderLineItemAppliedTax(value)

	extraProperties, err := core.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties

	o._rawJSON = json.RawMessage(data)
	return nil
}

func (o *OrderLineItemAppliedTax) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// Represents a discount that applies to one or more line items in an
// order.
//
// Fixed-amount, order-scoped discounts are distributed across all non-zero line item totals.
// The amount distributed to each line item is relative to the
// amount contributed by the item to the order subtotal.
type OrderLineItemDiscount struct {
	// A unique ID that identifies the discount only within this order.
	Uid *string `json:"uid,omitempty" url:"uid,omitempty"`
	// The catalog object ID referencing [CatalogDiscount](entity:CatalogDiscount).
	CatalogObjectId *string `json:"catalog_object_id,omitempty" url:"catalog_object_id,omitempty"`
	// The version of the catalog object that this discount references.
	CatalogVersion *int64 `json:"catalog_version,omitempty" url:"catalog_version,omitempty"`
	// The discount's name.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// The type of the discount.
	//
	// Discounts that do not reference a catalog object ID must have a type of
	// `FIXED_PERCENTAGE` or `FIXED_AMOUNT`.
	// See [OrderLineItemDiscountType](#type-orderlineitemdiscounttype) for possible values
	Type *OrderLineItemDiscountType `json:"type,omitempty" url:"type,omitempty"`
	// The percentage of the discount, as a string representation of a decimal number.
	// A value of `7.25` corresponds to a percentage of 7.25%.
	//
	// `percentage` is not set for amount-based discounts.
	Percentage *string `json:"percentage,omitempty" url:"percentage,omitempty"`
	// The total declared monetary amount of the discount.
	//
	// `amount_money` is not set for percentage-based discounts.
	AmountMoney *Money `json:"amount_money,omitempty" url:"amount_money,omitempty"`
	// The amount of discount actually applied to the line item.
	//
	// The amount represents the amount of money applied as a line-item scoped discount.
	// When an amount-based discount is scoped to the entire order, the value
	// of `applied_money` is different than `amount_money` because the total
	// amount of the discount is distributed across all line items.
	AppliedMoney *Money `json:"applied_money,omitempty" url:"applied_money,omitempty"`
	// Application-defined data attached to this discount. Metadata fields are intended
	// to store descriptive references or associations with an entity in another system or store brief
	// information about the object. Square does not process this field; it only stores and returns it
	// in relevant API calls. Do not use metadata to store any sensitive information (such as personally
	// identifiable information or card details).
	//
	// Keys written by applications must be 60 characters or less and must be in the character set
	// `[a-zA-Z0-9_-]`. Entries can also include metadata generated by Square. These keys are prefixed
	// with a namespace, separated from the key with a ':' character.
	//
	// Values have a maximum length of 255 characters.
	//
	// An application can have up to 10 entries per metadata field.
	//
	// Entries written by applications are private and can only be read or modified by the same
	// application.
	//
	// For more information, see [Metadata](https://developer.squareup.com/docs/build-basics/metadata).
	Metadata map[string]string `json:"metadata,omitempty" url:"metadata,omitempty"`
	// Indicates the level at which the discount applies. For `ORDER` scoped discounts,
	// Square generates references in `applied_discounts` on all order line items that do
	// not have them. For `LINE_ITEM` scoped discounts, the discount only applies to line items
	// with a discount reference in their `applied_discounts` field.
	//
	// This field is immutable. To change the scope of a discount, you must delete
	// the discount and re-add it as a new discount.
	// See [OrderLineItemDiscountScope](#type-orderlineitemdiscountscope) for possible values
	Scope *OrderLineItemDiscountScope `json:"scope,omitempty" url:"scope,omitempty"`
	// The reward IDs corresponding to this discount. The application and
	// specification of discounts that have `reward_ids` are completely controlled by the backing
	// criteria corresponding to the reward tiers of the rewards that are added to the order
	// through the Loyalty API. To manually unapply discounts that are the result of added rewards,
	// the rewards must be removed from the order through the Loyalty API.
	RewardIds []string `json:"reward_ids,omitempty" url:"reward_ids,omitempty"`
	// The object ID of a [pricing rule](entity:CatalogPricingRule) to be applied
	// automatically to this discount. The specification and application of the discounts, to
	// which a `pricing_rule_id` is assigned, are completely controlled by the corresponding
	// pricing rule.
	PricingRuleId *string `json:"pricing_rule_id,omitempty" url:"pricing_rule_id,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (o *OrderLineItemDiscount) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OrderLineItemDiscount) UnmarshalJSON(data []byte) error {
	type unmarshaler OrderLineItemDiscount
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OrderLineItemDiscount(value)

	extraProperties, err := core.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties

	o._rawJSON = json.RawMessage(data)
	return nil
}

func (o *OrderLineItemDiscount) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// Indicates whether this is a line-item or order-level discount.
type OrderLineItemDiscountScope string

const (
	OrderLineItemDiscountScopeOtherDiscountScope OrderLineItemDiscountScope = "OTHER_DISCOUNT_SCOPE"
	OrderLineItemDiscountScopeLineItem           OrderLineItemDiscountScope = "LINE_ITEM"
	OrderLineItemDiscountScopeOrder              OrderLineItemDiscountScope = "ORDER"
)

func NewOrderLineItemDiscountScopeFromString(s string) (OrderLineItemDiscountScope, error) {
	switch s {
	case "OTHER_DISCOUNT_SCOPE":
		return OrderLineItemDiscountScopeOtherDiscountScope, nil
	case "LINE_ITEM":
		return OrderLineItemDiscountScopeLineItem, nil
	case "ORDER":
		return OrderLineItemDiscountScopeOrder, nil
	}
	var t OrderLineItemDiscountScope
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (o OrderLineItemDiscountScope) Ptr() *OrderLineItemDiscountScope {
	return &o
}

// Indicates how the discount is applied to the associated line item or order.
type OrderLineItemDiscountType string

const (
	OrderLineItemDiscountTypeUnknownDiscount    OrderLineItemDiscountType = "UNKNOWN_DISCOUNT"
	OrderLineItemDiscountTypeFixedPercentage    OrderLineItemDiscountType = "FIXED_PERCENTAGE"
	OrderLineItemDiscountTypeFixedAmount        OrderLineItemDiscountType = "FIXED_AMOUNT"
	OrderLineItemDiscountTypeVariablePercentage OrderLineItemDiscountType = "VARIABLE_PERCENTAGE"
	OrderLineItemDiscountTypeVariableAmount     OrderLineItemDiscountType = "VARIABLE_AMOUNT"
)

func NewOrderLineItemDiscountTypeFromString(s string) (OrderLineItemDiscountType, error) {
	switch s {
	case "UNKNOWN_DISCOUNT":
		return OrderLineItemDiscountTypeUnknownDiscount, nil
	case "FIXED_PERCENTAGE":
		return OrderLineItemDiscountTypeFixedPercentage, nil
	case "FIXED_AMOUNT":
		return OrderLineItemDiscountTypeFixedAmount, nil
	case "VARIABLE_PERCENTAGE":
		return OrderLineItemDiscountTypeVariablePercentage, nil
	case "VARIABLE_AMOUNT":
		return OrderLineItemDiscountTypeVariableAmount, nil
	}
	var t OrderLineItemDiscountType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (o OrderLineItemDiscountType) Ptr() *OrderLineItemDiscountType {
	return &o
}

// Represents the line item type.
type OrderLineItemItemType string

const (
	OrderLineItemItemTypeDoNotUse     OrderLineItemItemType = "DO_NOT_USE"
	OrderLineItemItemTypeItem         OrderLineItemItemType = "ITEM"
	OrderLineItemItemTypeCustomAmount OrderLineItemItemType = "CUSTOM_AMOUNT"
	OrderLineItemItemTypeGiftCard     OrderLineItemItemType = "GIFT_CARD"
)

func NewOrderLineItemItemTypeFromString(s string) (OrderLineItemItemType, error) {
	switch s {
	case "DO_NOT_USE":
		return OrderLineItemItemTypeDoNotUse, nil
	case "ITEM":
		return OrderLineItemItemTypeItem, nil
	case "CUSTOM_AMOUNT":
		return OrderLineItemItemTypeCustomAmount, nil
	case "GIFT_CARD":
		return OrderLineItemItemTypeGiftCard, nil
	}
	var t OrderLineItemItemType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (o OrderLineItemItemType) Ptr() *OrderLineItemItemType {
	return &o
}

// A [CatalogModifier](entity:CatalogModifier).
type OrderLineItemModifier struct {
	// A unique ID that identifies the modifier only within this order.
	Uid *string `json:"uid,omitempty" url:"uid,omitempty"`
	// The catalog object ID referencing [CatalogModifier](entity:CatalogModifier).
	CatalogObjectId *string `json:"catalog_object_id,omitempty" url:"catalog_object_id,omitempty"`
	// The version of the catalog object that this modifier references.
	CatalogVersion *int64 `json:"catalog_version,omitempty" url:"catalog_version,omitempty"`
	// The name of the item modifier.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// The quantity of the line item modifier. The modifier quantity can be 0 or more.
	// For example, suppose a restaurant offers a cheeseburger on the menu. When a buyer orders
	// this item, the restaurant records the purchase by creating an `Order` object with a line item
	// for a burger. The line item includes a line item modifier: the name is cheese and the quantity
	// is 1. The buyer has the option to order extra cheese (or no cheese). If the buyer chooses
	// the extra cheese option, the modifier quantity increases to 2. If the buyer does not want
	// any cheese, the modifier quantity is set to 0.
	Quantity *string `json:"quantity,omitempty" url:"quantity,omitempty"`
	// The base price for the modifier.
	//
	// `base_price_money` is required for ad hoc modifiers.
	// If both `catalog_object_id` and `base_price_money` are set, `base_price_money` will
	// override the predefined [CatalogModifier](entity:CatalogModifier) price.
	BasePriceMoney *Money `json:"base_price_money,omitempty" url:"base_price_money,omitempty"`
	// The total price of the item modifier for its line item.
	// This is the modifier's `base_price_money` multiplied by the line item's quantity.
	TotalPriceMoney *Money `json:"total_price_money,omitempty" url:"total_price_money,omitempty"`
	// Application-defined data attached to this order. Metadata fields are intended
	// to store descriptive references or associations with an entity in another system or store brief
	// information about the object. Square does not process this field; it only stores and returns it
	// in relevant API calls. Do not use metadata to store any sensitive information (such as personally
	// identifiable information or card details).
	//
	// Keys written by applications must be 60 characters or less and must be in the character set
	// `[a-zA-Z0-9_-]`. Entries can also include metadata generated by Square. These keys are prefixed
	// with a namespace, separated from the key with a ':' character.
	//
	// Values have a maximum length of 255 characters.
	//
	// An application can have up to 10 entries per metadata field.
	//
	// Entries written by applications are private and can only be read or modified by the same
	// application.
	//
	// For more information, see [Metadata](https://developer.squareup.com/docs/build-basics/metadata).
	Metadata map[string]string `json:"metadata,omitempty" url:"metadata,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (o *OrderLineItemModifier) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OrderLineItemModifier) UnmarshalJSON(data []byte) error {
	type unmarshaler OrderLineItemModifier
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OrderLineItemModifier(value)

	extraProperties, err := core.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties

	o._rawJSON = json.RawMessage(data)
	return nil
}

func (o *OrderLineItemModifier) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// Describes pricing adjustments that are blocked from manual and
// automatic application to a line item. For more information, see
// [Apply Taxes and Discounts](https://developer.squareup.com/docs/orders-api/apply-taxes-and-discounts).
type OrderLineItemPricingBlocklists struct {
	// A list of discounts blocked from applying to the line item.
	// Discounts can be blocked by the `discount_uid` (for ad hoc discounts) or
	// the `discount_catalog_object_id` (for catalog discounts).
	BlockedDiscounts []*OrderLineItemPricingBlocklistsBlockedDiscount `json:"blocked_discounts,omitempty" url:"blocked_discounts,omitempty"`
	// A list of taxes blocked from applying to the line item.
	// Taxes can be blocked by the `tax_uid` (for ad hoc taxes) or
	// the `tax_catalog_object_id` (for catalog taxes).
	BlockedTaxes []*OrderLineItemPricingBlocklistsBlockedTax `json:"blocked_taxes,omitempty" url:"blocked_taxes,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (o *OrderLineItemPricingBlocklists) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OrderLineItemPricingBlocklists) UnmarshalJSON(data []byte) error {
	type unmarshaler OrderLineItemPricingBlocklists
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OrderLineItemPricingBlocklists(value)

	extraProperties, err := core.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties

	o._rawJSON = json.RawMessage(data)
	return nil
}

func (o *OrderLineItemPricingBlocklists) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// A discount to block from applying to a line item. The discount must be
// identified by either `discount_uid` or `discount_catalog_object_id`, but not both.
type OrderLineItemPricingBlocklistsBlockedDiscount struct {
	// A unique ID of the `BlockedDiscount` within the order.
	Uid *string `json:"uid,omitempty" url:"uid,omitempty"`
	// The `uid` of the discount that should be blocked. Use this field to block
	// ad hoc discounts. For catalog discounts, use the `discount_catalog_object_id` field.
	DiscountUid *string `json:"discount_uid,omitempty" url:"discount_uid,omitempty"`
	// The `catalog_object_id` of the discount that should be blocked.
	// Use this field to block catalog discounts. For ad hoc discounts, use the
	// `discount_uid` field.
	DiscountCatalogObjectId *string `json:"discount_catalog_object_id,omitempty" url:"discount_catalog_object_id,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (o *OrderLineItemPricingBlocklistsBlockedDiscount) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OrderLineItemPricingBlocklistsBlockedDiscount) UnmarshalJSON(data []byte) error {
	type unmarshaler OrderLineItemPricingBlocklistsBlockedDiscount
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OrderLineItemPricingBlocklistsBlockedDiscount(value)

	extraProperties, err := core.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties

	o._rawJSON = json.RawMessage(data)
	return nil
}

func (o *OrderLineItemPricingBlocklistsBlockedDiscount) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// A tax to block from applying to a line item. The tax must be
// identified by either `tax_uid` or `tax_catalog_object_id`, but not both.
type OrderLineItemPricingBlocklistsBlockedTax struct {
	// A unique ID of the `BlockedTax` within the order.
	Uid *string `json:"uid,omitempty" url:"uid,omitempty"`
	// The `uid` of the tax that should be blocked. Use this field to block
	// ad hoc taxes. For catalog, taxes use the `tax_catalog_object_id` field.
	TaxUid *string `json:"tax_uid,omitempty" url:"tax_uid,omitempty"`
	// The `catalog_object_id` of the tax that should be blocked.
	// Use this field to block catalog taxes. For ad hoc taxes, use the
	// `tax_uid` field.
	TaxCatalogObjectId *string `json:"tax_catalog_object_id,omitempty" url:"tax_catalog_object_id,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (o *OrderLineItemPricingBlocklistsBlockedTax) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OrderLineItemPricingBlocklistsBlockedTax) UnmarshalJSON(data []byte) error {
	type unmarshaler OrderLineItemPricingBlocklistsBlockedTax
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OrderLineItemPricingBlocklistsBlockedTax(value)

	extraProperties, err := core.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties

	o._rawJSON = json.RawMessage(data)
	return nil
}

func (o *OrderLineItemPricingBlocklistsBlockedTax) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// Represents a tax that applies to one or more line item in the order.
//
// Fixed-amount, order-scoped taxes are distributed across all non-zero line item totals.
// The amount distributed to each line item is relative to the amount the item
// contributes to the order subtotal.
type OrderLineItemTax struct {
	// A unique ID that identifies the tax only within this order.
	Uid *string `json:"uid,omitempty" url:"uid,omitempty"`
	// The catalog object ID referencing [CatalogTax](entity:CatalogTax).
	CatalogObjectId *string `json:"catalog_object_id,omitempty" url:"catalog_object_id,omitempty"`
	// The version of the catalog object that this tax references.
	CatalogVersion *int64 `json:"catalog_version,omitempty" url:"catalog_version,omitempty"`
	// The tax's name.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// Indicates the calculation method used to apply the tax.
	// See [OrderLineItemTaxType](#type-orderlineitemtaxtype) for possible values
	Type *OrderLineItemTaxType `json:"type,omitempty" url:"type,omitempty"`
	// The percentage of the tax, as a string representation of a decimal
	// number. For example, a value of `"7.25"` corresponds to a percentage of
	// 7.25%.
	Percentage *string `json:"percentage,omitempty" url:"percentage,omitempty"`
	// Application-defined data attached to this tax. Metadata fields are intended
	// to store descriptive references or associations with an entity in another system or store brief
	// information about the object. Square does not process this field; it only stores and returns it
	// in relevant API calls. Do not use metadata to store any sensitive information (such as personally
	// identifiable information or card details).
	//
	// Keys written by applications must be 60 characters or less and must be in the character set
	// `[a-zA-Z0-9_-]`. Entries can also include metadata generated by Square. These keys are prefixed
	// with a namespace, separated from the key with a ':' character.
	//
	// Values have a maximum length of 255 characters.
	//
	// An application can have up to 10 entries per metadata field.
	//
	// Entries written by applications are private and can only be read or modified by the same
	// application.
	//
	// For more information, see [Metadata](https://developer.squareup.com/docs/build-basics/metadata).
	Metadata map[string]string `json:"metadata,omitempty" url:"metadata,omitempty"`
	// The amount of money applied by the tax in the order.
	AppliedMoney *Money `json:"applied_money,omitempty" url:"applied_money,omitempty"`
	// Indicates the level at which the tax applies. For `ORDER` scoped taxes,
	// Square generates references in `applied_taxes` on all order line items that do
	// not have them. For `LINE_ITEM` scoped taxes, the tax only applies to line items
	// with references in their `applied_taxes` field.
	//
	// This field is immutable. To change the scope, you must delete the tax and
	// re-add it as a new tax.
	// See [OrderLineItemTaxScope](#type-orderlineitemtaxscope) for possible values
	Scope *OrderLineItemTaxScope `json:"scope,omitempty" url:"scope,omitempty"`
	// Determines whether the tax was automatically applied to the order based on
	// the catalog configuration. For an example, see
	// [Automatically Apply Taxes to an Order](https://developer.squareup.com/docs/orders-api/apply-taxes-and-discounts/auto-apply-taxes).
	AutoApplied *bool `json:"auto_applied,omitempty" url:"auto_applied,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (o *OrderLineItemTax) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OrderLineItemTax) UnmarshalJSON(data []byte) error {
	type unmarshaler OrderLineItemTax
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OrderLineItemTax(value)

	extraProperties, err := core.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties

	o._rawJSON = json.RawMessage(data)
	return nil
}

func (o *OrderLineItemTax) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// Indicates whether this is a line-item or order-level tax.
type OrderLineItemTaxScope string

const (
	OrderLineItemTaxScopeOtherTaxScope OrderLineItemTaxScope = "OTHER_TAX_SCOPE"
	OrderLineItemTaxScopeLineItem      OrderLineItemTaxScope = "LINE_ITEM"
	OrderLineItemTaxScopeOrder         OrderLineItemTaxScope = "ORDER"
)

func NewOrderLineItemTaxScopeFromString(s string) (OrderLineItemTaxScope, error) {
	switch s {
	case "OTHER_TAX_SCOPE":
		return OrderLineItemTaxScopeOtherTaxScope, nil
	case "LINE_ITEM":
		return OrderLineItemTaxScopeLineItem, nil
	case "ORDER":
		return OrderLineItemTaxScopeOrder, nil
	}
	var t OrderLineItemTaxScope
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (o OrderLineItemTaxScope) Ptr() *OrderLineItemTaxScope {
	return &o
}

// Indicates how the tax is applied to the associated line item or order.
type OrderLineItemTaxType string

const (
	OrderLineItemTaxTypeUnknownTax OrderLineItemTaxType = "UNKNOWN_TAX"
	OrderLineItemTaxTypeAdditive   OrderLineItemTaxType = "ADDITIVE"
	OrderLineItemTaxTypeInclusive  OrderLineItemTaxType = "INCLUSIVE"
)

func NewOrderLineItemTaxTypeFromString(s string) (OrderLineItemTaxType, error) {
	switch s {
	case "UNKNOWN_TAX":
		return OrderLineItemTaxTypeUnknownTax, nil
	case "ADDITIVE":
		return OrderLineItemTaxTypeAdditive, nil
	case "INCLUSIVE":
		return OrderLineItemTaxTypeInclusive, nil
	}
	var t OrderLineItemTaxType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (o OrderLineItemTaxType) Ptr() *OrderLineItemTaxType {
	return &o
}

// A collection of various money amounts.
type OrderMoneyAmounts struct {
	// The total money.
	TotalMoney *Money `json:"total_money,omitempty" url:"total_money,omitempty"`
	// The money associated with taxes.
	TaxMoney *Money `json:"tax_money,omitempty" url:"tax_money,omitempty"`
	// The money associated with discounts.
	DiscountMoney *Money `json:"discount_money,omitempty" url:"discount_money,omitempty"`
	// The money associated with tips.
	TipMoney *Money `json:"tip_money,omitempty" url:"tip_money,omitempty"`
	// The money associated with service charges.
	ServiceChargeMoney *Money `json:"service_charge_money,omitempty" url:"service_charge_money,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (o *OrderMoneyAmounts) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OrderMoneyAmounts) UnmarshalJSON(data []byte) error {
	type unmarshaler OrderMoneyAmounts
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OrderMoneyAmounts(value)

	extraProperties, err := core.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties

	o._rawJSON = json.RawMessage(data)
	return nil
}

func (o *OrderMoneyAmounts) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// Pricing options for an order. The options affect how the order's price is calculated.
// They can be used, for example, to apply automatic price adjustments that are based on preconfigured
// [pricing rules](entity:CatalogPricingRule).
type OrderPricingOptions struct {
	// The option to determine whether pricing rule-based
	// discounts are automatically applied to an order.
	AutoApplyDiscounts *bool `json:"auto_apply_discounts,omitempty" url:"auto_apply_discounts,omitempty"`
	// The option to determine whether rule-based taxes are automatically
	// applied to an order when the criteria of the corresponding rules are met.
	AutoApplyTaxes *bool `json:"auto_apply_taxes,omitempty" url:"auto_apply_taxes,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (o *OrderPricingOptions) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OrderPricingOptions) UnmarshalJSON(data []byte) error {
	type unmarshaler OrderPricingOptions
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OrderPricingOptions(value)

	extraProperties, err := core.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties

	o._rawJSON = json.RawMessage(data)
	return nil
}

func (o *OrderPricingOptions) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// Contains the measurement unit for a quantity and a precision that
// specifies the number of digits after the decimal point for decimal quantities.
type OrderQuantityUnit struct {
	// A [MeasurementUnit](entity:MeasurementUnit) that represents the
	// unit of measure for the quantity.
	MeasurementUnit *MeasurementUnit `json:"measurement_unit,omitempty" url:"measurement_unit,omitempty"`
	// For non-integer quantities, represents the number of digits after the decimal point that are
	// recorded for this quantity.
	//
	// For example, a precision of 1 allows quantities such as `"1.0"` and `"1.1"`, but not `"1.01"`.
	//
	// Min: 0. Max: 5.
	Precision *int `json:"precision,omitempty" url:"precision,omitempty"`
	// The catalog object ID referencing the
	// [CatalogMeasurementUnit](entity:CatalogMeasurementUnit).
	//
	// This field is set when this is a catalog-backed measurement unit.
	CatalogObjectId *string `json:"catalog_object_id,omitempty" url:"catalog_object_id,omitempty"`
	// The version of the catalog object that this measurement unit references.
	//
	// This field is set when this is a catalog-backed measurement unit.
	CatalogVersion *int64 `json:"catalog_version,omitempty" url:"catalog_version,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (o *OrderQuantityUnit) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OrderQuantityUnit) UnmarshalJSON(data []byte) error {
	type unmarshaler OrderQuantityUnit
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OrderQuantityUnit(value)

	extraProperties, err := core.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties

	o._rawJSON = json.RawMessage(data)
	return nil
}

func (o *OrderQuantityUnit) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// The set of line items, service charges, taxes, discounts, tips, and other items being returned in an order.
type OrderReturn struct {
	// A unique ID that identifies the return only within this order.
	Uid *string `json:"uid,omitempty" url:"uid,omitempty"`
	// An order that contains the original sale of these return line items. This is unset
	// for unlinked returns.
	SourceOrderId *string `json:"source_order_id,omitempty" url:"source_order_id,omitempty"`
	// A collection of line items that are being returned.
	ReturnLineItems []*OrderReturnLineItem `json:"return_line_items,omitempty" url:"return_line_items,omitempty"`
	// A collection of service charges that are being returned.
	ReturnServiceCharges []*OrderReturnServiceCharge `json:"return_service_charges,omitempty" url:"return_service_charges,omitempty"`
	// A collection of references to taxes being returned for an order, including the total
	// applied tax amount to be returned. The taxes must reference a top-level tax ID from the source
	// order.
	ReturnTaxes []*OrderReturnTax `json:"return_taxes,omitempty" url:"return_taxes,omitempty"`
	// A collection of references to discounts being returned for an order, including the total
	// applied discount amount to be returned. The discounts must reference a top-level discount ID
	// from the source order.
	ReturnDiscounts []*OrderReturnDiscount `json:"return_discounts,omitempty" url:"return_discounts,omitempty"`
	// A positive or negative rounding adjustment to the total value being returned. Adjustments are commonly
	// used to apply cash rounding when the minimum unit of the account is smaller than the lowest
	// physical denomination of the currency.
	RoundingAdjustment *OrderRoundingAdjustment `json:"rounding_adjustment,omitempty" url:"rounding_adjustment,omitempty"`
	// An aggregate monetary value being returned by this return entry.
	ReturnAmounts *OrderMoneyAmounts `json:"return_amounts,omitempty" url:"return_amounts,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (o *OrderReturn) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OrderReturn) UnmarshalJSON(data []byte) error {
	type unmarshaler OrderReturn
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OrderReturn(value)

	extraProperties, err := core.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties

	o._rawJSON = json.RawMessage(data)
	return nil
}

func (o *OrderReturn) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// Represents a discount being returned that applies to one or more return line items in an
// order.
//
// Fixed-amount, order-scoped discounts are distributed across all non-zero return line item totals.
// The amount distributed to each return line item is relative to that item’s contribution to the
// order subtotal.
type OrderReturnDiscount struct {
	// A unique ID that identifies the returned discount only within this order.
	Uid *string `json:"uid,omitempty" url:"uid,omitempty"`
	// The discount `uid` from the order that contains the original application of this discount.
	SourceDiscountUid *string `json:"source_discount_uid,omitempty" url:"source_discount_uid,omitempty"`
	// The catalog object ID referencing [CatalogDiscount](entity:CatalogDiscount).
	CatalogObjectId *string `json:"catalog_object_id,omitempty" url:"catalog_object_id,omitempty"`
	// The version of the catalog object that this discount references.
	CatalogVersion *int64 `json:"catalog_version,omitempty" url:"catalog_version,omitempty"`
	// The discount's name.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// The type of the discount. If it is created by the API, it is `FIXED_PERCENTAGE` or `FIXED_AMOUNT`.
	//
	// Discounts that do not reference a catalog object ID must have a type of
	// `FIXED_PERCENTAGE` or `FIXED_AMOUNT`.
	// See [OrderLineItemDiscountType](#type-orderlineitemdiscounttype) for possible values
	Type *OrderLineItemDiscountType `json:"type,omitempty" url:"type,omitempty"`
	// The percentage of the tax, as a string representation of a decimal number.
	// A value of `"7.25"` corresponds to a percentage of 7.25%.
	//
	// `percentage` is not set for amount-based discounts.
	Percentage *string `json:"percentage,omitempty" url:"percentage,omitempty"`
	// The total declared monetary amount of the discount.
	//
	// `amount_money` is not set for percentage-based discounts.
	AmountMoney *Money `json:"amount_money,omitempty" url:"amount_money,omitempty"`
	// The amount of discount actually applied to this line item. When an amount-based
	// discount is at the order level, this value is different from `amount_money` because the discount
	// is distributed across the line items.
	AppliedMoney *Money `json:"applied_money,omitempty" url:"applied_money,omitempty"`
	// Indicates the level at which the `OrderReturnDiscount` applies. For `ORDER` scoped
	// discounts, the server generates references in `applied_discounts` on all
	// `OrderReturnLineItem`s. For `LINE_ITEM` scoped discounts, the discount is only applied to
	// `OrderReturnLineItem`s with references in their `applied_discounts` field.
	// See [OrderLineItemDiscountScope](#type-orderlineitemdiscountscope) for possible values
	Scope *OrderLineItemDiscountScope `json:"scope,omitempty" url:"scope,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (o *OrderReturnDiscount) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OrderReturnDiscount) UnmarshalJSON(data []byte) error {
	type unmarshaler OrderReturnDiscount
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OrderReturnDiscount(value)

	extraProperties, err := core.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties

	o._rawJSON = json.RawMessage(data)
	return nil
}

func (o *OrderReturnDiscount) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// The line item being returned in an order.
type OrderReturnLineItem struct {
	// A unique ID for this return line-item entry.
	Uid *string `json:"uid,omitempty" url:"uid,omitempty"`
	// The `uid` of the line item in the original sale order.
	SourceLineItemUid *string `json:"source_line_item_uid,omitempty" url:"source_line_item_uid,omitempty"`
	// The name of the line item.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// The quantity returned, formatted as a decimal number.
	// For example, `"3"`.
	//
	// Line items with a `quantity_unit` can have non-integer quantities.
	// For example, `"1.70000"`.
	Quantity string `json:"quantity" url:"quantity"`
	// The unit and precision that this return line item's quantity is measured in.
	QuantityUnit *OrderQuantityUnit `json:"quantity_unit,omitempty" url:"quantity_unit,omitempty"`
	// The note of the return line item.
	Note *string `json:"note,omitempty" url:"note,omitempty"`
	// The [CatalogItemVariation](entity:CatalogItemVariation) ID applied to this return line item.
	CatalogObjectId *string `json:"catalog_object_id,omitempty" url:"catalog_object_id,omitempty"`
	// The version of the catalog object that this line item references.
	CatalogVersion *int64 `json:"catalog_version,omitempty" url:"catalog_version,omitempty"`
	// The name of the variation applied to this return line item.
	VariationName *string `json:"variation_name,omitempty" url:"variation_name,omitempty"`
	// The type of line item: an itemized return, a non-itemized return (custom amount),
	// or the return of an unactivated gift card sale.
	// See [OrderLineItemItemType](#type-orderlineitemitemtype) for possible values
	ItemType *OrderLineItemItemType `json:"item_type,omitempty" url:"item_type,omitempty"`
	// The [CatalogModifier](entity:CatalogModifier)s applied to this line item.
	ReturnModifiers []*OrderReturnLineItemModifier `json:"return_modifiers,omitempty" url:"return_modifiers,omitempty"`
	// The list of references to `OrderReturnTax` entities applied to the return line item. Each
	// `OrderLineItemAppliedTax` has a `tax_uid` that references the `uid` of a top-level
	// `OrderReturnTax` applied to the return line item. On reads, the applied amount
	// is populated.
	AppliedTaxes []*OrderLineItemAppliedTax `json:"applied_taxes,omitempty" url:"applied_taxes,omitempty"`
	// The list of references to `OrderReturnDiscount` entities applied to the return line item. Each
	// `OrderLineItemAppliedDiscount` has a `discount_uid` that references the `uid` of a top-level
	// `OrderReturnDiscount` applied to the return line item. On reads, the applied amount
	// is populated.
	AppliedDiscounts []*OrderLineItemAppliedDiscount `json:"applied_discounts,omitempty" url:"applied_discounts,omitempty"`
	// The base price for a single unit of the line item.
	BasePriceMoney *Money `json:"base_price_money,omitempty" url:"base_price_money,omitempty"`
	// The total price of all item variations returned in this line item.
	// The price is calculated as `base_price_money` multiplied by `quantity` and
	// does not include modifiers.
	VariationTotalPriceMoney *Money `json:"variation_total_price_money,omitempty" url:"variation_total_price_money,omitempty"`
	// The gross return amount of money calculated as (item base price + modifiers price) \* quantity.
	GrossReturnMoney *Money `json:"gross_return_money,omitempty" url:"gross_return_money,omitempty"`
	// The total amount of tax money to return for the line item.
	TotalTaxMoney *Money `json:"total_tax_money,omitempty" url:"total_tax_money,omitempty"`
	// The total amount of discount money to return for the line item.
	TotalDiscountMoney *Money `json:"total_discount_money,omitempty" url:"total_discount_money,omitempty"`
	// The total amount of money to return for this line item.
	TotalMoney *Money `json:"total_money,omitempty" url:"total_money,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (o *OrderReturnLineItem) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OrderReturnLineItem) UnmarshalJSON(data []byte) error {
	type unmarshaler OrderReturnLineItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OrderReturnLineItem(value)

	extraProperties, err := core.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties

	o._rawJSON = json.RawMessage(data)
	return nil
}

func (o *OrderReturnLineItem) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// A line item modifier being returned.
type OrderReturnLineItemModifier struct {
	// A unique ID that identifies the return modifier only within this order.
	Uid *string `json:"uid,omitempty" url:"uid,omitempty"`
	// The modifier `uid` from the order's line item that contains the
	// original sale of this line item modifier.
	SourceModifierUid *string `json:"source_modifier_uid,omitempty" url:"source_modifier_uid,omitempty"`
	// The catalog object ID referencing [CatalogModifier](entity:CatalogModifier).
	CatalogObjectId *string `json:"catalog_object_id,omitempty" url:"catalog_object_id,omitempty"`
	// The version of the catalog object that this line item modifier references.
	CatalogVersion *int64 `json:"catalog_version,omitempty" url:"catalog_version,omitempty"`
	// The name of the item modifier.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// The base price for the modifier.
	//
	// `base_price_money` is required for ad hoc modifiers.
	// If both `catalog_object_id` and `base_price_money` are set, `base_price_money` overrides the predefined [CatalogModifier](entity:CatalogModifier) price.
	BasePriceMoney *Money `json:"base_price_money,omitempty" url:"base_price_money,omitempty"`
	// The total price of the item modifier for its line item.
	// This is the modifier's `base_price_money` multiplied by the line item's quantity.
	TotalPriceMoney *Money `json:"total_price_money,omitempty" url:"total_price_money,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (o *OrderReturnLineItemModifier) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OrderReturnLineItemModifier) UnmarshalJSON(data []byte) error {
	type unmarshaler OrderReturnLineItemModifier
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OrderReturnLineItemModifier(value)

	extraProperties, err := core.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties

	o._rawJSON = json.RawMessage(data)
	return nil
}

func (o *OrderReturnLineItemModifier) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// Represents the service charge applied to the original order.
type OrderReturnServiceCharge struct {
	// A unique ID that identifies the return service charge only within this order.
	Uid *string `json:"uid,omitempty" url:"uid,omitempty"`
	// The service charge `uid` from the order containing the original
	// service charge. `source_service_charge_uid` is `null` for
	// unlinked returns.
	SourceServiceChargeUid *string `json:"source_service_charge_uid,omitempty" url:"source_service_charge_uid,omitempty"`
	// The name of the service charge.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// The catalog object ID of the associated [OrderServiceCharge](entity:OrderServiceCharge).
	CatalogObjectId *string `json:"catalog_object_id,omitempty" url:"catalog_object_id,omitempty"`
	// The version of the catalog object that this service charge references.
	CatalogVersion *int64 `json:"catalog_version,omitempty" url:"catalog_version,omitempty"`
	// The percentage of the service charge, as a string representation of
	// a decimal number. For example, a value of `"7.25"` corresponds to a
	// percentage of 7.25%.
	//
	// Either `percentage` or `amount_money` should be set, but not both.
	Percentage *string `json:"percentage,omitempty" url:"percentage,omitempty"`
	// The amount of a non-percentage-based service charge.
	//
	// Either `percentage` or `amount_money` should be set, but not both.
	AmountMoney *Money `json:"amount_money,omitempty" url:"amount_money,omitempty"`
	// The amount of money applied to the order by the service charge, including
	// any inclusive tax amounts, as calculated by Square.
	//
	// - For fixed-amount service charges, `applied_money` is equal to `amount_money`.
	// - For percentage-based service charges, `applied_money` is the money calculated using the percentage.
	AppliedMoney *Money `json:"applied_money,omitempty" url:"applied_money,omitempty"`
	// The total amount of money to collect for the service charge.
	//
	// **NOTE**: If an inclusive tax is applied to the service charge, `total_money`
	// does not equal `applied_money` plus `total_tax_money` because the inclusive
	// tax amount is already included in both `applied_money` and `total_tax_money`.
	TotalMoney *Money `json:"total_money,omitempty" url:"total_money,omitempty"`
	// The total amount of tax money to collect for the service charge.
	TotalTaxMoney *Money `json:"total_tax_money,omitempty" url:"total_tax_money,omitempty"`
	// The calculation phase after which to apply the service charge.
	// See [OrderServiceChargeCalculationPhase](#type-orderservicechargecalculationphase) for possible values
	CalculationPhase *OrderServiceChargeCalculationPhase `json:"calculation_phase,omitempty" url:"calculation_phase,omitempty"`
	// Indicates whether the surcharge can be taxed. Service charges
	// calculated in the `TOTAL_PHASE` cannot be marked as taxable.
	Taxable *bool `json:"taxable,omitempty" url:"taxable,omitempty"`
	// The list of references to `OrderReturnTax` entities applied to the
	// `OrderReturnServiceCharge`. Each `OrderLineItemAppliedTax` has a `tax_uid`
	// that references the `uid` of a top-level `OrderReturnTax` that is being
	// applied to the `OrderReturnServiceCharge`. On reads, the applied amount is
	// populated.
	AppliedTaxes []*OrderLineItemAppliedTax `json:"applied_taxes,omitempty" url:"applied_taxes,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (o *OrderReturnServiceCharge) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OrderReturnServiceCharge) UnmarshalJSON(data []byte) error {
	type unmarshaler OrderReturnServiceCharge
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OrderReturnServiceCharge(value)

	extraProperties, err := core.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties

	o._rawJSON = json.RawMessage(data)
	return nil
}

func (o *OrderReturnServiceCharge) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// Represents a tax being returned that applies to one or more return line items in an order.
//
// Fixed-amount, order-scoped taxes are distributed across all non-zero return line item totals.
// The amount distributed to each return line item is relative to that item’s contribution to the
// order subtotal.
type OrderReturnTax struct {
	// A unique ID that identifies the returned tax only within this order.
	Uid *string `json:"uid,omitempty" url:"uid,omitempty"`
	// The tax `uid` from the order that contains the original tax charge.
	SourceTaxUid *string `json:"source_tax_uid,omitempty" url:"source_tax_uid,omitempty"`
	// The catalog object ID referencing [CatalogTax](entity:CatalogTax).
	CatalogObjectId *string `json:"catalog_object_id,omitempty" url:"catalog_object_id,omitempty"`
	// The version of the catalog object that this tax references.
	CatalogVersion *int64 `json:"catalog_version,omitempty" url:"catalog_version,omitempty"`
	// The tax's name.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// Indicates the calculation method used to apply the tax.
	// See [OrderLineItemTaxType](#type-orderlineitemtaxtype) for possible values
	Type *OrderLineItemTaxType `json:"type,omitempty" url:"type,omitempty"`
	// The percentage of the tax, as a string representation of a decimal number.
	// For example, a value of `"7.25"` corresponds to a percentage of 7.25%.
	Percentage *string `json:"percentage,omitempty" url:"percentage,omitempty"`
	// The amount of money applied by the tax in an order.
	AppliedMoney *Money `json:"applied_money,omitempty" url:"applied_money,omitempty"`
	// Indicates the level at which the `OrderReturnTax` applies. For `ORDER` scoped
	// taxes, Square generates references in `applied_taxes` on all
	// `OrderReturnLineItem`s. For `LINE_ITEM` scoped taxes, the tax is only applied to
	// `OrderReturnLineItem`s with references in their `applied_discounts` field.
	// See [OrderLineItemTaxScope](#type-orderlineitemtaxscope) for possible values
	Scope *OrderLineItemTaxScope `json:"scope,omitempty" url:"scope,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (o *OrderReturnTax) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OrderReturnTax) UnmarshalJSON(data []byte) error {
	type unmarshaler OrderReturnTax
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OrderReturnTax(value)

	extraProperties, err := core.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties

	o._rawJSON = json.RawMessage(data)
	return nil
}

func (o *OrderReturnTax) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// A rounding adjustment of the money being returned. Commonly used to apply cash rounding
// when the minimum unit of the account is smaller than the lowest physical denomination of the currency.
type OrderRoundingAdjustment struct {
	// A unique ID that identifies the rounding adjustment only within this order.
	Uid *string `json:"uid,omitempty" url:"uid,omitempty"`
	// The name of the rounding adjustment from the original sale order.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// The actual rounding adjustment amount.
	AmountMoney *Money `json:"amount_money,omitempty" url:"amount_money,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (o *OrderRoundingAdjustment) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OrderRoundingAdjustment) UnmarshalJSON(data []byte) error {
	type unmarshaler OrderRoundingAdjustment
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OrderRoundingAdjustment(value)

	extraProperties, err := core.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties

	o._rawJSON = json.RawMessage(data)
	return nil
}

func (o *OrderRoundingAdjustment) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// Represents a service charge applied to an order.
type OrderServiceCharge struct {
	// A unique ID that identifies the service charge only within this order.
	Uid *string `json:"uid,omitempty" url:"uid,omitempty"`
	// The name of the service charge.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// The catalog object ID referencing the service charge [CatalogObject](entity:CatalogObject).
	CatalogObjectId *string `json:"catalog_object_id,omitempty" url:"catalog_object_id,omitempty"`
	// The version of the catalog object that this service charge references.
	CatalogVersion *int64 `json:"catalog_version,omitempty" url:"catalog_version,omitempty"`
	// The service charge percentage as a string representation of a
	// decimal number. For example, `"7.25"` indicates a service charge of 7.25%.
	//
	// Exactly 1 of `percentage` or `amount_money` should be set.
	Percentage *string `json:"percentage,omitempty" url:"percentage,omitempty"`
	// The amount of a non-percentage-based service charge.
	//
	// Exactly one of `percentage` or `amount_money` should be set.
	AmountMoney *Money `json:"amount_money,omitempty" url:"amount_money,omitempty"`
	// The amount of money applied to the order by the service charge,
	// including any inclusive tax amounts, as calculated by Square.
	//
	//   - For fixed-amount service charges, `applied_money` is equal to `amount_money`.
	//   - For percentage-based service charges, `applied_money` is the money
	//     calculated using the percentage.
	AppliedMoney *Money `json:"applied_money,omitempty" url:"applied_money,omitempty"`
	// The total amount of money to collect for the service charge.
	//
	// **Note**: If an inclusive tax is applied to the service charge,
	// `total_money` does not equal `applied_money` plus `total_tax_money`
	// because the inclusive tax amount is already included in both
	// `applied_money` and `total_tax_money`.
	TotalMoney *Money `json:"total_money,omitempty" url:"total_money,omitempty"`
	// The total amount of tax money to collect for the service charge.
	TotalTaxMoney *Money `json:"total_tax_money,omitempty" url:"total_tax_money,omitempty"`
	// The calculation phase at which to apply the service charge.
	// See [OrderServiceChargeCalculationPhase](#type-orderservicechargecalculationphase) for possible values
	CalculationPhase *OrderServiceChargeCalculationPhase `json:"calculation_phase,omitempty" url:"calculation_phase,omitempty"`
	// Indicates whether the service charge can be taxed. If set to `true`,
	// order-level taxes automatically apply to the service charge. Note that
	// service charges calculated in the `TOTAL_PHASE` cannot be marked as taxable.
	Taxable *bool `json:"taxable,omitempty" url:"taxable,omitempty"`
	// The list of references to the taxes applied to this service charge. Each
	// `OrderLineItemAppliedTax` has a `tax_uid` that references the `uid` of a top-level
	// `OrderLineItemTax` that is being applied to this service charge. On reads, the amount applied
	// is populated.
	//
	// An `OrderLineItemAppliedTax` is automatically created on every taxable service charge
	// for all `ORDER` scoped taxes that are added to the order. `OrderLineItemAppliedTax` records
	// for `LINE_ITEM` scoped taxes must be added in requests for the tax to apply to any taxable
	// service charge. Taxable service charges have the `taxable` field set to `true` and calculated
	// in the `SUBTOTAL_PHASE`.
	//
	// To change the amount of a tax, modify the referenced top-level tax.
	AppliedTaxes []*OrderLineItemAppliedTax `json:"applied_taxes,omitempty" url:"applied_taxes,omitempty"`
	// Application-defined data attached to this service charge. Metadata fields are intended
	// to store descriptive references or associations with an entity in another system or store brief
	// information about the object. Square does not process this field; it only stores and returns it
	// in relevant API calls. Do not use metadata to store any sensitive information (such as personally
	// identifiable information or card details).
	//
	// Keys written by applications must be 60 characters or less and must be in the character set
	// `[a-zA-Z0-9_-]`. Entries can also include metadata generated by Square. These keys are prefixed
	// with a namespace, separated from the key with a ':' character.
	//
	// Values have a maximum length of 255 characters.
	//
	// An application can have up to 10 entries per metadata field.
	//
	// Entries written by applications are private and can only be read or modified by the same
	// application.
	//
	// For more information, see [Metadata](https://developer.squareup.com/docs/build-basics/metadata).
	Metadata map[string]string `json:"metadata,omitempty" url:"metadata,omitempty"`
	// The type of the service charge.
	// See [OrderServiceChargeType](#type-orderservicechargetype) for possible values
	Type *OrderServiceChargeType `json:"type,omitempty" url:"type,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (o *OrderServiceCharge) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OrderServiceCharge) UnmarshalJSON(data []byte) error {
	type unmarshaler OrderServiceCharge
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OrderServiceCharge(value)

	extraProperties, err := core.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties

	o._rawJSON = json.RawMessage(data)
	return nil
}

func (o *OrderServiceCharge) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// Represents a phase in the process of calculating order totals.
// Service charges are applied after the indicated phase.
//
// [Read more about how order totals are calculated.](https://developer.squareup.com/docs/orders-api/how-it-works#how-totals-are-calculated)
type OrderServiceChargeCalculationPhase string

const (
	OrderServiceChargeCalculationPhaseServiceChargeCalculationPhaseDoNotUse OrderServiceChargeCalculationPhase = "SERVICE_CHARGE_CALCULATION_PHASE_DO_NOT_USE"
	OrderServiceChargeCalculationPhaseSubtotalPhase                         OrderServiceChargeCalculationPhase = "SUBTOTAL_PHASE"
	OrderServiceChargeCalculationPhaseTotalPhase                            OrderServiceChargeCalculationPhase = "TOTAL_PHASE"
	OrderServiceChargeCalculationPhaseApportionedPercentagePhase            OrderServiceChargeCalculationPhase = "APPORTIONED_PERCENTAGE_PHASE"
	OrderServiceChargeCalculationPhaseApportionedAmountPhase                OrderServiceChargeCalculationPhase = "APPORTIONED_AMOUNT_PHASE"
)

func NewOrderServiceChargeCalculationPhaseFromString(s string) (OrderServiceChargeCalculationPhase, error) {
	switch s {
	case "SERVICE_CHARGE_CALCULATION_PHASE_DO_NOT_USE":
		return OrderServiceChargeCalculationPhaseServiceChargeCalculationPhaseDoNotUse, nil
	case "SUBTOTAL_PHASE":
		return OrderServiceChargeCalculationPhaseSubtotalPhase, nil
	case "TOTAL_PHASE":
		return OrderServiceChargeCalculationPhaseTotalPhase, nil
	case "APPORTIONED_PERCENTAGE_PHASE":
		return OrderServiceChargeCalculationPhaseApportionedPercentagePhase, nil
	case "APPORTIONED_AMOUNT_PHASE":
		return OrderServiceChargeCalculationPhaseApportionedAmountPhase, nil
	}
	var t OrderServiceChargeCalculationPhase
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (o OrderServiceChargeCalculationPhase) Ptr() *OrderServiceChargeCalculationPhase {
	return &o
}

type OrderServiceChargeType string

const (
	OrderServiceChargeTypeServiceChargeTypeDoNotUse OrderServiceChargeType = "SERVICE_CHARGE_TYPE_DO_NOT_USE"
	OrderServiceChargeTypeAutoGratuity              OrderServiceChargeType = "AUTO_GRATUITY"
	OrderServiceChargeTypeCustom                    OrderServiceChargeType = "CUSTOM"
)

func NewOrderServiceChargeTypeFromString(s string) (OrderServiceChargeType, error) {
	switch s {
	case "SERVICE_CHARGE_TYPE_DO_NOT_USE":
		return OrderServiceChargeTypeServiceChargeTypeDoNotUse, nil
	case "AUTO_GRATUITY":
		return OrderServiceChargeTypeAutoGratuity, nil
	case "CUSTOM":
		return OrderServiceChargeTypeCustom, nil
	}
	var t OrderServiceChargeType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (o OrderServiceChargeType) Ptr() *OrderServiceChargeType {
	return &o
}

// Represents the origination details of an order.
type OrderSource struct {
	// The name used to identify the place (physical or digital) that an order originates.
	// If unset, the name defaults to the name of the application that created the order.
	Name *string `json:"name,omitempty" url:"name,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (o *OrderSource) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OrderSource) UnmarshalJSON(data []byte) error {
	type unmarshaler OrderSource
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OrderSource(value)

	extraProperties, err := core.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties

	o._rawJSON = json.RawMessage(data)
	return nil
}

func (o *OrderSource) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// The state of the order.
type OrderState string

const (
	OrderStateDoNotUse  OrderState = "DO_NOT_USE"
	OrderStateOpen      OrderState = "OPEN"
	OrderStateCompleted OrderState = "COMPLETED"
	OrderStateCanceled  OrderState = "CANCELED"
	OrderStateDraft     OrderState = "DRAFT"
)

func NewOrderStateFromString(s string) (OrderState, error) {
	switch s {
	case "DO_NOT_USE":
		return OrderStateDoNotUse, nil
	case "OPEN":
		return OrderStateOpen, nil
	case "COMPLETED":
		return OrderStateCompleted, nil
	case "CANCELED":
		return OrderStateCanceled, nil
	case "DRAFT":
		return OrderStateDraft, nil
	}
	var t OrderState
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (o OrderState) Ptr() *OrderState {
	return &o
}

type OrderUpdated struct {
	// The order's unique ID.
	OrderId *string `json:"order_id,omitempty" url:"order_id,omitempty"`
	// The version number, which is incremented each time an update is committed to the order.
	// Orders that were not created through the API do not include a version number and
	// therefore cannot be updated.
	//
	// [Read more about working with versions.](https://developer.squareup.com/docs/orders-api/manage-orders#update-orders)
	Version *int `json:"version,omitempty" url:"version,omitempty"`
	// The ID of the seller location that this order is associated with.
	LocationId *string `json:"location_id,omitempty" url:"location_id,omitempty"`
	// The state of the order.
	// See [OrderState](#type-orderstate) for possible values
	State *OrderState `json:"state,omitempty" url:"state,omitempty"`
	// The timestamp for when the order was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The timestamp for when the order was last updated, in RFC 3339 format.
	UpdatedAt *string `json:"updated_at,omitempty" url:"updated_at,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (o *OrderUpdated) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OrderUpdated) UnmarshalJSON(data []byte) error {
	type unmarshaler OrderUpdated
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OrderUpdated(value)

	extraProperties, err := core.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties

	o._rawJSON = json.RawMessage(data)
	return nil
}

func (o *OrderUpdated) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

type OrderUpdatedObject struct {
	// Information about the updated order.
	OrderUpdated *OrderUpdated `json:"order_updated,omitempty" url:"order_updated,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (o *OrderUpdatedObject) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OrderUpdatedObject) UnmarshalJSON(data []byte) error {
	type unmarshaler OrderUpdatedObject
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OrderUpdatedObject(value)

	extraProperties, err := core.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties

	o._rawJSON = json.RawMessage(data)
	return nil
}

func (o *OrderUpdatedObject) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// Published when an [Order](entity:Order) is updated. This
// event is triggered only by the [UpdateOrder](api-endpoint:Orders-CreateOrder)
// endpoint call.
type OrderUpdatedWebhook struct {
	// The ID of the target merchant associated with the event.
	MerchantId *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The type of event this represents, `"order.updated"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// A unique ID for the webhook event.
	EventId *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// Timestamp of when the webhook event was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// Data associated with the event.
	Data *OrderUpdatedWebhookData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (o *OrderUpdatedWebhook) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OrderUpdatedWebhook) UnmarshalJSON(data []byte) error {
	type unmarshaler OrderUpdatedWebhook
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OrderUpdatedWebhook(value)

	extraProperties, err := core.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties

	o._rawJSON = json.RawMessage(data)
	return nil
}

func (o *OrderUpdatedWebhook) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

type OrderUpdatedWebhookData struct {
	// Name of the affected object’s type, `"order"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// ID of the affected order.
	Id *string `json:"id,omitempty" url:"id,omitempty"`
	// An object containing information about the updated Order.
	Object *OrderUpdatedObject `json:"object,omitempty" url:"object,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (o *OrderUpdatedWebhookData) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OrderUpdatedWebhookData) UnmarshalJSON(data []byte) error {
	type unmarshaler OrderUpdatedWebhookData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OrderUpdatedWebhookData(value)

	extraProperties, err := core.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties

	o._rawJSON = json.RawMessage(data)
	return nil
}

func (o *OrderUpdatedWebhookData) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

type PaymentBalanceActivityAutomaticSavingsDetail struct {
	// The ID of the payment associated with this activity.
	PaymentId *string `json:"payment_id,omitempty" url:"payment_id,omitempty"`
	// The ID of the payout associated with this activity.
	PayoutId *string `json:"payout_id,omitempty" url:"payout_id,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (p *PaymentBalanceActivityAutomaticSavingsDetail) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PaymentBalanceActivityAutomaticSavingsDetail) UnmarshalJSON(data []byte) error {
	type unmarshaler PaymentBalanceActivityAutomaticSavingsDetail
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PaymentBalanceActivityAutomaticSavingsDetail(value)

	extraProperties, err := core.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaymentBalanceActivityAutomaticSavingsDetail) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PaymentBalanceActivityAutomaticSavingsReversedDetail struct {
	// The ID of the payment associated with this activity.
	PaymentId *string `json:"payment_id,omitempty" url:"payment_id,omitempty"`
	// The ID of the payout associated with this activity.
	PayoutId *string `json:"payout_id,omitempty" url:"payout_id,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (p *PaymentBalanceActivityAutomaticSavingsReversedDetail) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PaymentBalanceActivityAutomaticSavingsReversedDetail) UnmarshalJSON(data []byte) error {
	type unmarshaler PaymentBalanceActivityAutomaticSavingsReversedDetail
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PaymentBalanceActivityAutomaticSavingsReversedDetail(value)

	extraProperties, err := core.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaymentBalanceActivityAutomaticSavingsReversedDetail) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// DESCRIPTION OF PaymentBalanceActivityChargeDetail
type PaymentBalanceActivityChargeDetail struct {
	// The ID of the payment associated with this activity.
	PaymentId *string `json:"payment_id,omitempty" url:"payment_id,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (p *PaymentBalanceActivityChargeDetail) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PaymentBalanceActivityChargeDetail) UnmarshalJSON(data []byte) error {
	type unmarshaler PaymentBalanceActivityChargeDetail
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PaymentBalanceActivityChargeDetail(value)

	extraProperties, err := core.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaymentBalanceActivityChargeDetail) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PaymentBalanceActivityDepositFeeDetail struct {
	// The ID of the payout that triggered this deposit fee activity.
	PayoutId *string `json:"payout_id,omitempty" url:"payout_id,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (p *PaymentBalanceActivityDepositFeeDetail) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PaymentBalanceActivityDepositFeeDetail) UnmarshalJSON(data []byte) error {
	type unmarshaler PaymentBalanceActivityDepositFeeDetail
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PaymentBalanceActivityDepositFeeDetail(value)

	extraProperties, err := core.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaymentBalanceActivityDepositFeeDetail) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PaymentBalanceActivityDisputeDetail struct {
	// The ID of the payment associated with this activity.
	PaymentId *string `json:"payment_id,omitempty" url:"payment_id,omitempty"`
	// The ID of the dispute associated with this activity.
	DisputeId *string `json:"dispute_id,omitempty" url:"dispute_id,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (p *PaymentBalanceActivityDisputeDetail) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PaymentBalanceActivityDisputeDetail) UnmarshalJSON(data []byte) error {
	type unmarshaler PaymentBalanceActivityDisputeDetail
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PaymentBalanceActivityDisputeDetail(value)

	extraProperties, err := core.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaymentBalanceActivityDisputeDetail) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PaymentBalanceActivityFeeDetail struct {
	// The ID of the payment associated with this activity.
	PaymentId *string `json:"payment_id,omitempty" url:"payment_id,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (p *PaymentBalanceActivityFeeDetail) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PaymentBalanceActivityFeeDetail) UnmarshalJSON(data []byte) error {
	type unmarshaler PaymentBalanceActivityFeeDetail
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PaymentBalanceActivityFeeDetail(value)

	extraProperties, err := core.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaymentBalanceActivityFeeDetail) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PaymentBalanceActivityFreeProcessingDetail struct {
	// The ID of the payment associated with this activity.
	PaymentId *string `json:"payment_id,omitempty" url:"payment_id,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (p *PaymentBalanceActivityFreeProcessingDetail) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PaymentBalanceActivityFreeProcessingDetail) UnmarshalJSON(data []byte) error {
	type unmarshaler PaymentBalanceActivityFreeProcessingDetail
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PaymentBalanceActivityFreeProcessingDetail(value)

	extraProperties, err := core.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaymentBalanceActivityFreeProcessingDetail) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PaymentBalanceActivityHoldAdjustmentDetail struct {
	// The ID of the payment associated with this activity.
	PaymentId *string `json:"payment_id,omitempty" url:"payment_id,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (p *PaymentBalanceActivityHoldAdjustmentDetail) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PaymentBalanceActivityHoldAdjustmentDetail) UnmarshalJSON(data []byte) error {
	type unmarshaler PaymentBalanceActivityHoldAdjustmentDetail
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PaymentBalanceActivityHoldAdjustmentDetail(value)

	extraProperties, err := core.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaymentBalanceActivityHoldAdjustmentDetail) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PaymentBalanceActivityOpenDisputeDetail struct {
	// The ID of the payment associated with this activity.
	PaymentId *string `json:"payment_id,omitempty" url:"payment_id,omitempty"`
	// The ID of the dispute associated with this activity.
	DisputeId *string `json:"dispute_id,omitempty" url:"dispute_id,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (p *PaymentBalanceActivityOpenDisputeDetail) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PaymentBalanceActivityOpenDisputeDetail) UnmarshalJSON(data []byte) error {
	type unmarshaler PaymentBalanceActivityOpenDisputeDetail
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PaymentBalanceActivityOpenDisputeDetail(value)

	extraProperties, err := core.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaymentBalanceActivityOpenDisputeDetail) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PaymentBalanceActivityOtherAdjustmentDetail struct {
	// The ID of the payment associated with this activity.
	PaymentId *string `json:"payment_id,omitempty" url:"payment_id,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (p *PaymentBalanceActivityOtherAdjustmentDetail) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PaymentBalanceActivityOtherAdjustmentDetail) UnmarshalJSON(data []byte) error {
	type unmarshaler PaymentBalanceActivityOtherAdjustmentDetail
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PaymentBalanceActivityOtherAdjustmentDetail(value)

	extraProperties, err := core.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaymentBalanceActivityOtherAdjustmentDetail) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PaymentBalanceActivityOtherDetail struct {
	// The ID of the payment associated with this activity.
	PaymentId *string `json:"payment_id,omitempty" url:"payment_id,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (p *PaymentBalanceActivityOtherDetail) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PaymentBalanceActivityOtherDetail) UnmarshalJSON(data []byte) error {
	type unmarshaler PaymentBalanceActivityOtherDetail
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PaymentBalanceActivityOtherDetail(value)

	extraProperties, err := core.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaymentBalanceActivityOtherDetail) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PaymentBalanceActivityRefundDetail struct {
	// The ID of the payment associated with this activity.
	PaymentId *string `json:"payment_id,omitempty" url:"payment_id,omitempty"`
	// The ID of the refund associated with this activity.
	RefundId *string `json:"refund_id,omitempty" url:"refund_id,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (p *PaymentBalanceActivityRefundDetail) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PaymentBalanceActivityRefundDetail) UnmarshalJSON(data []byte) error {
	type unmarshaler PaymentBalanceActivityRefundDetail
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PaymentBalanceActivityRefundDetail(value)

	extraProperties, err := core.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaymentBalanceActivityRefundDetail) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PaymentBalanceActivityReleaseAdjustmentDetail struct {
	// The ID of the payment associated with this activity.
	PaymentId *string `json:"payment_id,omitempty" url:"payment_id,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (p *PaymentBalanceActivityReleaseAdjustmentDetail) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PaymentBalanceActivityReleaseAdjustmentDetail) UnmarshalJSON(data []byte) error {
	type unmarshaler PaymentBalanceActivityReleaseAdjustmentDetail
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PaymentBalanceActivityReleaseAdjustmentDetail(value)

	extraProperties, err := core.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaymentBalanceActivityReleaseAdjustmentDetail) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PaymentBalanceActivityReserveHoldDetail struct {
	// The ID of the payment associated with this activity.
	PaymentId *string `json:"payment_id,omitempty" url:"payment_id,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (p *PaymentBalanceActivityReserveHoldDetail) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PaymentBalanceActivityReserveHoldDetail) UnmarshalJSON(data []byte) error {
	type unmarshaler PaymentBalanceActivityReserveHoldDetail
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PaymentBalanceActivityReserveHoldDetail(value)

	extraProperties, err := core.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaymentBalanceActivityReserveHoldDetail) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PaymentBalanceActivityReserveReleaseDetail struct {
	// The ID of the payment associated with this activity.
	PaymentId *string `json:"payment_id,omitempty" url:"payment_id,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (p *PaymentBalanceActivityReserveReleaseDetail) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PaymentBalanceActivityReserveReleaseDetail) UnmarshalJSON(data []byte) error {
	type unmarshaler PaymentBalanceActivityReserveReleaseDetail
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PaymentBalanceActivityReserveReleaseDetail(value)

	extraProperties, err := core.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaymentBalanceActivityReserveReleaseDetail) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PaymentBalanceActivitySquareCapitalPaymentDetail struct {
	// The ID of the payment associated with this activity.
	PaymentId *string `json:"payment_id,omitempty" url:"payment_id,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (p *PaymentBalanceActivitySquareCapitalPaymentDetail) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PaymentBalanceActivitySquareCapitalPaymentDetail) UnmarshalJSON(data []byte) error {
	type unmarshaler PaymentBalanceActivitySquareCapitalPaymentDetail
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PaymentBalanceActivitySquareCapitalPaymentDetail(value)

	extraProperties, err := core.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaymentBalanceActivitySquareCapitalPaymentDetail) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PaymentBalanceActivitySquareCapitalReversedPaymentDetail struct {
	// The ID of the payment associated with this activity.
	PaymentId *string `json:"payment_id,omitempty" url:"payment_id,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (p *PaymentBalanceActivitySquareCapitalReversedPaymentDetail) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PaymentBalanceActivitySquareCapitalReversedPaymentDetail) UnmarshalJSON(data []byte) error {
	type unmarshaler PaymentBalanceActivitySquareCapitalReversedPaymentDetail
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PaymentBalanceActivitySquareCapitalReversedPaymentDetail(value)

	extraProperties, err := core.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaymentBalanceActivitySquareCapitalReversedPaymentDetail) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PaymentBalanceActivityTaxOnFeeDetail struct {
	// The ID of the payment associated with this activity.
	PaymentId *string `json:"payment_id,omitempty" url:"payment_id,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (p *PaymentBalanceActivityTaxOnFeeDetail) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PaymentBalanceActivityTaxOnFeeDetail) UnmarshalJSON(data []byte) error {
	type unmarshaler PaymentBalanceActivityTaxOnFeeDetail
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PaymentBalanceActivityTaxOnFeeDetail(value)

	extraProperties, err := core.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaymentBalanceActivityTaxOnFeeDetail) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PaymentBalanceActivityThirdPartyFeeDetail struct {
	// The ID of the payment associated with this activity.
	PaymentId *string `json:"payment_id,omitempty" url:"payment_id,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (p *PaymentBalanceActivityThirdPartyFeeDetail) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PaymentBalanceActivityThirdPartyFeeDetail) UnmarshalJSON(data []byte) error {
	type unmarshaler PaymentBalanceActivityThirdPartyFeeDetail
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PaymentBalanceActivityThirdPartyFeeDetail(value)

	extraProperties, err := core.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaymentBalanceActivityThirdPartyFeeDetail) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PaymentBalanceActivityThirdPartyFeeRefundDetail struct {
	// The ID of the payment associated with this activity.
	PaymentId *string `json:"payment_id,omitempty" url:"payment_id,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (p *PaymentBalanceActivityThirdPartyFeeRefundDetail) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PaymentBalanceActivityThirdPartyFeeRefundDetail) UnmarshalJSON(data []byte) error {
	type unmarshaler PaymentBalanceActivityThirdPartyFeeRefundDetail
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PaymentBalanceActivityThirdPartyFeeRefundDetail(value)

	extraProperties, err := core.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaymentBalanceActivityThirdPartyFeeRefundDetail) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// Published when a [Payment](entity:Payment) is created.
type PaymentCreatedWebhook struct {
	// The ID of the target merchant associated with the event.
	MerchantId *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The type of event this represents, `"payment.created"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// A unique ID for the webhook event.
	EventId *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// Timestamp of when the webhook event was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// Data associated with the event.
	Data *PaymentCreatedWebhookData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (p *PaymentCreatedWebhook) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PaymentCreatedWebhook) UnmarshalJSON(data []byte) error {
	type unmarshaler PaymentCreatedWebhook
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PaymentCreatedWebhook(value)

	extraProperties, err := core.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaymentCreatedWebhook) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PaymentCreatedWebhookData struct {
	// Name of the affected object’s type, `"payment"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// ID of the affected payment.
	Id *string `json:"id,omitempty" url:"id,omitempty"`
	// An object containing the created payment.
	Object *PaymentCreatedWebhookObject `json:"object,omitempty" url:"object,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (p *PaymentCreatedWebhookData) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PaymentCreatedWebhookData) UnmarshalJSON(data []byte) error {
	type unmarshaler PaymentCreatedWebhookData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PaymentCreatedWebhookData(value)

	extraProperties, err := core.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaymentCreatedWebhookData) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PaymentCreatedWebhookObject struct {
	// The created payment.
	Payment *Payment `json:"payment,omitempty" url:"payment,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (p *PaymentCreatedWebhookObject) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PaymentCreatedWebhookObject) UnmarshalJSON(data []byte) error {
	type unmarshaler PaymentCreatedWebhookObject
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PaymentCreatedWebhookObject(value)

	extraProperties, err := core.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaymentCreatedWebhookObject) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PaymentLink struct {
	// The Square-assigned ID of the payment link.
	Id *string `json:"id,omitempty" url:"id,omitempty"`
	// The Square-assigned version number, which is incremented each time an update is committed to the payment link.
	Version int `json:"version" url:"version"`
	// The optional description of the `payment_link` object.
	// It is primarily for use by your application and is not used anywhere.
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	// The ID of the order associated with the payment link.
	OrderId *string `json:"order_id,omitempty" url:"order_id,omitempty"`
	// The checkout options configured for the payment link.
	// For more information, see [Optional Checkout Configurations](https://developer.squareup.com/docs/checkout-api/optional-checkout-configurations).
	CheckoutOptions *CheckoutOptions `json:"checkout_options,omitempty" url:"checkout_options,omitempty"`
	// Describes buyer data to prepopulate
	// on the checkout page.
	PrePopulatedData *PrePopulatedData `json:"pre_populated_data,omitempty" url:"pre_populated_data,omitempty"`
	// The URL of the payment link.
	Url *string `json:"url,omitempty" url:"url,omitempty"`
	// The timestamp when the payment link was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The timestamp when the payment link was last updated, in RFC 3339 format.
	UpdatedAt *string `json:"updated_at,omitempty" url:"updated_at,omitempty"`
	// An optional note. After Square processes the payment, this note is added to the
	// resulting `Payment`.
	PaymentNote *string `json:"payment_note,omitempty" url:"payment_note,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (p *PaymentLink) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PaymentLink) UnmarshalJSON(data []byte) error {
	type unmarshaler PaymentLink
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PaymentLink(value)

	extraProperties, err := core.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaymentLink) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PaymentLinkRelatedResources struct {
	// The order associated with the payment link.
	Orders []*Order `json:"orders,omitempty" url:"orders,omitempty"`
	// The subscription plan associated with the payment link.
	SubscriptionPlans []*CatalogObject `json:"subscription_plans,omitempty" url:"subscription_plans,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (p *PaymentLinkRelatedResources) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PaymentLinkRelatedResources) UnmarshalJSON(data []byte) error {
	type unmarshaler PaymentLinkRelatedResources
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PaymentLinkRelatedResources(value)

	extraProperties, err := core.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaymentLinkRelatedResources) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PaymentOptions struct {
	// Indicates whether the `Payment` objects created from this `TerminalCheckout` are automatically
	// `COMPLETED` or left in an `APPROVED` state for later modification.
	Autocomplete *bool `json:"autocomplete,omitempty" url:"autocomplete,omitempty"`
	// The duration of time after the payment's creation when Square automatically cancels the
	// payment. This automatic cancellation applies only to payments that do not reach a terminal state
	// (COMPLETED, CANCELED, or FAILED) before the `delay_duration` time period.
	//
	// This parameter should be specified as a time duration, in RFC 3339 format, with a minimum value
	// of 1 minute.
	//
	// Note: This feature is only supported for card payments. This parameter can only be set for a delayed
	// capture payment (`autocomplete=false`).
	// Default:
	//
	// - Card-present payments: "PT36H" (36 hours) from the creation time.
	// - Card-not-present payments: "P7D" (7 days) from the creation time.
	DelayDuration *string `json:"delay_duration,omitempty" url:"delay_duration,omitempty"`
	// If set to `true` and charging a Square Gift Card, a payment might be returned with
	// `amount_money` equal to less than what was requested. For example, a request for $20 when charging
	// a Square Gift Card with a balance of $5 results in an APPROVED payment of $5. You might choose
	// to prompt the buyer for an additional payment to cover the remainder or cancel the Gift Card
	// payment.
	//
	// This field cannot be `true` when `autocomplete = true`.
	// This field cannot be `true` when an `order_id` isn't specified.
	//
	// For more information, see
	// [Take Partial Payments](https://developer.squareup.com/docs/payments-api/take-payments/card-payments/partial-payments-with-gift-cards).
	//
	// Default: false
	AcceptPartialAuthorization *bool `json:"accept_partial_authorization,omitempty" url:"accept_partial_authorization,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (p *PaymentOptions) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PaymentOptions) UnmarshalJSON(data []byte) error {
	type unmarshaler PaymentOptions
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PaymentOptions(value)

	extraProperties, err := core.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaymentOptions) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// Represents a refund of a payment made using Square. Contains information about
// the original payment and the amount of money refunded.
type PaymentRefund struct {
	// The unique ID for this refund, generated by Square.
	Id string `json:"id" url:"id"`
	// The refund's status:
	//
	// - `PENDING` - Awaiting approval.
	// - `COMPLETED` - Successfully completed.
	// - `REJECTED` - The refund was rejected.
	// - `FAILED` - An error occurred.
	Status *string `json:"status,omitempty" url:"status,omitempty"`
	// The location ID associated with the payment this refund is attached to.
	LocationId *string `json:"location_id,omitempty" url:"location_id,omitempty"`
	// The amount of money refunded. This amount is specified in the smallest denomination
	// of the applicable currency (for example, US dollar amounts are specified in cents).
	AmountMoney *Money `json:"amount_money,omitempty" url:"amount_money,omitempty"`
	// The amount of money the application developer contributed to help cover the refunded amount.
	// This amount is specified in the smallest denomination of the applicable currency (for example,
	// US dollar amounts are specified in cents). For more information, see
	// [Working with Monetary Amounts](https://developer.squareup.com/docs/build-basics/working-with-monetary-amounts).
	AppFeeMoney *Money `json:"app_fee_money,omitempty" url:"app_fee_money,omitempty"`
	// Processing fees and fee adjustments assessed by Square for this refund.
	ProcessingFee []*ProcessingFee `json:"processing_fee,omitempty" url:"processing_fee,omitempty"`
	// The ID of the payment associated with this refund.
	PaymentId *string `json:"payment_id,omitempty" url:"payment_id,omitempty"`
	// The ID of the order associated with the refund.
	OrderId *string `json:"order_id,omitempty" url:"order_id,omitempty"`
	// The reason for the refund.
	Reason *string `json:"reason,omitempty" url:"reason,omitempty"`
	// The timestamp of when the refund was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The timestamp of when the refund was last updated, in RFC 3339 format.
	UpdatedAt *string `json:"updated_at,omitempty" url:"updated_at,omitempty"`
	// An optional ID of the team member associated with taking the payment.
	TeamMemberId *string `json:"team_member_id,omitempty" url:"team_member_id,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (p *PaymentRefund) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PaymentRefund) UnmarshalJSON(data []byte) error {
	type unmarshaler PaymentRefund
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PaymentRefund(value)

	extraProperties, err := core.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaymentRefund) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// Published when a [Payment](entity:Payment) is updated.
// Typically the `payment.status`, or `card_details.status` fields are updated
// as a payment is canceled, authorized, or completed.
type PaymentUpdatedWebhook struct {
	// The ID of the target merchant associated with the event.
	MerchantId *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The type of event this represents, `"payment.updated"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// A unique ID for the webhook event.
	EventId *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// Timestamp of when the webhook event was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// Data associated with the event.
	Data *PaymentUpdatedWebhookData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (p *PaymentUpdatedWebhook) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PaymentUpdatedWebhook) UnmarshalJSON(data []byte) error {
	type unmarshaler PaymentUpdatedWebhook
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PaymentUpdatedWebhook(value)

	extraProperties, err := core.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaymentUpdatedWebhook) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PaymentUpdatedWebhookData struct {
	// Name of the affected object’s type, `"payment"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// ID of the affected payment.
	Id *string `json:"id,omitempty" url:"id,omitempty"`
	// An object containing the updated payment.
	Object *PaymentUpdatedWebhookObject `json:"object,omitempty" url:"object,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (p *PaymentUpdatedWebhookData) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PaymentUpdatedWebhookData) UnmarshalJSON(data []byte) error {
	type unmarshaler PaymentUpdatedWebhookData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PaymentUpdatedWebhookData(value)

	extraProperties, err := core.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaymentUpdatedWebhookData) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PaymentUpdatedWebhookObject struct {
	// The updated payment.
	Payment *Payment `json:"payment,omitempty" url:"payment,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (p *PaymentUpdatedWebhookObject) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PaymentUpdatedWebhookObject) UnmarshalJSON(data []byte) error {
	type unmarshaler PaymentUpdatedWebhookObject
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PaymentUpdatedWebhookObject(value)

	extraProperties, err := core.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaymentUpdatedWebhookObject) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// An accounting of the amount owed the seller and record of the actual transfer to their
// external bank account or to the Square balance.
type Payout struct {
	// A unique ID for the payout.
	Id string `json:"id" url:"id"`
	// Indicates the payout status.
	// See [PayoutStatus](#type-payoutstatus) for possible values
	Status *PayoutStatus `json:"status,omitempty" url:"status,omitempty"`
	// The ID of the location associated with the payout.
	LocationId string `json:"location_id" url:"location_id"`
	// The timestamp of when the payout was created and submitted for deposit to the seller's banking destination, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The timestamp of when the payout was last updated, in RFC 3339 format.
	UpdatedAt *string `json:"updated_at,omitempty" url:"updated_at,omitempty"`
	// The amount of money involved in the payout. A positive amount indicates a deposit, and a negative amount indicates a withdrawal. This amount is never zero.
	AmountMoney *Money `json:"amount_money,omitempty" url:"amount_money,omitempty"`
	// Information about the banking destination (such as a bank account, Square checking account, or debit card)
	// against which the payout was made.
	Destination *Destination `json:"destination,omitempty" url:"destination,omitempty"`
	// The version number, which is incremented each time an update is made to this payout record.
	// The version number helps developers receive event notifications or feeds out of order.
	Version *int `json:"version,omitempty" url:"version,omitempty"`
	// Indicates the payout type.
	// See [PayoutType](#type-payouttype) for possible values
	Type *PayoutType `json:"type,omitempty" url:"type,omitempty"`
	// A list of transfer fees and any taxes on the fees assessed by Square for this payout.
	PayoutFee []*PayoutFee `json:"payout_fee,omitempty" url:"payout_fee,omitempty"`
	// The calendar date, in ISO 8601 format (YYYY-MM-DD), when the payout is due to arrive in the seller’s banking destination.
	ArrivalDate *string `json:"arrival_date,omitempty" url:"arrival_date,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (p *Payout) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *Payout) UnmarshalJSON(data []byte) error {
	type unmarshaler Payout
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = Payout(value)

	extraProperties, err := core.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *Payout) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// One or more PayoutEntries that make up a Payout. Each one has a date, amount, and type of activity.
// The total amount of the payout will equal the sum of the payout entries for a batch payout
type PayoutEntry struct {
	// A unique ID for the payout entry.
	Id string `json:"id" url:"id"`
	// The ID of the payout entries’ associated payout.
	PayoutId string `json:"payout_id" url:"payout_id"`
	// The timestamp of when the payout entry affected the balance, in RFC 3339 format.
	EffectiveAt *string `json:"effective_at,omitempty" url:"effective_at,omitempty"`
	// The type of activity associated with this payout entry.
	// See [ActivityType](#type-activitytype) for possible values
	Type *ActivityType `json:"type,omitempty" url:"type,omitempty"`
	// The amount of money involved in this payout entry.
	GrossAmountMoney *Money `json:"gross_amount_money,omitempty" url:"gross_amount_money,omitempty"`
	// The amount of Square fees associated with this payout entry.
	FeeAmountMoney *Money `json:"fee_amount_money,omitempty" url:"fee_amount_money,omitempty"`
	// The net proceeds from this transaction after any fees.
	NetAmountMoney *Money `json:"net_amount_money,omitempty" url:"net_amount_money,omitempty"`
	// Details of any automatic transfer from the payment processing balance to the Square Savings account. These are, generally, proportional to the merchant's sales.
	TypeAutomaticSavingsDetails *PaymentBalanceActivityAutomaticSavingsDetail `json:"type_automatic_savings_details,omitempty" url:"type_automatic_savings_details,omitempty"`
	// Details of any automatic transfer from the Square Savings account back to the processing balance. These are, generally, proportional to the merchant's refunds.
	TypeAutomaticSavingsReversedDetails *PaymentBalanceActivityAutomaticSavingsReversedDetail `json:"type_automatic_savings_reversed_details,omitempty" url:"type_automatic_savings_reversed_details,omitempty"`
	// Details of credit card payment captures.
	TypeChargeDetails *PaymentBalanceActivityChargeDetail `json:"type_charge_details,omitempty" url:"type_charge_details,omitempty"`
	// Details of any fees involved with deposits such as for instant deposits.
	TypeDepositFeeDetails *PaymentBalanceActivityDepositFeeDetail `json:"type_deposit_fee_details,omitempty" url:"type_deposit_fee_details,omitempty"`
	// Details of any balance change due to a dispute event.
	TypeDisputeDetails *PaymentBalanceActivityDisputeDetail `json:"type_dispute_details,omitempty" url:"type_dispute_details,omitempty"`
	// Details of adjustments due to the Square processing fee.
	TypeFeeDetails *PaymentBalanceActivityFeeDetail `json:"type_fee_details,omitempty" url:"type_fee_details,omitempty"`
	// Square offers Free Payments Processing for a variety of business scenarios including seller referral or when Square wants to apologize for a bug, customer service, repricing complication, and so on. This entry represents details of any credit to the merchant for the purposes of Free Processing.
	TypeFreeProcessingDetails *PaymentBalanceActivityFreeProcessingDetail `json:"type_free_processing_details,omitempty" url:"type_free_processing_details,omitempty"`
	// Details of any adjustment made by Square related to the holding or releasing of a payment.
	TypeHoldAdjustmentDetails *PaymentBalanceActivityHoldAdjustmentDetail `json:"type_hold_adjustment_details,omitempty" url:"type_hold_adjustment_details,omitempty"`
	// Details of any open disputes.
	TypeOpenDisputeDetails *PaymentBalanceActivityOpenDisputeDetail `json:"type_open_dispute_details,omitempty" url:"type_open_dispute_details,omitempty"`
	// Details of any other type that does not belong in the rest of the types.
	TypeOtherDetails *PaymentBalanceActivityOtherDetail `json:"type_other_details,omitempty" url:"type_other_details,omitempty"`
	// Details of any other type of adjustments that don't fall under existing types.
	TypeOtherAdjustmentDetails *PaymentBalanceActivityOtherAdjustmentDetail `json:"type_other_adjustment_details,omitempty" url:"type_other_adjustment_details,omitempty"`
	// Details of a refund for an existing card payment.
	TypeRefundDetails *PaymentBalanceActivityRefundDetail `json:"type_refund_details,omitempty" url:"type_refund_details,omitempty"`
	// Details of fees released for adjustments.
	TypeReleaseAdjustmentDetails *PaymentBalanceActivityReleaseAdjustmentDetail `json:"type_release_adjustment_details,omitempty" url:"type_release_adjustment_details,omitempty"`
	// Details of fees paid for funding risk reserve.
	TypeReserveHoldDetails *PaymentBalanceActivityReserveHoldDetail `json:"type_reserve_hold_details,omitempty" url:"type_reserve_hold_details,omitempty"`
	// Details of fees released from risk reserve.
	TypeReserveReleaseDetails *PaymentBalanceActivityReserveReleaseDetail `json:"type_reserve_release_details,omitempty" url:"type_reserve_release_details,omitempty"`
	// Details of capital merchant cash advance (MCA) assessments. These are, generally, proportional to the merchant's sales but may be issued for other reasons related to the MCA.
	TypeSquareCapitalPaymentDetails *PaymentBalanceActivitySquareCapitalPaymentDetail `json:"type_square_capital_payment_details,omitempty" url:"type_square_capital_payment_details,omitempty"`
	// Details of capital merchant cash advance (MCA) assessment refunds. These are, generally, proportional to the merchant's refunds but may be issued for other reasons related to the MCA.
	TypeSquareCapitalReversedPaymentDetails *PaymentBalanceActivitySquareCapitalReversedPaymentDetail `json:"type_square_capital_reversed_payment_details,omitempty" url:"type_square_capital_reversed_payment_details,omitempty"`
	// Details of tax paid on fee amounts.
	TypeTaxOnFeeDetails *PaymentBalanceActivityTaxOnFeeDetail `json:"type_tax_on_fee_details,omitempty" url:"type_tax_on_fee_details,omitempty"`
	// Details of fees collected by a 3rd party platform.
	TypeThirdPartyFeeDetails *PaymentBalanceActivityThirdPartyFeeDetail `json:"type_third_party_fee_details,omitempty" url:"type_third_party_fee_details,omitempty"`
	// Details of refunded fees from a 3rd party platform.
	TypeThirdPartyFeeRefundDetails *PaymentBalanceActivityThirdPartyFeeRefundDetail `json:"type_third_party_fee_refund_details,omitempty" url:"type_third_party_fee_refund_details,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (p *PayoutEntry) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PayoutEntry) UnmarshalJSON(data []byte) error {
	type unmarshaler PayoutEntry
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PayoutEntry(value)

	extraProperties, err := core.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PayoutEntry) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// Published when a [Payout](entity:Payout) has failed.
type PayoutFailedWebhook struct {
	// The ID of the target merchant associated with the event.
	MerchantId *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The ID of the target location associated with the event.
	LocationId *string `json:"location_id,omitempty" url:"location_id,omitempty"`
	// The type of event that this represents, `payout.failed`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// A unique ID for the webhook event.
	EventId *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// The timestamp of when the webhook event was verified, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// Data associated with the event.
	Data *PayoutFailedWebhookData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (p *PayoutFailedWebhook) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PayoutFailedWebhook) UnmarshalJSON(data []byte) error {
	type unmarshaler PayoutFailedWebhook
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PayoutFailedWebhook(value)

	extraProperties, err := core.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PayoutFailedWebhook) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PayoutFailedWebhookData struct {
	// The name of the affected object's type, `payout`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// The ID of the failed payout.
	Id *string `json:"id,omitempty" url:"id,omitempty"`
	// An object containing the failed payout.
	Object *PayoutFailedWebhookObject `json:"object,omitempty" url:"object,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (p *PayoutFailedWebhookData) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PayoutFailedWebhookData) UnmarshalJSON(data []byte) error {
	type unmarshaler PayoutFailedWebhookData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PayoutFailedWebhookData(value)

	extraProperties, err := core.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PayoutFailedWebhookData) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PayoutFailedWebhookObject struct {
	// The payout that failed.
	Payout *Payout `json:"payout,omitempty" url:"payout,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (p *PayoutFailedWebhookObject) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PayoutFailedWebhookObject) UnmarshalJSON(data []byte) error {
	type unmarshaler PayoutFailedWebhookObject
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PayoutFailedWebhookObject(value)

	extraProperties, err := core.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PayoutFailedWebhookObject) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// Represents a payout fee that can incur as part of a payout.
type PayoutFee struct {
	// The money amount of the payout fee.
	AmountMoney *Money `json:"amount_money,omitempty" url:"amount_money,omitempty"`
	// The timestamp of when the fee takes effect, in RFC 3339 format.
	EffectiveAt *string `json:"effective_at,omitempty" url:"effective_at,omitempty"`
	// The type of fee assessed as part of the payout.
	// See [PayoutFeeType](#type-payoutfeetype) for possible values
	Type *PayoutFeeType `json:"type,omitempty" url:"type,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (p *PayoutFee) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PayoutFee) UnmarshalJSON(data []byte) error {
	type unmarshaler PayoutFee
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PayoutFee(value)

	extraProperties, err := core.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PayoutFee) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// Represents the type of payout fee that can incur as part of a payout.
type PayoutFeeType string

const (
	PayoutFeeTypeUnknownPayoutFeeTypeDoNotUse PayoutFeeType = "UNKNOWN_PAYOUT_FEE_TYPE_DO_NOT_USE"
	PayoutFeeTypeTransferFee                  PayoutFeeType = "TRANSFER_FEE"
	PayoutFeeTypeTaxOnTransferFee             PayoutFeeType = "TAX_ON_TRANSFER_FEE"
)

func NewPayoutFeeTypeFromString(s string) (PayoutFeeType, error) {
	switch s {
	case "UNKNOWN_PAYOUT_FEE_TYPE_DO_NOT_USE":
		return PayoutFeeTypeUnknownPayoutFeeTypeDoNotUse, nil
	case "TRANSFER_FEE":
		return PayoutFeeTypeTransferFee, nil
	case "TAX_ON_TRANSFER_FEE":
		return PayoutFeeTypeTaxOnTransferFee, nil
	}
	var t PayoutFeeType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (p PayoutFeeType) Ptr() *PayoutFeeType {
	return &p
}

// Published when a [Payout](entity:Payout) is complete.
type PayoutPaidWebhook struct {
	// The ID of the target merchant associated with the event.
	MerchantId *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The ID of the target location associated with the event.
	LocationId *string `json:"location_id,omitempty" url:"location_id,omitempty"`
	// The type of event this represents, `"payout.paid"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// A unique ID for the webhook event.
	EventId *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// Timestamp of when the webhook event was verified, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// Data associated with the event.
	Data *PayoutPaidWebhookData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (p *PayoutPaidWebhook) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PayoutPaidWebhook) UnmarshalJSON(data []byte) error {
	type unmarshaler PayoutPaidWebhook
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PayoutPaidWebhook(value)

	extraProperties, err := core.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PayoutPaidWebhook) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PayoutPaidWebhookData struct {
	// Name of the affected object’s type, `"payout"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// ID of the completed payout.
	Id *string `json:"id,omitempty" url:"id,omitempty"`
	// An object containing the completed payout.
	Object *PayoutPaidWebhookObject `json:"object,omitempty" url:"object,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (p *PayoutPaidWebhookData) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PayoutPaidWebhookData) UnmarshalJSON(data []byte) error {
	type unmarshaler PayoutPaidWebhookData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PayoutPaidWebhookData(value)

	extraProperties, err := core.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PayoutPaidWebhookData) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PayoutPaidWebhookObject struct {
	// The payout that has completed.
	Payout *Payout `json:"payout,omitempty" url:"payout,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (p *PayoutPaidWebhookObject) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PayoutPaidWebhookObject) UnmarshalJSON(data []byte) error {
	type unmarshaler PayoutPaidWebhookObject
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PayoutPaidWebhookObject(value)

	extraProperties, err := core.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PayoutPaidWebhookObject) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// Published when a [Payout](entity:Payout) is sent.
type PayoutSentWebhook struct {
	// The ID of the target merchant associated with the event.
	MerchantId *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The ID of the target location associated with the event.
	LocationId *string `json:"location_id,omitempty" url:"location_id,omitempty"`
	// The type of event this represents, `"payout.sent"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// A unique ID for the webhook event.
	EventId *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// Timestamp of when the webhook event was verified, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// Data associated with the event.
	Data *PayoutSentWebhookData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (p *PayoutSentWebhook) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PayoutSentWebhook) UnmarshalJSON(data []byte) error {
	type unmarshaler PayoutSentWebhook
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PayoutSentWebhook(value)

	extraProperties, err := core.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PayoutSentWebhook) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PayoutSentWebhookData struct {
	// Name of the affected object’s type, `"payout"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// ID of the sent payout.
	Id *string `json:"id,omitempty" url:"id,omitempty"`
	// An object containing the sent payout.
	Object *PayoutSentWebhookObject `json:"object,omitempty" url:"object,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (p *PayoutSentWebhookData) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PayoutSentWebhookData) UnmarshalJSON(data []byte) error {
	type unmarshaler PayoutSentWebhookData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PayoutSentWebhookData(value)

	extraProperties, err := core.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PayoutSentWebhookData) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PayoutSentWebhookObject struct {
	// The payout that was sent.
	Payout *Payout `json:"payout,omitempty" url:"payout,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (p *PayoutSentWebhookObject) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PayoutSentWebhookObject) UnmarshalJSON(data []byte) error {
	type unmarshaler PayoutSentWebhookObject
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PayoutSentWebhookObject(value)

	extraProperties, err := core.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PayoutSentWebhookObject) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// The type of payout: “BATCH” or “SIMPLE”.
// BATCH payouts include a list of payout entries that can be considered settled.
// SIMPLE payouts do not have any payout entries associated with them
// and will show up as one of the payout entries in a future BATCH payout.
type PayoutType string

const (
	PayoutTypeUnknownPayoutTypeDoNotUse PayoutType = "UNKNOWN_PAYOUT_TYPE_DO_NOT_USE"
	PayoutTypeBatch                     PayoutType = "BATCH"
	PayoutTypeSimple                    PayoutType = "SIMPLE"
)

func NewPayoutTypeFromString(s string) (PayoutType, error) {
	switch s {
	case "UNKNOWN_PAYOUT_TYPE_DO_NOT_USE":
		return PayoutTypeUnknownPayoutTypeDoNotUse, nil
	case "BATCH":
		return PayoutTypeBatch, nil
	case "SIMPLE":
		return PayoutTypeSimple, nil
	}
	var t PayoutType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (p PayoutType) Ptr() *PayoutType {
	return &p
}

// Describes buyer data to prepopulate in the payment form.
// For more information,
// see [Optional Checkout Configurations](https://developer.squareup.com/docs/checkout-api/optional-checkout-configurations).
type PrePopulatedData struct {
	// The buyer email to prepopulate in the payment form.
	BuyerEmail *string `json:"buyer_email,omitempty" url:"buyer_email,omitempty"`
	// The buyer phone number to prepopulate in the payment form.
	BuyerPhoneNumber *string `json:"buyer_phone_number,omitempty" url:"buyer_phone_number,omitempty"`
	// The buyer address to prepopulate in the payment form.
	BuyerAddress *Address `json:"buyer_address,omitempty" url:"buyer_address,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (p *PrePopulatedData) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PrePopulatedData) UnmarshalJSON(data []byte) error {
	type unmarshaler PrePopulatedData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PrePopulatedData(value)

	extraProperties, err := core.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PrePopulatedData) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// Represents the Square processing fee.
type ProcessingFee struct {
	// The timestamp of when the fee takes effect, in RFC 3339 format.
	EffectiveAt *string `json:"effective_at,omitempty" url:"effective_at,omitempty"`
	// The type of fee assessed or adjusted. The fee type can be `INITIAL` or `ADJUSTMENT`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// The fee amount, which might be negative, that is assessed or adjusted by Square.
	//
	// Positive values represent funds being assessed, while negative values represent
	// funds being returned.
	AmountMoney *Money `json:"amount_money,omitempty" url:"amount_money,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (p *ProcessingFee) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *ProcessingFee) UnmarshalJSON(data []byte) error {
	type unmarshaler ProcessingFee
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = ProcessingFee(value)

	extraProperties, err := core.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *ProcessingFee) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// Indicates the Square product used to generate a change.
type Product string

const (
	ProductProductDoNotUse    Product = "PRODUCT_DO_NOT_USE"
	ProductSquarePos          Product = "SQUARE_POS"
	ProductExternalApi        Product = "EXTERNAL_API"
	ProductBilling            Product = "BILLING"
	ProductAppointments       Product = "APPOINTMENTS"
	ProductInvoices           Product = "INVOICES"
	ProductOnlineStore        Product = "ONLINE_STORE"
	ProductPayroll            Product = "PAYROLL"
	ProductDashboard          Product = "DASHBOARD"
	ProductItemLibraryImport  Product = "ITEM_LIBRARY_IMPORT"
	ProductRetail             Product = "RETAIL"
	ProductRestaurant         Product = "RESTAURANT"
	ProductCustomersDirectory Product = "CUSTOMERS_DIRECTORY"
	ProductOther              Product = "OTHER"
)

func NewProductFromString(s string) (Product, error) {
	switch s {
	case "PRODUCT_DO_NOT_USE":
		return ProductProductDoNotUse, nil
	case "SQUARE_POS":
		return ProductSquarePos, nil
	case "EXTERNAL_API":
		return ProductExternalApi, nil
	case "BILLING":
		return ProductBilling, nil
	case "APPOINTMENTS":
		return ProductAppointments, nil
	case "INVOICES":
		return ProductInvoices, nil
	case "ONLINE_STORE":
		return ProductOnlineStore, nil
	case "PAYROLL":
		return ProductPayroll, nil
	case "DASHBOARD":
		return ProductDashboard, nil
	case "ITEM_LIBRARY_IMPORT":
		return ProductItemLibraryImport, nil
	case "RETAIL":
		return ProductRetail, nil
	case "RESTAURANT":
		return ProductRestaurant, nil
	case "CUSTOMERS_DIRECTORY":
		return ProductCustomersDirectory, nil
	case "OTHER":
		return ProductOther, nil
	}
	var t Product
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (p Product) Ptr() *Product {
	return &p
}

type ProductType string

const (
	ProductTypeUnknown     ProductType = "UNKNOWN"
	ProductTypeRegister    ProductType = "REGISTER"
	ProductTypeRestaurant  ProductType = "RESTAURANT"
	ProductTypeRetail      ProductType = "RETAIL"
	ProductTypePaySdk      ProductType = "PAY_SDK"
	ProductTypeTerminalApi ProductType = "TERMINAL_API"
	ProductTypeKds         ProductType = "KDS"
)

func NewProductTypeFromString(s string) (ProductType, error) {
	switch s {
	case "UNKNOWN":
		return ProductTypeUnknown, nil
	case "REGISTER":
		return ProductTypeRegister, nil
	case "RESTAURANT":
		return ProductTypeRestaurant, nil
	case "RETAIL":
		return ProductTypeRetail, nil
	case "PAY_SDK":
		return ProductTypePaySdk, nil
	case "TERMINAL_API":
		return ProductTypeTerminalApi, nil
	case "KDS":
		return ProductTypeKds, nil
	}
	var t ProductType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (p ProductType) Ptr() *ProductType {
	return &p
}

// A whole number or unreduced fractional ratio.
type QuantityRatio struct {
	// The whole or fractional quantity as the numerator.
	Quantity *int `json:"quantity,omitempty" url:"quantity,omitempty"`
	// The whole or fractional quantity as the denominator.
	// In the case of fractional quantity this field is the denominator and quantity is the numerator.
	// When unspecified, the value is `1`. For example, when `quantity=3` and `quantity_donominator` is unspecified,
	// the quantity ratio is `3` or `3/1`.
	QuantityDenominator *int `json:"quantity_denominator,omitempty" url:"quantity_denominator,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (q *QuantityRatio) GetExtraProperties() map[string]interface{} {
	return q.extraProperties
}

func (q *QuantityRatio) UnmarshalJSON(data []byte) error {
	type unmarshaler QuantityRatio
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*q = QuantityRatio(value)

	extraProperties, err := core.ExtractExtraProperties(data, *q)
	if err != nil {
		return err
	}
	q.extraProperties = extraProperties

	q._rawJSON = json.RawMessage(data)
	return nil
}

func (q *QuantityRatio) String() string {
	if len(q._rawJSON) > 0 {
		if value, err := core.StringifyJSON(q._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(q); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", q)
}

// Describes an ad hoc item and price to generate a quick pay checkout link.
// For more information,
// see [Quick Pay Checkout](https://developer.squareup.com/docs/checkout-api/quick-pay-checkout).
type QuickPay struct {
	// The ad hoc item name. In the resulting `Order`, this name appears as the line item name.
	Name string `json:"name" url:"name"`
	// The price of the item.
	PriceMoney *Money `json:"price_money,omitempty" url:"price_money,omitempty"`
	// The ID of the business location the checkout is associated with.
	LocationId string `json:"location_id" url:"location_id"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (q *QuickPay) GetExtraProperties() map[string]interface{} {
	return q.extraProperties
}

func (q *QuickPay) UnmarshalJSON(data []byte) error {
	type unmarshaler QuickPay
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*q = QuickPay(value)

	extraProperties, err := core.ExtractExtraProperties(data, *q)
	if err != nil {
		return err
	}
	q.extraProperties = extraProperties

	q._rawJSON = json.RawMessage(data)
	return nil
}

func (q *QuickPay) String() string {
	if len(q._rawJSON) > 0 {
		if value, err := core.StringifyJSON(q._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(q); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", q)
}

// The range of a number value between the specified lower and upper bounds.
type Range struct {
	// The lower bound of the number range. At least one of `min` or `max` must be specified.
	// If unspecified, the results will have no minimum value.
	Min *string `json:"min,omitempty" url:"min,omitempty"`
	// The upper bound of the number range. At least one of `min` or `max` must be specified.
	// If unspecified, the results will have no maximum value.
	Max *string `json:"max,omitempty" url:"max,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (r *Range) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *Range) UnmarshalJSON(data []byte) error {
	type unmarshaler Range
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = Range(value)

	extraProperties, err := core.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties

	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *Range) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

// A response that includes the `LoyaltyEvent` published for redeeming the reward.
type RedeemLoyaltyRewardResponse struct {
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The `LoyaltyEvent` for redeeming the reward.
	Event *LoyaltyEvent `json:"event,omitempty" url:"event,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (r *RedeemLoyaltyRewardResponse) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RedeemLoyaltyRewardResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler RedeemLoyaltyRewardResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RedeemLoyaltyRewardResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties

	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *RedeemLoyaltyRewardResponse) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

// Represents a refund processed for a Square transaction.
type Refund struct {
	// The refund's unique ID.
	Id string `json:"id" url:"id"`
	// The ID of the refund's associated location.
	LocationId string `json:"location_id" url:"location_id"`
	// The ID of the transaction that the refunded tender is part of.
	TransactionId *string `json:"transaction_id,omitempty" url:"transaction_id,omitempty"`
	// The ID of the refunded tender.
	TenderId string `json:"tender_id" url:"tender_id"`
	// The timestamp for when the refund was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The reason for the refund being issued.
	Reason string `json:"reason" url:"reason"`
	// The amount of money refunded to the buyer.
	AmountMoney *Money `json:"amount_money,omitempty" url:"amount_money,omitempty"`
	// The current status of the refund (`PENDING`, `APPROVED`, `REJECTED`,
	// or `FAILED`).
	// See [RefundStatus](#type-refundstatus) for possible values
	Status RefundStatus `json:"status" url:"status"`
	// The amount of Square processing fee money refunded to the _merchant_.
	ProcessingFeeMoney *Money `json:"processing_fee_money,omitempty" url:"processing_fee_money,omitempty"`
	// Additional recipients (other than the merchant) receiving a portion of this refund.
	// For example, fees assessed on a refund of a purchase by a third party integration.
	AdditionalRecipients []*AdditionalRecipient `json:"additional_recipients,omitempty" url:"additional_recipients,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (r *Refund) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *Refund) UnmarshalJSON(data []byte) error {
	type unmarshaler Refund
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = Refund(value)

	extraProperties, err := core.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties

	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *Refund) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

// Published when a [Refund](entity:PaymentRefund) is created.
type RefundCreatedWebhook struct {
	// The ID of the target merchant associated with the event.
	MerchantId *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The type of event this represents, `"refund.created"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// A unique ID for the webhook event.
	EventId *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// Timestamp of when the webhook event was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// Data associated with the event.
	Data *RefundCreatedWebhookData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (r *RefundCreatedWebhook) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RefundCreatedWebhook) UnmarshalJSON(data []byte) error {
	type unmarshaler RefundCreatedWebhook
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RefundCreatedWebhook(value)

	extraProperties, err := core.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties

	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *RefundCreatedWebhook) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type RefundCreatedWebhookData struct {
	// Name of the affected object’s type, `"refund"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// ID of the affected refund.
	Id *string `json:"id,omitempty" url:"id,omitempty"`
	// An object containing the created refund.
	Object *RefundCreatedWebhookObject `json:"object,omitempty" url:"object,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (r *RefundCreatedWebhookData) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RefundCreatedWebhookData) UnmarshalJSON(data []byte) error {
	type unmarshaler RefundCreatedWebhookData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RefundCreatedWebhookData(value)

	extraProperties, err := core.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties

	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *RefundCreatedWebhookData) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type RefundCreatedWebhookObject struct {
	// The created refund.
	Refund *PaymentRefund `json:"refund,omitempty" url:"refund,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (r *RefundCreatedWebhookObject) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RefundCreatedWebhookObject) UnmarshalJSON(data []byte) error {
	type unmarshaler RefundCreatedWebhookObject
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RefundCreatedWebhookObject(value)

	extraProperties, err := core.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties

	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *RefundCreatedWebhookObject) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

// Indicates a refund's current status.
type RefundStatus string

const (
	RefundStatusPending  RefundStatus = "PENDING"
	RefundStatusApproved RefundStatus = "APPROVED"
	RefundStatusRejected RefundStatus = "REJECTED"
	RefundStatusFailed   RefundStatus = "FAILED"
)

func NewRefundStatusFromString(s string) (RefundStatus, error) {
	switch s {
	case "PENDING":
		return RefundStatusPending, nil
	case "APPROVED":
		return RefundStatusApproved, nil
	case "REJECTED":
		return RefundStatusRejected, nil
	case "FAILED":
		return RefundStatusFailed, nil
	}
	var t RefundStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (r RefundStatus) Ptr() *RefundStatus {
	return &r
}

// Published when a [Refund](entity:PaymentRefund) is updated.
// Typically the `refund.status` changes when a refund is completed.
type RefundUpdatedWebhook struct {
	// The ID of the target merchant associated with the event.
	MerchantId *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The type of event this represents, `"refund.updated"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// A unique ID for the webhook event.
	EventId *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// Timestamp of when the webhook event was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// Data associated with the event.
	Data *RefundUpdatedWebhookData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (r *RefundUpdatedWebhook) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RefundUpdatedWebhook) UnmarshalJSON(data []byte) error {
	type unmarshaler RefundUpdatedWebhook
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RefundUpdatedWebhook(value)

	extraProperties, err := core.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties

	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *RefundUpdatedWebhook) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type RefundUpdatedWebhookData struct {
	// Name of the affected object’s type, `"refund"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// ID of the affected refund.
	Id *string `json:"id,omitempty" url:"id,omitempty"`
	// An object containing the updated refund.
	Object *RefundUpdatedWebhookObject `json:"object,omitempty" url:"object,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (r *RefundUpdatedWebhookData) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RefundUpdatedWebhookData) UnmarshalJSON(data []byte) error {
	type unmarshaler RefundUpdatedWebhookData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RefundUpdatedWebhookData(value)

	extraProperties, err := core.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties

	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *RefundUpdatedWebhookData) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type RefundUpdatedWebhookObject struct {
	// The updated refund.
	Refund *PaymentRefund `json:"refund,omitempty" url:"refund,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (r *RefundUpdatedWebhookObject) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RefundUpdatedWebhookObject) UnmarshalJSON(data []byte) error {
	type unmarshaler RefundUpdatedWebhookObject
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RefundUpdatedWebhookObject(value)

	extraProperties, err := core.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties

	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *RefundUpdatedWebhookObject) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

// The status of the domain registration.
type RegisterDomainResponseStatus string

const (
	RegisterDomainResponseStatusPending  RegisterDomainResponseStatus = "PENDING"
	RegisterDomainResponseStatusVerified RegisterDomainResponseStatus = "VERIFIED"
	RegisterDomainResponseStatusDoNotUse RegisterDomainResponseStatus = "DO_NOT_USE"
)

func NewRegisterDomainResponseStatusFromString(s string) (RegisterDomainResponseStatus, error) {
	switch s {
	case "PENDING":
		return RegisterDomainResponseStatusPending, nil
	case "VERIFIED":
		return RegisterDomainResponseStatusVerified, nil
	case "DO_NOT_USE":
		return RegisterDomainResponseStatusDoNotUse, nil
	}
	var t RegisterDomainResponseStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (r RegisterDomainResponseStatus) Ptr() *RegisterDomainResponseStatus {
	return &r
}

// Defines the fields that are included in the request body of
// a request to the [RemoveGroupFromCustomer](api-endpoint:Customers-RemoveGroupFromCustomer) endpoint.
type RemoveGroupFromCustomerRequest struct {
	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (r *RemoveGroupFromCustomerRequest) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RemoveGroupFromCustomerRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler RemoveGroupFromCustomerRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RemoveGroupFromCustomerRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties

	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *RemoveGroupFromCustomerRequest) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

// Defines the fields that are included in the response body of
// a request to the [RemoveGroupFromCustomer](api-endpoint:Customers-RemoveGroupFromCustomer)
// endpoint.
type RemoveGroupFromCustomerResponse struct {
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (r *RemoveGroupFromCustomerResponse) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RemoveGroupFromCustomerResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler RemoveGroupFromCustomerResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RemoveGroupFromCustomerResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties

	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *RemoveGroupFromCustomerResponse) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

// Represents fraud risk information for the associated payment.
//
// When you take a payment through Square's Payments API (using the `CreatePayment`
// endpoint), Square evaluates it and assigns a risk level to the payment. Sellers
// can use this information to determine the course of action (for example,
// provide the goods/services or refund the payment).
type RiskEvaluation struct {
	// The timestamp when payment risk was evaluated, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The risk level associated with the payment
	// See [RiskEvaluationRiskLevel](#type-riskevaluationrisklevel) for possible values
	RiskLevel *RiskEvaluationRiskLevel `json:"risk_level,omitempty" url:"risk_level,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (r *RiskEvaluation) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RiskEvaluation) UnmarshalJSON(data []byte) error {
	type unmarshaler RiskEvaluation
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RiskEvaluation(value)

	extraProperties, err := core.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties

	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *RiskEvaluation) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type RiskEvaluationRiskLevel string

const (
	RiskEvaluationRiskLevelDoNotUse RiskEvaluationRiskLevel = "DO_NOT_USE"
	RiskEvaluationRiskLevelPending  RiskEvaluationRiskLevel = "PENDING"
	RiskEvaluationRiskLevelNormal   RiskEvaluationRiskLevel = "NORMAL"
	RiskEvaluationRiskLevelModerate RiskEvaluationRiskLevel = "MODERATE"
	RiskEvaluationRiskLevelHigh     RiskEvaluationRiskLevel = "HIGH"
)

func NewRiskEvaluationRiskLevelFromString(s string) (RiskEvaluationRiskLevel, error) {
	switch s {
	case "DO_NOT_USE":
		return RiskEvaluationRiskLevelDoNotUse, nil
	case "PENDING":
		return RiskEvaluationRiskLevelPending, nil
	case "NORMAL":
		return RiskEvaluationRiskLevelNormal, nil
	case "MODERATE":
		return RiskEvaluationRiskLevelModerate, nil
	case "HIGH":
		return RiskEvaluationRiskLevelHigh, nil
	}
	var t RiskEvaluationRiskLevel
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (r RiskEvaluationRiskLevel) Ptr() *RiskEvaluationRiskLevel {
	return &r
}

// Describes save-card action fields.
type SaveCardOptions struct {
	// The square-assigned ID of the customer linked to the saved card.
	CustomerId string `json:"customer_id" url:"customer_id"`
	// The id of the created card-on-file.
	CardId *string `json:"card_id,omitempty" url:"card_id,omitempty"`
	// An optional user-defined reference ID that can be used to associate
	// this `Card` to another entity in an external system. For example, a customer
	// ID generated by a third-party system.
	ReferenceId *string `json:"reference_id,omitempty" url:"reference_id,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *SaveCardOptions) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SaveCardOptions) UnmarshalJSON(data []byte) error {
	type unmarshaler SaveCardOptions
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SaveCardOptions(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SaveCardOptions) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// A query filter to search for buyer-accessible availabilities by.
type SearchAvailabilityFilter struct {
	// The query expression to search for buy-accessible availabilities with their starting times falling within the specified time range.
	// The time range must be at least 24 hours and at most 32 days long.
	// For waitlist availabilities, the time range can be 0 or more up to 366 days long.
	StartAtRange *TimeRange `json:"start_at_range,omitempty" url:"start_at_range,omitempty"`
	// The query expression to search for buyer-accessible availabilities with their location IDs matching the specified location ID.
	// This query expression cannot be set if `booking_id` is set.
	LocationId *string `json:"location_id,omitempty" url:"location_id,omitempty"`
	// The query expression to search for buyer-accessible availabilities matching the specified list of segment filters.
	// If the size of the `segment_filters` list is `n`, the search returns availabilities with `n` segments per availability.
	//
	// This query expression cannot be set if `booking_id` is set.
	SegmentFilters []*SegmentFilter `json:"segment_filters,omitempty" url:"segment_filters,omitempty"`
	// The query expression to search for buyer-accessible availabilities for an existing booking by matching the specified `booking_id` value.
	// This is commonly used to reschedule an appointment.
	// If this expression is set, the `location_id` and `segment_filters` expressions cannot be set.
	BookingId *string `json:"booking_id,omitempty" url:"booking_id,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *SearchAvailabilityFilter) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SearchAvailabilityFilter) UnmarshalJSON(data []byte) error {
	type unmarshaler SearchAvailabilityFilter
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SearchAvailabilityFilter(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SearchAvailabilityFilter) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// The search criteria for the loyalty accounts.
type SearchLoyaltyAccountsRequestLoyaltyAccountQuery struct {
	// The set of mappings to use in the loyalty account search.
	//
	// This cannot be combined with `customer_ids`.
	//
	// Max: 30 mappings
	Mappings []*LoyaltyAccountMapping `json:"mappings,omitempty" url:"mappings,omitempty"`
	// The set of customer IDs to use in the loyalty account search.
	//
	// This cannot be combined with `mappings`.
	//
	// Max: 30 customer IDs
	CustomerIds []string `json:"customer_ids,omitempty" url:"customer_ids,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *SearchLoyaltyAccountsRequestLoyaltyAccountQuery) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SearchLoyaltyAccountsRequestLoyaltyAccountQuery) UnmarshalJSON(data []byte) error {
	type unmarshaler SearchLoyaltyAccountsRequestLoyaltyAccountQuery
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SearchLoyaltyAccountsRequestLoyaltyAccountQuery(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SearchLoyaltyAccountsRequestLoyaltyAccountQuery) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// A response that includes loyalty accounts that satisfy the search criteria.
type SearchLoyaltyAccountsResponse struct {
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The loyalty accounts that met the search criteria,
	// in order of creation date.
	LoyaltyAccounts []*LoyaltyAccount `json:"loyalty_accounts,omitempty" url:"loyalty_accounts,omitempty"`
	// The pagination cursor to use in a subsequent
	// request. If empty, this is the final response.
	// For more information,
	// see [Pagination](https://developer.squareup.com/docs/basics/api101/pagination).
	Cursor *string `json:"cursor,omitempty" url:"cursor,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *SearchLoyaltyAccountsResponse) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SearchLoyaltyAccountsResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler SearchLoyaltyAccountsResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SearchLoyaltyAccountsResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SearchLoyaltyAccountsResponse) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// The set of search requirements.
type SearchLoyaltyRewardsRequestLoyaltyRewardQuery struct {
	// The ID of the [loyalty account](entity:LoyaltyAccount) to which the loyalty reward belongs.
	LoyaltyAccountId string `json:"loyalty_account_id" url:"loyalty_account_id"`
	// The status of the loyalty reward.
	// See [LoyaltyRewardStatus](#type-loyaltyrewardstatus) for possible values
	Status *LoyaltyRewardStatus `json:"status,omitempty" url:"status,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *SearchLoyaltyRewardsRequestLoyaltyRewardQuery) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SearchLoyaltyRewardsRequestLoyaltyRewardQuery) UnmarshalJSON(data []byte) error {
	type unmarshaler SearchLoyaltyRewardsRequestLoyaltyRewardQuery
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SearchLoyaltyRewardsRequestLoyaltyRewardQuery(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SearchLoyaltyRewardsRequestLoyaltyRewardQuery) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// A response that includes the loyalty rewards satisfying the search criteria.
type SearchLoyaltyRewardsResponse struct {
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The loyalty rewards that satisfy the search criteria.
	// These are returned in descending order by `updated_at`.
	Rewards []*LoyaltyReward `json:"rewards,omitempty" url:"rewards,omitempty"`
	// The pagination cursor to be used in a subsequent
	// request. If empty, this is the final response.
	Cursor *string `json:"cursor,omitempty" url:"cursor,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *SearchLoyaltyRewardsResponse) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SearchLoyaltyRewardsResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler SearchLoyaltyRewardsResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SearchLoyaltyRewardsResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SearchLoyaltyRewardsResponse) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// A filter based on the order `customer_id` and any tender `customer_id`
// associated with the order. It does not filter based on the
// [FulfillmentRecipient](entity:OrderFulfillmentRecipient) `customer_id`.
type SearchOrdersCustomerFilter struct {
	// A list of customer IDs to filter by.
	//
	// Max: 10 customer IDs.
	CustomerIds []string `json:"customer_ids,omitempty" url:"customer_ids,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *SearchOrdersCustomerFilter) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SearchOrdersCustomerFilter) UnmarshalJSON(data []byte) error {
	type unmarshaler SearchOrdersCustomerFilter
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SearchOrdersCustomerFilter(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SearchOrdersCustomerFilter) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Filter for `Order` objects based on whether their `CREATED_AT`,
// `CLOSED_AT`, or `UPDATED_AT` timestamps fall within a specified time range.
// You can specify the time range and which timestamp to filter for. You can filter
// for only one time range at a time.
//
// For each time range, the start time and end time are inclusive. If the end time
// is absent, it defaults to the time of the first request for the cursor.
//
// **Important:** If you use the `DateTimeFilter` in a `SearchOrders` query,
// you must set the `sort_field` in [OrdersSort](entity:SearchOrdersSort)
// to the same field you filter for. For example, if you set the `CLOSED_AT` field
// in `DateTimeFilter`, you must set the `sort_field` in `SearchOrdersSort` to
// `CLOSED_AT`. Otherwise, `SearchOrders` throws an error.
// [Learn more about filtering orders by time range.](https://developer.squareup.com/docs/orders-api/manage-orders#important-note-on-filtering-orders-by-time-range)
type SearchOrdersDateTimeFilter struct {
	// The time range for filtering on the `created_at` timestamp. If you use this
	// value, you must set the `sort_field` in the `OrdersSearchSort` object to
	// `CREATED_AT`.
	CreatedAt *TimeRange `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The time range for filtering on the `updated_at` timestamp. If you use this
	// value, you must set the `sort_field` in the `OrdersSearchSort` object to
	// `UPDATED_AT`.
	UpdatedAt *TimeRange `json:"updated_at,omitempty" url:"updated_at,omitempty"`
	// The time range for filtering on the `closed_at` timestamp. If you use this
	// value, you must set the `sort_field` in the `OrdersSearchSort` object to
	// `CLOSED_AT`.
	ClosedAt *TimeRange `json:"closed_at,omitempty" url:"closed_at,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *SearchOrdersDateTimeFilter) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SearchOrdersDateTimeFilter) UnmarshalJSON(data []byte) error {
	type unmarshaler SearchOrdersDateTimeFilter
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SearchOrdersDateTimeFilter(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SearchOrdersDateTimeFilter) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Filtering criteria to use for a `SearchOrders` request. Multiple filters
// are ANDed together.
type SearchOrdersFilter struct {
	// Filter by [OrderState](entity:OrderState).
	StateFilter *SearchOrdersStateFilter `json:"state_filter,omitempty" url:"state_filter,omitempty"`
	// Filter for results within a time range.
	//
	// **Important:** If you filter for orders by time range, you must set `SearchOrdersSort`
	// to sort by the same field.
	// [Learn more about filtering orders by time range.](https://developer.squareup.com/docs/orders-api/manage-orders#important-note-on-filtering-orders-by-time-range)
	DateTimeFilter *SearchOrdersDateTimeFilter `json:"date_time_filter,omitempty" url:"date_time_filter,omitempty"`
	// Filter by the fulfillment type or state.
	FulfillmentFilter *SearchOrdersFulfillmentFilter `json:"fulfillment_filter,omitempty" url:"fulfillment_filter,omitempty"`
	// Filter by the source of the order.
	SourceFilter *SearchOrdersSourceFilter `json:"source_filter,omitempty" url:"source_filter,omitempty"`
	// Filter by customers associated with the order.
	CustomerFilter *SearchOrdersCustomerFilter `json:"customer_filter,omitempty" url:"customer_filter,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *SearchOrdersFilter) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SearchOrdersFilter) UnmarshalJSON(data []byte) error {
	type unmarshaler SearchOrdersFilter
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SearchOrdersFilter(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SearchOrdersFilter) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Filter based on [order fulfillment](entity:OrderFulfillment) information.
type SearchOrdersFulfillmentFilter struct {
	// A list of [fulfillment types](entity:OrderFulfillmentType) to filter
	// for. The list returns orders if any of its fulfillments match any of the fulfillment types
	// listed in this field.
	// See [OrderFulfillmentType](#type-orderfulfillmenttype) for possible values
	FulfillmentTypes []OrderFulfillmentType `json:"fulfillment_types,omitempty" url:"fulfillment_types,omitempty"`
	// A list of [fulfillment states](entity:OrderFulfillmentState) to filter
	// for. The list returns orders if any of its fulfillments match any of the
	// fulfillment states listed in this field.
	// See [OrderFulfillmentState](#type-orderfulfillmentstate) for possible values
	FulfillmentStates []OrderFulfillmentState `json:"fulfillment_states,omitempty" url:"fulfillment_states,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *SearchOrdersFulfillmentFilter) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SearchOrdersFulfillmentFilter) UnmarshalJSON(data []byte) error {
	type unmarshaler SearchOrdersFulfillmentFilter
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SearchOrdersFulfillmentFilter(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SearchOrdersFulfillmentFilter) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Sorting criteria for a `SearchOrders` request. Results can only be sorted
// by a timestamp field.
type SearchOrdersSort struct {
	// The field to sort by.
	//
	// **Important:** When using a [DateTimeFilter](entity:SearchOrdersFilter),
	// `sort_field` must match the timestamp field that the `DateTimeFilter` uses to
	// filter. For example, if you set your `sort_field` to `CLOSED_AT` and you use a
	// `DateTimeFilter`, your `DateTimeFilter` must filter for orders by their `CLOSED_AT` date.
	// If this field does not match the timestamp field in `DateTimeFilter`,
	// `SearchOrders` returns an error.
	//
	// Default: `CREATED_AT`.
	// See [SearchOrdersSortField](#type-searchorderssortfield) for possible values
	SortField SearchOrdersSortField `json:"sort_field" url:"sort_field"`
	// The chronological order in which results are returned. Defaults to `DESC`.
	// See [SortOrder](#type-sortorder) for possible values
	SortOrder *SortOrder `json:"sort_order,omitempty" url:"sort_order,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *SearchOrdersSort) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SearchOrdersSort) UnmarshalJSON(data []byte) error {
	type unmarshaler SearchOrdersSort
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SearchOrdersSort(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SearchOrdersSort) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Specifies which timestamp to use to sort `SearchOrder` results.
type SearchOrdersSortField string

const (
	SearchOrdersSortFieldDoNotUse  SearchOrdersSortField = "DO_NOT_USE"
	SearchOrdersSortFieldCreatedAt SearchOrdersSortField = "CREATED_AT"
	SearchOrdersSortFieldUpdatedAt SearchOrdersSortField = "UPDATED_AT"
	SearchOrdersSortFieldClosedAt  SearchOrdersSortField = "CLOSED_AT"
)

func NewSearchOrdersSortFieldFromString(s string) (SearchOrdersSortField, error) {
	switch s {
	case "DO_NOT_USE":
		return SearchOrdersSortFieldDoNotUse, nil
	case "CREATED_AT":
		return SearchOrdersSortFieldCreatedAt, nil
	case "UPDATED_AT":
		return SearchOrdersSortFieldUpdatedAt, nil
	case "CLOSED_AT":
		return SearchOrdersSortFieldClosedAt, nil
	}
	var t SearchOrdersSortField
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s SearchOrdersSortField) Ptr() *SearchOrdersSortField {
	return &s
}

// A filter based on order `source` information.
type SearchOrdersSourceFilter struct {
	// Filters by the [Source](entity:OrderSource) `name`. The filter returns any orders
	// with a `source.name` that matches any of the listed source names.
	//
	// Max: 10 source names.
	SourceNames []string `json:"source_names,omitempty" url:"source_names,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *SearchOrdersSourceFilter) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SearchOrdersSourceFilter) UnmarshalJSON(data []byte) error {
	type unmarshaler SearchOrdersSourceFilter
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SearchOrdersSourceFilter(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SearchOrdersSourceFilter) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Filter by the current order `state`.
type SearchOrdersStateFilter struct {
	// States to filter for.
	// See [OrderState](#type-orderstate) for possible values
	States []OrderState `json:"states,omitempty" url:"states,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *SearchOrdersStateFilter) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SearchOrdersStateFilter) UnmarshalJSON(data []byte) error {
	type unmarshaler SearchOrdersStateFilter
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SearchOrdersStateFilter(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SearchOrdersStateFilter) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// The response to a request for `Shift` objects. The response contains
// the requested `Shift` objects and might contain a set of `Error` objects if
// the request resulted in errors.
type SearchShiftsResponse struct {
	// Shifts.
	Shifts []*Shift `json:"shifts,omitempty" url:"shifts,omitempty"`
	// An opaque cursor for fetching the next page.
	Cursor *string `json:"cursor,omitempty" url:"cursor,omitempty"`
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *SearchShiftsResponse) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SearchShiftsResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler SearchShiftsResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SearchShiftsResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SearchShiftsResponse) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Represents a set of query expressions (filters) to narrow the scope of targeted subscriptions returned by
// the [SearchSubscriptions](api-endpoint:Subscriptions-SearchSubscriptions) endpoint.
type SearchSubscriptionsFilter struct {
	// A filter to select subscriptions based on the subscribing customer IDs.
	CustomerIds []string `json:"customer_ids,omitempty" url:"customer_ids,omitempty"`
	// A filter to select subscriptions based on the location.
	LocationIds []string `json:"location_ids,omitempty" url:"location_ids,omitempty"`
	// A filter to select subscriptions based on the source application.
	SourceNames []string `json:"source_names,omitempty" url:"source_names,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *SearchSubscriptionsFilter) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SearchSubscriptionsFilter) UnmarshalJSON(data []byte) error {
	type unmarshaler SearchSubscriptionsFilter
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SearchSubscriptionsFilter(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SearchSubscriptionsFilter) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Represents a filter used in a search for `TeamMember` objects. `AND` logic is applied
// between the individual fields, and `OR` logic is applied within list-based fields.
// For example, setting this filter value:
//
// ```
// filter = (locations_ids = ["A", "B"], status = ACTIVE)
// ```
//
// returns only active team members assigned to either location "A" or "B".
type SearchTeamMembersFilter struct {
	// When present, filters by team members assigned to the specified locations.
	// When empty, includes team members assigned to any location.
	LocationIds []string `json:"location_ids,omitempty" url:"location_ids,omitempty"`
	// When present, filters by team members who match the given status.
	// When empty, includes team members of all statuses.
	// See [TeamMemberStatus](#type-teammemberstatus) for possible values
	Status *TeamMemberStatus `json:"status,omitempty" url:"status,omitempty"`
	// When present and set to true, returns the team member who is the owner of the Square account.
	IsOwner *bool `json:"is_owner,omitempty" url:"is_owner,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *SearchTeamMembersFilter) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SearchTeamMembersFilter) UnmarshalJSON(data []byte) error {
	type unmarshaler SearchTeamMembersFilter
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SearchTeamMembersFilter(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SearchTeamMembersFilter) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SearchTerminalActionsResponse struct {
	// Information on errors encountered during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The requested search result of `TerminalAction`s.
	Action []*TerminalAction `json:"action,omitempty" url:"action,omitempty"`
	// The pagination cursor to be used in a subsequent request. If empty,
	// this is the final response.
	//
	// See [Pagination](https://developer.squareup.com/docs/basics/api101/pagination) for more
	// information.
	Cursor *string `json:"cursor,omitempty" url:"cursor,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *SearchTerminalActionsResponse) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SearchTerminalActionsResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler SearchTerminalActionsResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SearchTerminalActionsResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SearchTerminalActionsResponse) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SearchTerminalCheckoutsResponse struct {
	// Information about errors encountered during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The requested search result of `TerminalCheckout` objects.
	Checkouts []*TerminalCheckout `json:"checkouts,omitempty" url:"checkouts,omitempty"`
	// The pagination cursor to be used in a subsequent request. If empty,
	// this is the final response.
	//
	// See [Pagination](https://developer.squareup.com/docs/basics/api101/pagination) for more information.
	Cursor *string `json:"cursor,omitempty" url:"cursor,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *SearchTerminalCheckoutsResponse) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SearchTerminalCheckoutsResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler SearchTerminalCheckoutsResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SearchTerminalCheckoutsResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SearchTerminalCheckoutsResponse) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SearchTerminalRefundsResponse struct {
	// Information about errors encountered during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The requested search result of `TerminalRefund` objects.
	Refunds []*TerminalRefund `json:"refunds,omitempty" url:"refunds,omitempty"`
	// The pagination cursor to be used in a subsequent request. If empty,
	// this is the final response.
	//
	// See [Pagination](https://developer.squareup.com/docs/basics/api101/pagination) for more information.
	Cursor *string `json:"cursor,omitempty" url:"cursor,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *SearchTerminalRefundsResponse) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SearchTerminalRefundsResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler SearchTerminalRefundsResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SearchTerminalRefundsResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SearchTerminalRefundsResponse) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// The field to sort the returned [Vendor](entity:Vendor) objects by.
type SearchVendorsRequestSortField string

const (
	SearchVendorsRequestSortFieldName      SearchVendorsRequestSortField = "NAME"
	SearchVendorsRequestSortFieldCreatedAt SearchVendorsRequestSortField = "CREATED_AT"
)

func NewSearchVendorsRequestSortFieldFromString(s string) (SearchVendorsRequestSortField, error) {
	switch s {
	case "NAME":
		return SearchVendorsRequestSortFieldName, nil
	case "CREATED_AT":
		return SearchVendorsRequestSortFieldCreatedAt, nil
	}
	var t SearchVendorsRequestSortField
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s SearchVendorsRequestSortField) Ptr() *SearchVendorsRequestSortField {
	return &s
}

// A query filter to search for buyer-accessible appointment segments by.
type SegmentFilter struct {
	// The ID of the [CatalogItemVariation](entity:CatalogItemVariation) object representing the service booked in this segment.
	ServiceVariationId string `json:"service_variation_id" url:"service_variation_id"`
	// A query filter to search for buyer-accessible appointment segments with service-providing team members matching the specified list of team member IDs. Supported query expressions are
	//
	// - `ANY`: return the appointment segments with team members whose IDs match any member in this list.
	// - `NONE`: return the appointment segments with team members whose IDs are in this list.
	// - `ALL`: not supported.
	//
	// When no expression is specified, any service-providing team member is eligible to fulfill the Booking.
	TeamMemberIdFilter *FilterValue `json:"team_member_id_filter,omitempty" url:"team_member_id_filter,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *SegmentFilter) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SegmentFilter) UnmarshalJSON(data []byte) error {
	type unmarshaler SegmentFilter
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SegmentFilter(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SegmentFilter) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// A record of the hourly rate, start, and end times for a single work shift
// for an employee. This might include a record of the start and end times for breaks
// taken during the shift.
type Shift struct {
	// The UUID for this object.
	Id *string `json:"id,omitempty" url:"id,omitempty"`
	// The ID of the employee this shift belongs to. DEPRECATED at version 2020-08-26. Use `team_member_id` instead.
	EmployeeId *string `json:"employee_id,omitempty" url:"employee_id,omitempty"`
	// The ID of the location this shift occurred at. The location should be based on
	// where the employee clocked in.
	LocationId *string `json:"location_id,omitempty" url:"location_id,omitempty"`
	// The read-only convenience value that is calculated from the location based
	// on the `location_id`. Format: the IANA timezone database identifier for the
	// location timezone.
	Timezone *string `json:"timezone,omitempty" url:"timezone,omitempty"`
	// RFC 3339; shifted to the location timezone + offset. Precision up to the
	// minute is respected; seconds are truncated.
	StartAt string `json:"start_at" url:"start_at"`
	// RFC 3339; shifted to the timezone + offset. Precision up to the minute is
	// respected; seconds are truncated.
	EndAt *string `json:"end_at,omitempty" url:"end_at,omitempty"`
	// Job and pay related information. If the wage is not set on create, it defaults to a wage
	// of zero. If the title is not set on create, it defaults to the name of the role the employee
	// is assigned to, if any.
	Wage *ShiftWage `json:"wage,omitempty" url:"wage,omitempty"`
	// A list of all the paid or unpaid breaks that were taken during this shift.
	Breaks []*Break `json:"breaks,omitempty" url:"breaks,omitempty"`
	// Describes the working state of the current `Shift`.
	// See [ShiftStatus](#type-shiftstatus) for possible values
	Status *ShiftStatus `json:"status,omitempty" url:"status,omitempty"`
	// Used for resolving concurrency issues. The request fails if the version
	// provided does not match the server version at the time of the request. If not provided,
	// Square executes a blind write; potentially overwriting data from another
	// write.
	Version *int `json:"version,omitempty" url:"version,omitempty"`
	// A read-only timestamp in RFC 3339 format; presented in UTC.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// A read-only timestamp in RFC 3339 format; presented in UTC.
	UpdatedAt *string `json:"updated_at,omitempty" url:"updated_at,omitempty"`
	// The ID of the team member this shift belongs to. Replaced `employee_id` at version "2020-08-26".
	TeamMemberId *string `json:"team_member_id,omitempty" url:"team_member_id,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *Shift) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *Shift) UnmarshalJSON(data []byte) error {
	type unmarshaler Shift
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = Shift(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *Shift) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Defines a filter used in a search for `Shift` records. `AND` logic is
// used by Square's servers to apply each filter property specified.
type ShiftFilter struct {
	// Fetch shifts for the specified location.
	LocationIds []string `json:"location_ids,omitempty" url:"location_ids,omitempty"`
	// Fetch shifts for the specified employees. DEPRECATED at version 2020-08-26. Use `team_member_ids` instead.
	EmployeeIds []string `json:"employee_ids,omitempty" url:"employee_ids,omitempty"`
	// Fetch a `Shift` instance by `Shift.status`.
	// See [ShiftFilterStatus](#type-shiftfilterstatus) for possible values
	Status *ShiftFilterStatus `json:"status,omitempty" url:"status,omitempty"`
	// Fetch `Shift` instances that start in the time range - Inclusive.
	Start *TimeRange `json:"start,omitempty" url:"start,omitempty"`
	// Fetch the `Shift` instances that end in the time range - Inclusive.
	End *TimeRange `json:"end,omitempty" url:"end,omitempty"`
	// Fetch the `Shift` instances based on the workday date range.
	Workday *ShiftWorkday `json:"workday,omitempty" url:"workday,omitempty"`
	// Fetch shifts for the specified team members. Replaced `employee_ids` at version "2020-08-26".
	TeamMemberIds []string `json:"team_member_ids,omitempty" url:"team_member_ids,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *ShiftFilter) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *ShiftFilter) UnmarshalJSON(data []byte) error {
	type unmarshaler ShiftFilter
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = ShiftFilter(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *ShiftFilter) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Specifies the `status` of `Shift` records to be returned.
type ShiftFilterStatus string

const (
	ShiftFilterStatusDoNotUse ShiftFilterStatus = "DO_NOT_USE"
	ShiftFilterStatusOpen     ShiftFilterStatus = "OPEN"
	ShiftFilterStatusClosed   ShiftFilterStatus = "CLOSED"
)

func NewShiftFilterStatusFromString(s string) (ShiftFilterStatus, error) {
	switch s {
	case "DO_NOT_USE":
		return ShiftFilterStatusDoNotUse, nil
	case "OPEN":
		return ShiftFilterStatusOpen, nil
	case "CLOSED":
		return ShiftFilterStatusClosed, nil
	}
	var t ShiftFilterStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s ShiftFilterStatus) Ptr() *ShiftFilterStatus {
	return &s
}

// The parameters of a `Shift` search query, which includes filter and sort options.
type ShiftQuery struct {
	// Query filter options.
	Filter *ShiftFilter `json:"filter,omitempty" url:"filter,omitempty"`
	// Sort order details.
	Sort *ShiftSort `json:"sort,omitempty" url:"sort,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *ShiftQuery) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *ShiftQuery) UnmarshalJSON(data []byte) error {
	type unmarshaler ShiftQuery
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = ShiftQuery(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *ShiftQuery) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Sets the sort order of search results.
type ShiftSort struct {
	// The field to sort on.
	// See [ShiftSortField](#type-shiftsortfield) for possible values
	Field *ShiftSortField `json:"field,omitempty" url:"field,omitempty"`
	// The order in which results are returned. Defaults to DESC.
	// See [SortOrder](#type-sortorder) for possible values
	Order *SortOrder `json:"order,omitempty" url:"order,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *ShiftSort) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *ShiftSort) UnmarshalJSON(data []byte) error {
	type unmarshaler ShiftSort
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = ShiftSort(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *ShiftSort) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Enumerates the `Shift` fields to sort on.
type ShiftSortField string

const (
	ShiftSortFieldDoNotUse  ShiftSortField = "DO_NOT_USE"
	ShiftSortFieldStartAt   ShiftSortField = "START_AT"
	ShiftSortFieldEndAt     ShiftSortField = "END_AT"
	ShiftSortFieldCreatedAt ShiftSortField = "CREATED_AT"
	ShiftSortFieldUpdatedAt ShiftSortField = "UPDATED_AT"
)

func NewShiftSortFieldFromString(s string) (ShiftSortField, error) {
	switch s {
	case "DO_NOT_USE":
		return ShiftSortFieldDoNotUse, nil
	case "START_AT":
		return ShiftSortFieldStartAt, nil
	case "END_AT":
		return ShiftSortFieldEndAt, nil
	case "CREATED_AT":
		return ShiftSortFieldCreatedAt, nil
	case "UPDATED_AT":
		return ShiftSortFieldUpdatedAt, nil
	}
	var t ShiftSortField
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s ShiftSortField) Ptr() *ShiftSortField {
	return &s
}

// Enumerates the possible status of a `Shift`.
type ShiftStatus string

const (
	ShiftStatusUnknownStatus ShiftStatus = "UNKNOWN_STATUS"
	ShiftStatusOpen          ShiftStatus = "OPEN"
	ShiftStatusClosed        ShiftStatus = "CLOSED"
)

func NewShiftStatusFromString(s string) (ShiftStatus, error) {
	switch s {
	case "UNKNOWN_STATUS":
		return ShiftStatusUnknownStatus, nil
	case "OPEN":
		return ShiftStatusOpen, nil
	case "CLOSED":
		return ShiftStatusClosed, nil
	}
	var t ShiftStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s ShiftStatus) Ptr() *ShiftStatus {
	return &s
}

// The hourly wage rate used to compensate an employee for this shift.
type ShiftWage struct {
	// The name of the job performed during this shift. Square
	// labor-reporting UIs might group shifts together by title.
	Title *string `json:"title,omitempty" url:"title,omitempty"`
	// Can be a custom-set hourly wage or the calculated effective hourly
	// wage based on the annual wage and hours worked per week.
	HourlyRate *Money `json:"hourly_rate,omitempty" url:"hourly_rate,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *ShiftWage) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *ShiftWage) UnmarshalJSON(data []byte) error {
	type unmarshaler ShiftWage
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = ShiftWage(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *ShiftWage) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// A `Shift` search query filter parameter that sets a range of days that
// a `Shift` must start or end in before passing the filter condition.
type ShiftWorkday struct {
	// Dates for fetching the shifts.
	DateRange *DateRange `json:"date_range,omitempty" url:"date_range,omitempty"`
	// The strategy on which the dates are applied.
	// See [ShiftWorkdayMatcher](#type-shiftworkdaymatcher) for possible values
	MatchShiftsBy *ShiftWorkdayMatcher `json:"match_shifts_by,omitempty" url:"match_shifts_by,omitempty"`
	// Location-specific timezones convert workdays to datetime filters.
	// Every location included in the query must have a timezone or this field
	// must be provided as a fallback. Format: the IANA timezone database
	// identifier for the relevant timezone.
	DefaultTimezone *string `json:"default_timezone,omitempty" url:"default_timezone,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *ShiftWorkday) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *ShiftWorkday) UnmarshalJSON(data []byte) error {
	type unmarshaler ShiftWorkday
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = ShiftWorkday(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *ShiftWorkday) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Defines the logic used to apply a workday filter.
type ShiftWorkdayMatcher string

const (
	ShiftWorkdayMatcherDoNotUse     ShiftWorkdayMatcher = "DO_NOT_USE"
	ShiftWorkdayMatcherStartAt      ShiftWorkdayMatcher = "START_AT"
	ShiftWorkdayMatcherEndAt        ShiftWorkdayMatcher = "END_AT"
	ShiftWorkdayMatcherIntersection ShiftWorkdayMatcher = "INTERSECTION"
)

func NewShiftWorkdayMatcherFromString(s string) (ShiftWorkdayMatcher, error) {
	switch s {
	case "DO_NOT_USE":
		return ShiftWorkdayMatcherDoNotUse, nil
	case "START_AT":
		return ShiftWorkdayMatcherStartAt, nil
	case "END_AT":
		return ShiftWorkdayMatcherEndAt, nil
	case "INTERSECTION":
		return ShiftWorkdayMatcherIntersection, nil
	}
	var t ShiftWorkdayMatcher
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s ShiftWorkdayMatcher) Ptr() *ShiftWorkdayMatcher {
	return &s
}

type ShippingFee struct {
	// The name for the shipping fee.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// The amount and currency for the shipping fee.
	Charge *Money `json:"charge,omitempty" url:"charge,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *ShippingFee) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *ShippingFee) UnmarshalJSON(data []byte) error {
	type unmarshaler ShippingFee
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = ShippingFee(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *ShippingFee) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Represents a Square Online site, which is an online store for a Square seller.
type Site struct {
	// The Square-assigned ID of the site.
	Id *string `json:"id,omitempty" url:"id,omitempty"`
	// The title of the site.
	SiteTitle *string `json:"site_title,omitempty" url:"site_title,omitempty"`
	// The domain of the site (without the protocol). For example, `mysite1.square.site`.
	Domain *string `json:"domain,omitempty" url:"domain,omitempty"`
	// Indicates whether the site is published.
	IsPublished *bool `json:"is_published,omitempty" url:"is_published,omitempty"`
	// The timestamp of when the site was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The timestamp of when the site was last updated, in RFC 3339 format.
	UpdatedAt *string `json:"updated_at,omitempty" url:"updated_at,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *Site) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *Site) UnmarshalJSON(data []byte) error {
	type unmarshaler Site
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = Site(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *Site) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SnippetResponse struct {
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The snippet.
	Snippet *Snippet `json:"snippet,omitempty" url:"snippet,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *SnippetResponse) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SnippetResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler SnippetResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SnippetResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SnippetResponse) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// The order (e.g., chronological or alphabetical) in which results from a request are returned.
type SortOrder string

const (
	SortOrderDesc SortOrder = "DESC"
	SortOrderAsc  SortOrder = "ASC"
)

func NewSortOrderFromString(s string) (SortOrder, error) {
	switch s {
	case "DESC":
		return SortOrderDesc, nil
	case "ASC":
		return SortOrderAsc, nil
	}
	var t SortOrder
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s SortOrder) Ptr() *SortOrder {
	return &s
}

// Represents information about the application used to generate a change.
type SourceApplication struct {
	// **Read only** The [product](entity:Product) type of the application.
	// See [Product](#type-product) for possible values
	Product *Product `json:"product,omitempty" url:"product,omitempty"`
	// **Read only** The Square-assigned ID of the application. This field is used only if the
	// [product](entity:Product) type is `EXTERNAL_API`.
	ApplicationId *string `json:"application_id,omitempty" url:"application_id,omitempty"`
	// **Read only** The display name of the application
	// (for example, `"Custom Application"` or `"Square POS 4.74 for Android"`).
	Name *string `json:"name,omitempty" url:"name,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *SourceApplication) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SourceApplication) UnmarshalJSON(data []byte) error {
	type unmarshaler SourceApplication
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SourceApplication(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SourceApplication) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Contains the name and abbreviation for standard measurement unit.
type StandardUnitDescription struct {
	// Identifies the measurement unit being described.
	Unit *MeasurementUnit `json:"unit,omitempty" url:"unit,omitempty"`
	// UI display name of the measurement unit. For example, 'Pound'.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// UI display abbreviation for the measurement unit. For example, 'lb'.
	Abbreviation *string `json:"abbreviation,omitempty" url:"abbreviation,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *StandardUnitDescription) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *StandardUnitDescription) UnmarshalJSON(data []byte) error {
	type unmarshaler StandardUnitDescription
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = StandardUnitDescription(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *StandardUnitDescription) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Group of standard measurement units.
type StandardUnitDescriptionGroup struct {
	// List of standard (non-custom) measurement units in this description group.
	StandardUnitDescriptions []*StandardUnitDescription `json:"standard_unit_descriptions,omitempty" url:"standard_unit_descriptions,omitempty"`
	// IETF language tag.
	LanguageCode *string `json:"language_code,omitempty" url:"language_code,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *StandardUnitDescriptionGroup) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *StandardUnitDescriptionGroup) UnmarshalJSON(data []byte) error {
	type unmarshaler StandardUnitDescriptionGroup
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = StandardUnitDescriptionGroup(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *StandardUnitDescriptionGroup) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Defines the parameters for a `SubmitEvidence` request.
type SubmitEvidenceRequest struct {
	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *SubmitEvidenceRequest) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SubmitEvidenceRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler SubmitEvidenceRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SubmitEvidenceRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SubmitEvidenceRequest) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Represents an action as a pending change to a subscription.
type SubscriptionAction struct {
	// The ID of an action scoped to a subscription.
	Id *string `json:"id,omitempty" url:"id,omitempty"`
	// The type of the action.
	// See [SubscriptionActionType](#type-subscriptionactiontype) for possible values
	Type *SubscriptionActionType `json:"type,omitempty" url:"type,omitempty"`
	// The `YYYY-MM-DD`-formatted date when the action occurs on the subscription.
	EffectiveDate *string `json:"effective_date,omitempty" url:"effective_date,omitempty"`
	// The target subscription plan a subscription switches to, for a `SWAP_PLAN` action.
	NewPlanId *string `json:"new_plan_id,omitempty" url:"new_plan_id,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *SubscriptionAction) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SubscriptionAction) UnmarshalJSON(data []byte) error {
	type unmarshaler SubscriptionAction
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SubscriptionAction(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SubscriptionAction) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Supported types of an action as a pending change to a subscription.
type SubscriptionActionType string

const (
	SubscriptionActionTypeDefaultSubscriptionActionTypeDoNotUse SubscriptionActionType = "DEFAULT_SUBSCRIPTION_ACTION_TYPE_DO_NOT_USE"
	SubscriptionActionTypeCancel                                SubscriptionActionType = "CANCEL"
	SubscriptionActionTypePause                                 SubscriptionActionType = "PAUSE"
	SubscriptionActionTypeResume                                SubscriptionActionType = "RESUME"
	SubscriptionActionTypeSwapPlan                              SubscriptionActionType = "SWAP_PLAN"
)

func NewSubscriptionActionTypeFromString(s string) (SubscriptionActionType, error) {
	switch s {
	case "DEFAULT_SUBSCRIPTION_ACTION_TYPE_DO_NOT_USE":
		return SubscriptionActionTypeDefaultSubscriptionActionTypeDoNotUse, nil
	case "CANCEL":
		return SubscriptionActionTypeCancel, nil
	case "PAUSE":
		return SubscriptionActionTypePause, nil
	case "RESUME":
		return SubscriptionActionTypeResume, nil
	case "SWAP_PLAN":
		return SubscriptionActionTypeSwapPlan, nil
	}
	var t SubscriptionActionType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s SubscriptionActionType) Ptr() *SubscriptionActionType {
	return &s
}

// Determines the billing cadence of a [Subscription](entity:Subscription)
type SubscriptionCadence string

const (
	SubscriptionCadenceSubscriptionCadenceDoNotUse SubscriptionCadence = "SUBSCRIPTION_CADENCE_DO_NOT_USE"
	SubscriptionCadenceDaily                       SubscriptionCadence = "DAILY"
	SubscriptionCadenceWeekly                      SubscriptionCadence = "WEEKLY"
	SubscriptionCadenceEveryTwoWeeks               SubscriptionCadence = "EVERY_TWO_WEEKS"
	SubscriptionCadenceThirtyDays                  SubscriptionCadence = "THIRTY_DAYS"
	SubscriptionCadenceSixtyDays                   SubscriptionCadence = "SIXTY_DAYS"
	SubscriptionCadenceNinetyDays                  SubscriptionCadence = "NINETY_DAYS"
	SubscriptionCadenceMonthly                     SubscriptionCadence = "MONTHLY"
	SubscriptionCadenceEveryTwoMonths              SubscriptionCadence = "EVERY_TWO_MONTHS"
	SubscriptionCadenceQuarterly                   SubscriptionCadence = "QUARTERLY"
	SubscriptionCadenceEveryFourMonths             SubscriptionCadence = "EVERY_FOUR_MONTHS"
	SubscriptionCadenceEverySixMonths              SubscriptionCadence = "EVERY_SIX_MONTHS"
	SubscriptionCadenceAnnual                      SubscriptionCadence = "ANNUAL"
	SubscriptionCadenceEveryTwoYears               SubscriptionCadence = "EVERY_TWO_YEARS"
)

func NewSubscriptionCadenceFromString(s string) (SubscriptionCadence, error) {
	switch s {
	case "SUBSCRIPTION_CADENCE_DO_NOT_USE":
		return SubscriptionCadenceSubscriptionCadenceDoNotUse, nil
	case "DAILY":
		return SubscriptionCadenceDaily, nil
	case "WEEKLY":
		return SubscriptionCadenceWeekly, nil
	case "EVERY_TWO_WEEKS":
		return SubscriptionCadenceEveryTwoWeeks, nil
	case "THIRTY_DAYS":
		return SubscriptionCadenceThirtyDays, nil
	case "SIXTY_DAYS":
		return SubscriptionCadenceSixtyDays, nil
	case "NINETY_DAYS":
		return SubscriptionCadenceNinetyDays, nil
	case "MONTHLY":
		return SubscriptionCadenceMonthly, nil
	case "EVERY_TWO_MONTHS":
		return SubscriptionCadenceEveryTwoMonths, nil
	case "QUARTERLY":
		return SubscriptionCadenceQuarterly, nil
	case "EVERY_FOUR_MONTHS":
		return SubscriptionCadenceEveryFourMonths, nil
	case "EVERY_SIX_MONTHS":
		return SubscriptionCadenceEverySixMonths, nil
	case "ANNUAL":
		return SubscriptionCadenceAnnual, nil
	case "EVERY_TWO_YEARS":
		return SubscriptionCadenceEveryTwoYears, nil
	}
	var t SubscriptionCadence
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s SubscriptionCadence) Ptr() *SubscriptionCadence {
	return &s
}

// Published when a [Subscription](entity:Subscription) is created.
type SubscriptionCreatedWebhook struct {
	// The ID of the target merchant associated with the event.
	MerchantId *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The type of event this represents, `"subscription.created"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// A unique ID for the webhook event.
	EventId *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// Timestamp of when the webhook event was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// Data associated with the event.
	Data *SubscriptionCreatedWebhookData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *SubscriptionCreatedWebhook) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SubscriptionCreatedWebhook) UnmarshalJSON(data []byte) error {
	type unmarshaler SubscriptionCreatedWebhook
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SubscriptionCreatedWebhook(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SubscriptionCreatedWebhook) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SubscriptionCreatedWebhookData struct {
	// Name of the affected object’s type, `"subscription"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// ID of the affected subscription.
	Id *string `json:"id,omitempty" url:"id,omitempty"`
	// An object containing the created subscription.
	Object *SubscriptionCreatedWebhookObject `json:"object,omitempty" url:"object,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *SubscriptionCreatedWebhookData) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SubscriptionCreatedWebhookData) UnmarshalJSON(data []byte) error {
	type unmarshaler SubscriptionCreatedWebhookData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SubscriptionCreatedWebhookData(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SubscriptionCreatedWebhookData) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SubscriptionCreatedWebhookObject struct {
	// The created subscription.
	Subscription *Subscription `json:"subscription,omitempty" url:"subscription,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *SubscriptionCreatedWebhookObject) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SubscriptionCreatedWebhookObject) UnmarshalJSON(data []byte) error {
	type unmarshaler SubscriptionCreatedWebhookObject
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SubscriptionCreatedWebhookObject(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SubscriptionCreatedWebhookObject) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Describes changes to a subscription and the subscription status.
type SubscriptionEvent struct {
	// The ID of the subscription event.
	Id string `json:"id" url:"id"`
	// Type of the subscription event.
	// See [SubscriptionEventSubscriptionEventType](#type-subscriptioneventsubscriptioneventtype) for possible values
	SubscriptionEventType SubscriptionEventSubscriptionEventType `json:"subscription_event_type" url:"subscription_event_type"`
	// The `YYYY-MM-DD`-formatted date (for example, 2013-01-15) when the subscription event occurred.
	EffectiveDate string `json:"effective_date" url:"effective_date"`
	// The ID of the subscription plan associated with the subscription.
	PlanId string `json:"plan_id" url:"plan_id"`
	// Additional information about the subscription event.
	Info *SubscriptionEventInfo `json:"info,omitempty" url:"info,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *SubscriptionEvent) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SubscriptionEvent) UnmarshalJSON(data []byte) error {
	type unmarshaler SubscriptionEvent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SubscriptionEvent(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SubscriptionEvent) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Provides information about the subscription event.
type SubscriptionEventInfo struct {
	// A human-readable explanation for the event.
	Detail *string `json:"detail,omitempty" url:"detail,omitempty"`
	// An info code indicating the subscription event that occurred.
	// See [InfoCode](#type-infocode) for possible values
	Code *SubscriptionEventInfoCode `json:"code,omitempty" url:"code,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *SubscriptionEventInfo) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SubscriptionEventInfo) UnmarshalJSON(data []byte) error {
	type unmarshaler SubscriptionEventInfo
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SubscriptionEventInfo(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SubscriptionEventInfo) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Supported info codes of a subscription event.
type SubscriptionEventInfoCode string

const (
	SubscriptionEventInfoCodeLocationNotActive           SubscriptionEventInfoCode = "LOCATION_NOT_ACTIVE"
	SubscriptionEventInfoCodeLocationCannotAcceptPayment SubscriptionEventInfoCode = "LOCATION_CANNOT_ACCEPT_PAYMENT"
	SubscriptionEventInfoCodeCustomerDeleted             SubscriptionEventInfoCode = "CUSTOMER_DELETED"
	SubscriptionEventInfoCodeCustomerNoEmail             SubscriptionEventInfoCode = "CUSTOMER_NO_EMAIL"
	SubscriptionEventInfoCodeCustomerNoName              SubscriptionEventInfoCode = "CUSTOMER_NO_NAME"
	SubscriptionEventInfoCodeUserProvided                SubscriptionEventInfoCode = "USER_PROVIDED"
)

func NewSubscriptionEventInfoCodeFromString(s string) (SubscriptionEventInfoCode, error) {
	switch s {
	case "LOCATION_NOT_ACTIVE":
		return SubscriptionEventInfoCodeLocationNotActive, nil
	case "LOCATION_CANNOT_ACCEPT_PAYMENT":
		return SubscriptionEventInfoCodeLocationCannotAcceptPayment, nil
	case "CUSTOMER_DELETED":
		return SubscriptionEventInfoCodeCustomerDeleted, nil
	case "CUSTOMER_NO_EMAIL":
		return SubscriptionEventInfoCodeCustomerNoEmail, nil
	case "CUSTOMER_NO_NAME":
		return SubscriptionEventInfoCodeCustomerNoName, nil
	case "USER_PROVIDED":
		return SubscriptionEventInfoCodeUserProvided, nil
	}
	var t SubscriptionEventInfoCode
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s SubscriptionEventInfoCode) Ptr() *SubscriptionEventInfoCode {
	return &s
}

// Supported types of an event occurred to a subscription.
type SubscriptionEventSubscriptionEventType string

const (
	SubscriptionEventSubscriptionEventTypeDefaultSubscriptionEventTypeDoNotUse SubscriptionEventSubscriptionEventType = "DEFAULT_SUBSCRIPTION_EVENT_TYPE_DO_NOT_USE"
	SubscriptionEventSubscriptionEventTypeStartSubscription                    SubscriptionEventSubscriptionEventType = "START_SUBSCRIPTION"
	SubscriptionEventSubscriptionEventTypePlanChange                           SubscriptionEventSubscriptionEventType = "PLAN_CHANGE"
	SubscriptionEventSubscriptionEventTypeStopSubscription                     SubscriptionEventSubscriptionEventType = "STOP_SUBSCRIPTION"
	SubscriptionEventSubscriptionEventTypeDeactivateSubscription               SubscriptionEventSubscriptionEventType = "DEACTIVATE_SUBSCRIPTION"
	SubscriptionEventSubscriptionEventTypeResumeSubscription                   SubscriptionEventSubscriptionEventType = "RESUME_SUBSCRIPTION"
	SubscriptionEventSubscriptionEventTypePauseSubscription                    SubscriptionEventSubscriptionEventType = "PAUSE_SUBSCRIPTION"
)

func NewSubscriptionEventSubscriptionEventTypeFromString(s string) (SubscriptionEventSubscriptionEventType, error) {
	switch s {
	case "DEFAULT_SUBSCRIPTION_EVENT_TYPE_DO_NOT_USE":
		return SubscriptionEventSubscriptionEventTypeDefaultSubscriptionEventTypeDoNotUse, nil
	case "START_SUBSCRIPTION":
		return SubscriptionEventSubscriptionEventTypeStartSubscription, nil
	case "PLAN_CHANGE":
		return SubscriptionEventSubscriptionEventTypePlanChange, nil
	case "STOP_SUBSCRIPTION":
		return SubscriptionEventSubscriptionEventTypeStopSubscription, nil
	case "DEACTIVATE_SUBSCRIPTION":
		return SubscriptionEventSubscriptionEventTypeDeactivateSubscription, nil
	case "RESUME_SUBSCRIPTION":
		return SubscriptionEventSubscriptionEventTypeResumeSubscription, nil
	case "PAUSE_SUBSCRIPTION":
		return SubscriptionEventSubscriptionEventTypePauseSubscription, nil
	}
	var t SubscriptionEventSubscriptionEventType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s SubscriptionEventSubscriptionEventType) Ptr() *SubscriptionEventSubscriptionEventType {
	return &s
}

// Describes a phase in a subscription plan. For more information, see
// [Set Up and Manage a Subscription Plan](https://developer.squareup.com/docs/subscriptions-api/setup-plan).
type SubscriptionPhase struct {
	// The Square-assigned ID of the subscription phase. This field cannot be changed after a `SubscriptionPhase` is created.
	Uid *string `json:"uid,omitempty" url:"uid,omitempty"`
	// The billing cadence of the phase. For example, weekly or monthly. This field cannot be changed after a `SubscriptionPhase` is created.
	// See [SubscriptionCadence](#type-subscriptioncadence) for possible values
	Cadence SubscriptionCadence `json:"cadence" url:"cadence"`
	// The number of `cadence`s the phase lasts. If not set, the phase never ends. Only the last phase can be indefinite. This field cannot be changed after a `SubscriptionPhase` is created.
	Periods *int `json:"periods,omitempty" url:"periods,omitempty"`
	// The amount to bill for each `cadence`. Failure to specify this field results in a `MISSING_REQUIRED_PARAMETER` error at runtime.
	RecurringPriceMoney *Money `json:"recurring_price_money,omitempty" url:"recurring_price_money,omitempty"`
	// The position this phase appears in the sequence of phases defined for the plan, indexed from 0. This field cannot be changed after a `SubscriptionPhase` is created.
	Ordinal *int64 `json:"ordinal,omitempty" url:"ordinal,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *SubscriptionPhase) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SubscriptionPhase) UnmarshalJSON(data []byte) error {
	type unmarshaler SubscriptionPhase
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SubscriptionPhase(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SubscriptionPhase) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Supported subscription statuses.
type SubscriptionStatus string

const (
	SubscriptionStatusDefaultSubscriptionStatusDoNotUse SubscriptionStatus = "DEFAULT_SUBSCRIPTION_STATUS_DO_NOT_USE"
	SubscriptionStatusPending                           SubscriptionStatus = "PENDING"
	SubscriptionStatusActive                            SubscriptionStatus = "ACTIVE"
	SubscriptionStatusCanceled                          SubscriptionStatus = "CANCELED"
	SubscriptionStatusDeactivated                       SubscriptionStatus = "DEACTIVATED"
	SubscriptionStatusPaused                            SubscriptionStatus = "PAUSED"
)

func NewSubscriptionStatusFromString(s string) (SubscriptionStatus, error) {
	switch s {
	case "DEFAULT_SUBSCRIPTION_STATUS_DO_NOT_USE":
		return SubscriptionStatusDefaultSubscriptionStatusDoNotUse, nil
	case "PENDING":
		return SubscriptionStatusPending, nil
	case "ACTIVE":
		return SubscriptionStatusActive, nil
	case "CANCELED":
		return SubscriptionStatusCanceled, nil
	case "DEACTIVATED":
		return SubscriptionStatusDeactivated, nil
	case "PAUSED":
		return SubscriptionStatusPaused, nil
	}
	var t SubscriptionStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s SubscriptionStatus) Ptr() *SubscriptionStatus {
	return &s
}

// Represents the details of a webhook subscription, including notification URL,
// event types, and signature key.
type SubscriptionTestResult struct {
	// A Square-generated unique ID for the subscription test result.
	Id *string `json:"id,omitempty" url:"id,omitempty"`
	// The status code returned by the subscription notification URL.
	StatusCode *int `json:"status_code,omitempty" url:"status_code,omitempty"`
	// An object containing the payload of the test event. For example, a `payment.created` event.
	Payload *string `json:"payload,omitempty" url:"payload,omitempty"`
	// The timestamp of when the subscription was created, in RFC 3339 format.
	// For example, "2016-09-04T23:59:33.123Z".
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The timestamp of when the subscription was updated, in RFC 3339 format. For example, "2016-09-04T23:59:33.123Z".
	// Because a subscription test result is unique, this field is the same as the `created_at` field.
	UpdatedAt *string `json:"updated_at,omitempty" url:"updated_at,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *SubscriptionTestResult) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SubscriptionTestResult) UnmarshalJSON(data []byte) error {
	type unmarshaler SubscriptionTestResult
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SubscriptionTestResult(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SubscriptionTestResult) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Published when a [Subscription](entity:Subscription) is updated.
// Typically the `subscription.status` is updated as subscriptions become active
// or cancelled.
type SubscriptionUpdatedWebhook struct {
	// The ID of the target merchant associated with the event.
	MerchantId *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The type of event this represents, `"subscription.updated"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// A unique ID for the webhook event.
	EventId *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// Timestamp of when the webhook event was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// Data associated with the event.
	Data *SubscriptionUpdatedWebhookData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *SubscriptionUpdatedWebhook) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SubscriptionUpdatedWebhook) UnmarshalJSON(data []byte) error {
	type unmarshaler SubscriptionUpdatedWebhook
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SubscriptionUpdatedWebhook(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SubscriptionUpdatedWebhook) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SubscriptionUpdatedWebhookData struct {
	// Name of the affected object’s type, `"subscription"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// ID of the affected subscription.
	Id *string `json:"id,omitempty" url:"id,omitempty"`
	// An object containing the updated subscription.
	Object *SubscriptionUpdatedWebhookObject `json:"object,omitempty" url:"object,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *SubscriptionUpdatedWebhookData) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SubscriptionUpdatedWebhookData) UnmarshalJSON(data []byte) error {
	type unmarshaler SubscriptionUpdatedWebhookData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SubscriptionUpdatedWebhookData(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SubscriptionUpdatedWebhookData) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SubscriptionUpdatedWebhookObject struct {
	// The updated subscription.
	Subscription *Subscription `json:"subscription,omitempty" url:"subscription,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *SubscriptionUpdatedWebhookObject) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SubscriptionUpdatedWebhookObject) UnmarshalJSON(data []byte) error {
	type unmarshaler SubscriptionUpdatedWebhookObject
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SubscriptionUpdatedWebhookObject(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SubscriptionUpdatedWebhookObject) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// When to calculate the taxes due on a cart.
type TaxCalculationPhase string

const (
	TaxCalculationPhaseTaxSubtotalPhase TaxCalculationPhase = "TAX_SUBTOTAL_PHASE"
	TaxCalculationPhaseTaxTotalPhase    TaxCalculationPhase = "TAX_TOTAL_PHASE"
)

func NewTaxCalculationPhaseFromString(s string) (TaxCalculationPhase, error) {
	switch s {
	case "TAX_SUBTOTAL_PHASE":
		return TaxCalculationPhaseTaxSubtotalPhase, nil
	case "TAX_TOTAL_PHASE":
		return TaxCalculationPhaseTaxTotalPhase, nil
	}
	var t TaxCalculationPhase
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (t TaxCalculationPhase) Ptr() *TaxCalculationPhase {
	return &t
}

// Identifiers for the location used by various governments for tax purposes.
type TaxIds struct {
	// The EU VAT number for this location. For example, `IE3426675K`.
	// If the EU VAT number is present, it is well-formed and has been
	// validated with VIES, the VAT Information Exchange System.
	EuVat *string `json:"eu_vat,omitempty" url:"eu_vat,omitempty"`
	// The SIRET (Système d'Identification du Répertoire des Entreprises et de leurs Etablissements)
	// number is a 14-digit code issued by the French INSEE. For example, `39922799000021`.
	FrSiret *string `json:"fr_siret,omitempty" url:"fr_siret,omitempty"`
	// The French government uses the NAF (Nomenclature des Activités Françaises) to display and
	// track economic statistical data. This is also called the APE (Activite Principale de l’Entreprise) code.
	// For example, `6910Z`.
	FrNaf *string `json:"fr_naf,omitempty" url:"fr_naf,omitempty"`
	// The NIF (Numero de Identificacion Fiscal) number is a nine-character tax identifier used in Spain.
	// If it is present, it has been validated. For example, `73628495A`.
	EsNif *string `json:"es_nif,omitempty" url:"es_nif,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (t *TaxIds) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TaxIds) UnmarshalJSON(data []byte) error {
	type unmarshaler TaxIds
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TaxIds(value)

	extraProperties, err := core.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties

	t._rawJSON = json.RawMessage(data)
	return nil
}

func (t *TaxIds) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// Whether to the tax amount should be additional to or included in the CatalogItem price.
type TaxInclusionType string

const (
	TaxInclusionTypeAdditive  TaxInclusionType = "ADDITIVE"
	TaxInclusionTypeInclusive TaxInclusionType = "INCLUSIVE"
)

func NewTaxInclusionTypeFromString(s string) (TaxInclusionType, error) {
	switch s {
	case "ADDITIVE":
		return TaxInclusionTypeAdditive, nil
	case "INCLUSIVE":
		return TaxInclusionTypeInclusive, nil
	}
	var t TaxInclusionType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (t TaxInclusionType) Ptr() *TaxInclusionType {
	return &t
}

// A record representing an individual team member for a business.
type TeamMember struct {
	// The unique ID for the team member.
	Id *string `json:"id,omitempty" url:"id,omitempty"`
	// A second ID used to associate the team member with an entity in another system.
	ReferenceId *string `json:"reference_id,omitempty" url:"reference_id,omitempty"`
	// Whether the team member is the owner of the Square account.
	IsOwner *bool `json:"is_owner,omitempty" url:"is_owner,omitempty"`
	// Describes the status of the team member.
	// See [TeamMemberStatus](#type-teammemberstatus) for possible values
	Status *TeamMemberStatus `json:"status,omitempty" url:"status,omitempty"`
	// The given name (that is, the first name) associated with the team member.
	GivenName *string `json:"given_name,omitempty" url:"given_name,omitempty"`
	// The family name (that is, the last name) associated with the team member.
	FamilyName *string `json:"family_name,omitempty" url:"family_name,omitempty"`
	// The email address associated with the team member.
	EmailAddress *string `json:"email_address,omitempty" url:"email_address,omitempty"`
	// The team member's phone number, in E.164 format. For example:
	// +14155552671 - the country code is 1 for US
	// +551155256325 - the country code is 55 for BR
	PhoneNumber *string `json:"phone_number,omitempty" url:"phone_number,omitempty"`
	// The timestamp, in RFC 3339 format, describing when the team member was created.
	// For example, "2018-10-04T04:00:00-07:00" or "2019-02-05T12:00:00Z".
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The timestamp, in RFC 3339 format, describing when the team member was last updated.
	// For example, "2018-10-04T04:00:00-07:00" or "2019-02-05T12:00:00Z".
	UpdatedAt *string `json:"updated_at,omitempty" url:"updated_at,omitempty"`
	// Describes the team member's assigned locations.
	AssignedLocations *TeamMemberAssignedLocations `json:"assigned_locations,omitempty" url:"assigned_locations,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (t *TeamMember) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TeamMember) UnmarshalJSON(data []byte) error {
	type unmarshaler TeamMember
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TeamMember(value)

	extraProperties, err := core.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties

	t._rawJSON = json.RawMessage(data)
	return nil
}

func (t *TeamMember) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// An object that represents a team member's assignment to locations.
type TeamMemberAssignedLocations struct {
	// The current assignment type of the team member.
	// See [TeamMemberAssignedLocationsAssignmentType](#type-teammemberassignedlocationsassignmenttype) for possible values
	AssignmentType *TeamMemberAssignedLocationsAssignmentType `json:"assignment_type,omitempty" url:"assignment_type,omitempty"`
	// The locations that the team member is assigned to.
	LocationIds []string `json:"location_ids,omitempty" url:"location_ids,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (t *TeamMemberAssignedLocations) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TeamMemberAssignedLocations) UnmarshalJSON(data []byte) error {
	type unmarshaler TeamMemberAssignedLocations
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TeamMemberAssignedLocations(value)

	extraProperties, err := core.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties

	t._rawJSON = json.RawMessage(data)
	return nil
}

func (t *TeamMemberAssignedLocations) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// Enumerates the possible assignment types that the team member can have.
type TeamMemberAssignedLocationsAssignmentType string

const (
	TeamMemberAssignedLocationsAssignmentTypeDoNotUse                     TeamMemberAssignedLocationsAssignmentType = "DO_NOT_USE"
	TeamMemberAssignedLocationsAssignmentTypeAllCurrentAndFutureLocations TeamMemberAssignedLocationsAssignmentType = "ALL_CURRENT_AND_FUTURE_LOCATIONS"
	TeamMemberAssignedLocationsAssignmentTypeExplicitLocations            TeamMemberAssignedLocationsAssignmentType = "EXPLICIT_LOCATIONS"
)

func NewTeamMemberAssignedLocationsAssignmentTypeFromString(s string) (TeamMemberAssignedLocationsAssignmentType, error) {
	switch s {
	case "DO_NOT_USE":
		return TeamMemberAssignedLocationsAssignmentTypeDoNotUse, nil
	case "ALL_CURRENT_AND_FUTURE_LOCATIONS":
		return TeamMemberAssignedLocationsAssignmentTypeAllCurrentAndFutureLocations, nil
	case "EXPLICIT_LOCATIONS":
		return TeamMemberAssignedLocationsAssignmentTypeExplicitLocations, nil
	}
	var t TeamMemberAssignedLocationsAssignmentType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (t TeamMemberAssignedLocationsAssignmentType) Ptr() *TeamMemberAssignedLocationsAssignmentType {
	return &t
}

// The booking profile of a seller's team member, including the team member's ID, display name, description and whether the team member can be booked as a service provider.
type TeamMemberBookingProfile struct {
	// The ID of the [TeamMember](entity:TeamMember) object for the team member associated with the booking profile.
	TeamMemberId *string `json:"team_member_id,omitempty" url:"team_member_id,omitempty"`
	// The description of the team member.
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	// The display name of the team member.
	DisplayName *string `json:"display_name,omitempty" url:"display_name,omitempty"`
	// Indicates whether the team member can be booked through the Bookings API or the seller's online booking channel or site (`true) or not (`false`).
	IsBookable *bool `json:"is_bookable,omitempty" url:"is_bookable,omitempty"`
	// The URL of the team member's image for the bookings profile.
	ProfileImageUrl *string `json:"profile_image_url,omitempty" url:"profile_image_url,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (t *TeamMemberBookingProfile) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TeamMemberBookingProfile) UnmarshalJSON(data []byte) error {
	type unmarshaler TeamMemberBookingProfile
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TeamMemberBookingProfile(value)

	extraProperties, err := core.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties

	t._rawJSON = json.RawMessage(data)
	return nil
}

func (t *TeamMemberBookingProfile) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// Published when a Team Member is created.
type TeamMemberCreatedWebhook struct {
	// The ID of the target merchant associated with the event.
	MerchantId *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The type of event this represents, `"team_member.created"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// A unique ID for the webhook event.
	EventId *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// Timestamp of when the webhook event was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// Data associated with the event.
	Data *TeamMemberCreatedWebhookData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (t *TeamMemberCreatedWebhook) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TeamMemberCreatedWebhook) UnmarshalJSON(data []byte) error {
	type unmarshaler TeamMemberCreatedWebhook
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TeamMemberCreatedWebhook(value)

	extraProperties, err := core.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties

	t._rawJSON = json.RawMessage(data)
	return nil
}

func (t *TeamMemberCreatedWebhook) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type TeamMemberCreatedWebhookData struct {
	// Name of the affected object’s type, `"team_member"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// ID of the created team member.
	Id *string `json:"id,omitempty" url:"id,omitempty"`
	// An object containing the created team member.
	Object *TeamMemberCreatedWebhookObject `json:"object,omitempty" url:"object,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (t *TeamMemberCreatedWebhookData) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TeamMemberCreatedWebhookData) UnmarshalJSON(data []byte) error {
	type unmarshaler TeamMemberCreatedWebhookData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TeamMemberCreatedWebhookData(value)

	extraProperties, err := core.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties

	t._rawJSON = json.RawMessage(data)
	return nil
}

func (t *TeamMemberCreatedWebhookData) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type TeamMemberCreatedWebhookObject struct {
	// The created team member.
	TeamMember *TeamMember `json:"team_member,omitempty" url:"team_member,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (t *TeamMemberCreatedWebhookObject) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TeamMemberCreatedWebhookObject) UnmarshalJSON(data []byte) error {
	type unmarshaler TeamMemberCreatedWebhookObject
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TeamMemberCreatedWebhookObject(value)

	extraProperties, err := core.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties

	t._rawJSON = json.RawMessage(data)
	return nil
}

func (t *TeamMemberCreatedWebhookObject) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// Enumerates the possible invitation statuses the team member can have within a business.
type TeamMemberInvitationStatus string

const (
	TeamMemberInvitationStatusInvitationStatusDoNotUse TeamMemberInvitationStatus = "INVITATION_STATUS_DO_NOT_USE"
	TeamMemberInvitationStatusUninvited                TeamMemberInvitationStatus = "UNINVITED"
	TeamMemberInvitationStatusPending                  TeamMemberInvitationStatus = "PENDING"
	TeamMemberInvitationStatusAccepted                 TeamMemberInvitationStatus = "ACCEPTED"
)

func NewTeamMemberInvitationStatusFromString(s string) (TeamMemberInvitationStatus, error) {
	switch s {
	case "INVITATION_STATUS_DO_NOT_USE":
		return TeamMemberInvitationStatusInvitationStatusDoNotUse, nil
	case "UNINVITED":
		return TeamMemberInvitationStatusUninvited, nil
	case "PENDING":
		return TeamMemberInvitationStatusPending, nil
	case "ACCEPTED":
		return TeamMemberInvitationStatusAccepted, nil
	}
	var t TeamMemberInvitationStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (t TeamMemberInvitationStatus) Ptr() *TeamMemberInvitationStatus {
	return &t
}

// Enumerates the possible statuses the team member can have within a business.
type TeamMemberStatus string

const (
	TeamMemberStatusStatusDoNotUse TeamMemberStatus = "STATUS_DO_NOT_USE"
	TeamMemberStatusActive         TeamMemberStatus = "ACTIVE"
	TeamMemberStatusInactive       TeamMemberStatus = "INACTIVE"
)

func NewTeamMemberStatusFromString(s string) (TeamMemberStatus, error) {
	switch s {
	case "STATUS_DO_NOT_USE":
		return TeamMemberStatusStatusDoNotUse, nil
	case "ACTIVE":
		return TeamMemberStatusActive, nil
	case "INACTIVE":
		return TeamMemberStatusInactive, nil
	}
	var t TeamMemberStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (t TeamMemberStatus) Ptr() *TeamMemberStatus {
	return &t
}

// Published when a Team Member is updated.
type TeamMemberUpdatedWebhook struct {
	// The ID of the target merchant associated with the event.
	MerchantId *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The type of event this represents, `"team_member.updated"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// A unique ID for the webhook event.
	EventId *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// Timestamp of when the webhook event was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// Data associated with the event.
	Data *TeamMemberUpdatedWebhookData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (t *TeamMemberUpdatedWebhook) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TeamMemberUpdatedWebhook) UnmarshalJSON(data []byte) error {
	type unmarshaler TeamMemberUpdatedWebhook
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TeamMemberUpdatedWebhook(value)

	extraProperties, err := core.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties

	t._rawJSON = json.RawMessage(data)
	return nil
}

func (t *TeamMemberUpdatedWebhook) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type TeamMemberUpdatedWebhookData struct {
	// Name of the affected object’s type, `"team_member"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// ID of the affected team member.
	Id *string `json:"id,omitempty" url:"id,omitempty"`
	// An object containing the updated team member.
	Object *TeamMemberUpdatedWebhookObject `json:"object,omitempty" url:"object,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (t *TeamMemberUpdatedWebhookData) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TeamMemberUpdatedWebhookData) UnmarshalJSON(data []byte) error {
	type unmarshaler TeamMemberUpdatedWebhookData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TeamMemberUpdatedWebhookData(value)

	extraProperties, err := core.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties

	t._rawJSON = json.RawMessage(data)
	return nil
}

func (t *TeamMemberUpdatedWebhookData) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type TeamMemberUpdatedWebhookObject struct {
	// The updated team member.
	TeamMember *TeamMember `json:"team_member,omitempty" url:"team_member,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (t *TeamMemberUpdatedWebhookObject) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TeamMemberUpdatedWebhookObject) UnmarshalJSON(data []byte) error {
	type unmarshaler TeamMemberUpdatedWebhookObject
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TeamMemberUpdatedWebhookObject(value)

	extraProperties, err := core.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties

	t._rawJSON = json.RawMessage(data)
	return nil
}

func (t *TeamMemberUpdatedWebhookObject) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// The hourly wage rate that a team member earns on a `Shift` for doing the job
// specified by the `title` property of this object.
type TeamMemberWage struct {
	// The UUID for this object.
	Id *string `json:"id,omitempty" url:"id,omitempty"`
	// The `TeamMember` that this wage is assigned to.
	TeamMemberId *string `json:"team_member_id,omitempty" url:"team_member_id,omitempty"`
	// The job title that this wage relates to.
	Title *string `json:"title,omitempty" url:"title,omitempty"`
	// Can be a custom-set hourly wage or the calculated effective hourly
	// wage based on the annual wage and hours worked per week.
	HourlyRate *Money `json:"hourly_rate,omitempty" url:"hourly_rate,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (t *TeamMemberWage) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TeamMemberWage) UnmarshalJSON(data []byte) error {
	type unmarshaler TeamMemberWage
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TeamMemberWage(value)

	extraProperties, err := core.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties

	t._rawJSON = json.RawMessage(data)
	return nil
}

func (t *TeamMemberWage) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// Published when a Wage Setting is updated.
type TeamMemberWageSettingUpdatedWebhook struct {
	// The ID of the target merchant associated with the event.
	MerchantId *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The type of event this represents, `"team_member.wage_setting.updated"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// A unique ID for the webhook event.
	EventId *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// Timestamp of when the webhook event was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// Data associated with the event.
	Data *TeamMemberWageSettingUpdatedWebhookData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (t *TeamMemberWageSettingUpdatedWebhook) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TeamMemberWageSettingUpdatedWebhook) UnmarshalJSON(data []byte) error {
	type unmarshaler TeamMemberWageSettingUpdatedWebhook
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TeamMemberWageSettingUpdatedWebhook(value)

	extraProperties, err := core.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties

	t._rawJSON = json.RawMessage(data)
	return nil
}

func (t *TeamMemberWageSettingUpdatedWebhook) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type TeamMemberWageSettingUpdatedWebhookData struct {
	// Name of the affected object’s type, `"wage_setting"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// ID of the updated team member wage setting.
	Id *string `json:"id,omitempty" url:"id,omitempty"`
	// An object containing the updated team member wage setting.
	Object *TeamMemberWageSettingUpdatedWebhookObject `json:"object,omitempty" url:"object,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (t *TeamMemberWageSettingUpdatedWebhookData) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TeamMemberWageSettingUpdatedWebhookData) UnmarshalJSON(data []byte) error {
	type unmarshaler TeamMemberWageSettingUpdatedWebhookData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TeamMemberWageSettingUpdatedWebhookData(value)

	extraProperties, err := core.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties

	t._rawJSON = json.RawMessage(data)
	return nil
}

func (t *TeamMemberWageSettingUpdatedWebhookData) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type TeamMemberWageSettingUpdatedWebhookObject struct {
	// The updated team member wage setting.
	WageSetting *WageSetting `json:"wage_setting,omitempty" url:"wage_setting,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (t *TeamMemberWageSettingUpdatedWebhookObject) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TeamMemberWageSettingUpdatedWebhookObject) UnmarshalJSON(data []byte) error {
	type unmarshaler TeamMemberWageSettingUpdatedWebhookObject
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TeamMemberWageSettingUpdatedWebhookObject(value)

	extraProperties, err := core.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties

	t._rawJSON = json.RawMessage(data)
	return nil
}

func (t *TeamMemberWageSettingUpdatedWebhookObject) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// Represents a tender (i.e., a method of payment) used in a Square transaction.
type Tender struct {
	// The tender's unique ID. It is the associated payment ID.
	Id *string `json:"id,omitempty" url:"id,omitempty"`
	// The ID of the transaction's associated location.
	LocationId *string `json:"location_id,omitempty" url:"location_id,omitempty"`
	// The ID of the tender's associated transaction.
	TransactionId *string `json:"transaction_id,omitempty" url:"transaction_id,omitempty"`
	// The timestamp for when the tender was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// An optional note associated with the tender at the time of payment.
	Note *string `json:"note,omitempty" url:"note,omitempty"`
	// The total amount of the tender, including `tip_money`. If the tender has a `payment_id`,
	// the `total_money` of the corresponding [Payment](entity:Payment) will be equal to the
	// `amount_money` of the tender.
	AmountMoney *Money `json:"amount_money,omitempty" url:"amount_money,omitempty"`
	// The tip's amount of the tender.
	TipMoney *Money `json:"tip_money,omitempty" url:"tip_money,omitempty"`
	// The amount of any Square processing fees applied to the tender.
	//
	// This field is not immediately populated when a new transaction is created.
	// It is usually available after about ten seconds.
	ProcessingFeeMoney *Money `json:"processing_fee_money,omitempty" url:"processing_fee_money,omitempty"`
	// If the tender is associated with a customer or represents a customer's card on file,
	// this is the ID of the associated customer.
	CustomerId *string `json:"customer_id,omitempty" url:"customer_id,omitempty"`
	// The type of tender, such as `CARD` or `CASH`.
	// See [TenderType](#type-tendertype) for possible values
	Type TenderType `json:"type" url:"type"`
	// The details of the card tender.
	//
	// This value is present only if the value of `type` is `CARD`.
	CardDetails *TenderCardDetails `json:"card_details,omitempty" url:"card_details,omitempty"`
	// The details of the cash tender.
	//
	// This value is present only if the value of `type` is `CASH`.
	CashDetails *TenderCashDetails `json:"cash_details,omitempty" url:"cash_details,omitempty"`
	// Additional recipients (other than the merchant) receiving a portion of this tender.
	// For example, fees assessed on the purchase by a third party integration.
	AdditionalRecipients []*AdditionalRecipient `json:"additional_recipients,omitempty" url:"additional_recipients,omitempty"`
	// The ID of the [Payment](entity:Payment) that corresponds to this tender.
	// This value is only present for payments created with the v2 Payments API.
	PaymentId *string `json:"payment_id,omitempty" url:"payment_id,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (t *Tender) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *Tender) UnmarshalJSON(data []byte) error {
	type unmarshaler Tender
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = Tender(value)

	extraProperties, err := core.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties

	t._rawJSON = json.RawMessage(data)
	return nil
}

func (t *Tender) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// Represents additional details of a tender with `type` `CARD` or `SQUARE_GIFT_CARD`
type TenderCardDetails struct {
	// The credit card payment's current state (such as `AUTHORIZED` or
	// `CAPTURED`). See [TenderCardDetailsStatus](entity:TenderCardDetailsStatus)
	// for possible values.
	// See [TenderCardDetailsStatus](#type-tendercarddetailsstatus) for possible values
	Status *TenderCardDetailsStatus `json:"status,omitempty" url:"status,omitempty"`
	// The credit card's non-confidential details.
	Card *Card `json:"card,omitempty" url:"card,omitempty"`
	// The method used to enter the card's details for the transaction.
	// See [TenderCardDetailsEntryMethod](#type-tendercarddetailsentrymethod) for possible values
	EntryMethod *TenderCardDetailsEntryMethod `json:"entry_method,omitempty" url:"entry_method,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (t *TenderCardDetails) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TenderCardDetails) UnmarshalJSON(data []byte) error {
	type unmarshaler TenderCardDetails
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TenderCardDetails(value)

	extraProperties, err := core.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties

	t._rawJSON = json.RawMessage(data)
	return nil
}

func (t *TenderCardDetails) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// Indicates the method used to enter the card's details.
type TenderCardDetailsEntryMethod string

const (
	TenderCardDetailsEntryMethodSwiped      TenderCardDetailsEntryMethod = "SWIPED"
	TenderCardDetailsEntryMethodKeyed       TenderCardDetailsEntryMethod = "KEYED"
	TenderCardDetailsEntryMethodEmv         TenderCardDetailsEntryMethod = "EMV"
	TenderCardDetailsEntryMethodOnFile      TenderCardDetailsEntryMethod = "ON_FILE"
	TenderCardDetailsEntryMethodContactless TenderCardDetailsEntryMethod = "CONTACTLESS"
)

func NewTenderCardDetailsEntryMethodFromString(s string) (TenderCardDetailsEntryMethod, error) {
	switch s {
	case "SWIPED":
		return TenderCardDetailsEntryMethodSwiped, nil
	case "KEYED":
		return TenderCardDetailsEntryMethodKeyed, nil
	case "EMV":
		return TenderCardDetailsEntryMethodEmv, nil
	case "ON_FILE":
		return TenderCardDetailsEntryMethodOnFile, nil
	case "CONTACTLESS":
		return TenderCardDetailsEntryMethodContactless, nil
	}
	var t TenderCardDetailsEntryMethod
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (t TenderCardDetailsEntryMethod) Ptr() *TenderCardDetailsEntryMethod {
	return &t
}

// Indicates the card transaction's current status.
type TenderCardDetailsStatus string

const (
	TenderCardDetailsStatusAuthorized TenderCardDetailsStatus = "AUTHORIZED"
	TenderCardDetailsStatusCaptured   TenderCardDetailsStatus = "CAPTURED"
	TenderCardDetailsStatusVoided     TenderCardDetailsStatus = "VOIDED"
	TenderCardDetailsStatusFailed     TenderCardDetailsStatus = "FAILED"
)

func NewTenderCardDetailsStatusFromString(s string) (TenderCardDetailsStatus, error) {
	switch s {
	case "AUTHORIZED":
		return TenderCardDetailsStatusAuthorized, nil
	case "CAPTURED":
		return TenderCardDetailsStatusCaptured, nil
	case "VOIDED":
		return TenderCardDetailsStatusVoided, nil
	case "FAILED":
		return TenderCardDetailsStatusFailed, nil
	}
	var t TenderCardDetailsStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (t TenderCardDetailsStatus) Ptr() *TenderCardDetailsStatus {
	return &t
}

// Represents the details of a tender with `type` `CASH`.
type TenderCashDetails struct {
	// The total amount of cash provided by the buyer, before change is given.
	BuyerTenderedMoney *Money `json:"buyer_tendered_money,omitempty" url:"buyer_tendered_money,omitempty"`
	// The amount of change returned to the buyer.
	ChangeBackMoney *Money `json:"change_back_money,omitempty" url:"change_back_money,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (t *TenderCashDetails) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TenderCashDetails) UnmarshalJSON(data []byte) error {
	type unmarshaler TenderCashDetails
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TenderCashDetails(value)

	extraProperties, err := core.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties

	t._rawJSON = json.RawMessage(data)
	return nil
}

func (t *TenderCashDetails) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// Indicates a tender's type.
type TenderType string

const (
	TenderTypeCard             TenderType = "CARD"
	TenderTypeCash             TenderType = "CASH"
	TenderTypeThirdPartyCard   TenderType = "THIRD_PARTY_CARD"
	TenderTypeSquareGiftCard   TenderType = "SQUARE_GIFT_CARD"
	TenderTypeNoSale           TenderType = "NO_SALE"
	TenderTypeCheck            TenderType = "CHECK"
	TenderTypeMerchantGiftCard TenderType = "MERCHANT_GIFT_CARD"
	TenderTypeThirdPartyEMoney TenderType = "THIRD_PARTY_E_MONEY"
	TenderTypeBankAccount      TenderType = "BANK_ACCOUNT"
	TenderTypeWallet           TenderType = "WALLET"
	TenderTypeBuyNowPayLater   TenderType = "BUY_NOW_PAY_LATER"
	TenderTypeSquareAccount    TenderType = "SQUARE_ACCOUNT"
	TenderTypeOther            TenderType = "OTHER"
)

func NewTenderTypeFromString(s string) (TenderType, error) {
	switch s {
	case "CARD":
		return TenderTypeCard, nil
	case "CASH":
		return TenderTypeCash, nil
	case "THIRD_PARTY_CARD":
		return TenderTypeThirdPartyCard, nil
	case "SQUARE_GIFT_CARD":
		return TenderTypeSquareGiftCard, nil
	case "NO_SALE":
		return TenderTypeNoSale, nil
	case "CHECK":
		return TenderTypeCheck, nil
	case "MERCHANT_GIFT_CARD":
		return TenderTypeMerchantGiftCard, nil
	case "THIRD_PARTY_E_MONEY":
		return TenderTypeThirdPartyEMoney, nil
	case "BANK_ACCOUNT":
		return TenderTypeBankAccount, nil
	case "WALLET":
		return TenderTypeWallet, nil
	case "BUY_NOW_PAY_LATER":
		return TenderTypeBuyNowPayLater, nil
	case "SQUARE_ACCOUNT":
		return TenderTypeSquareAccount, nil
	case "OTHER":
		return TenderTypeOther, nil
	}
	var t TenderType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (t TenderType) Ptr() *TenderType {
	return &t
}

// Represents an action processed by the Square Terminal.
type TerminalAction struct {
	// A unique ID for this `TerminalAction`.
	Id *string `json:"id,omitempty" url:"id,omitempty"`
	// The unique Id of the device intended for this `TerminalAction`.
	// The Id can be retrieved from /v2/devices api.
	DeviceId *string `json:"device_id,omitempty" url:"device_id,omitempty"`
	// The duration as an RFC 3339 duration, after which the action will be automatically canceled.
	// TerminalActions that are `PENDING` will be automatically `CANCELED` and have a cancellation reason
	// of `TIMED_OUT`
	//
	// Default: 5 minutes from creation
	//
	// Maximum: 5 minutes
	DeadlineDuration *string `json:"deadline_duration,omitempty" url:"deadline_duration,omitempty"`
	// The status of the `TerminalAction`.
	// Options: `PENDING`, `IN_PROGRESS`, `CANCELED`, `COMPLETED`
	Status *string `json:"status,omitempty" url:"status,omitempty"`
	// The reason why `TerminalAction` is canceled. Present if the status is `CANCELED`.
	// See [ActionCancelReason](#type-actioncancelreason) for possible values
	CancelReason *ActionCancelReason `json:"cancel_reason,omitempty" url:"cancel_reason,omitempty"`
	// The time when the `TerminalAction` was created as an RFC 3339 timestamp.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The time when the `TerminalAction` was last updated as an RFC 3339 timestamp.
	UpdatedAt *string `json:"updated_at,omitempty" url:"updated_at,omitempty"`
	// The ID of the application that created the action.
	AppId *string `json:"app_id,omitempty" url:"app_id,omitempty"`
	// Represents the type of the action.
	// See [ActionType](#type-actiontype) for possible values
	Type *TerminalActionActionType `json:"type,omitempty" url:"type,omitempty"`
	// Describes configuration for the save-card action. Requires `SAVE_CARD` type.
	SaveCardOptions *SaveCardOptions `json:"save_card_options,omitempty" url:"save_card_options,omitempty"`
	// Details about the Terminal that received the action request (such as battery level,
	// operating system version, and network connection settings).
	//
	// Only available for `PING` action type.
	DeviceMetadata *DeviceMetadata `json:"device_metadata,omitempty" url:"device_metadata,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (t *TerminalAction) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TerminalAction) UnmarshalJSON(data []byte) error {
	type unmarshaler TerminalAction
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TerminalAction(value)

	extraProperties, err := core.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties

	t._rawJSON = json.RawMessage(data)
	return nil
}

func (t *TerminalAction) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// Describes the type of this unit and indicates which field contains the unit information. This is an ‘open’ enum.
type TerminalActionActionType string

const (
	TerminalActionActionTypeInvalidType           TerminalActionActionType = "INVALID_TYPE"
	TerminalActionActionTypeUnsupportedActionType TerminalActionActionType = "UNSUPPORTED_ACTION_TYPE"
	TerminalActionActionTypeCheckout              TerminalActionActionType = "CHECKOUT"
	TerminalActionActionTypeRefund                TerminalActionActionType = "REFUND"
	TerminalActionActionTypeQrCode                TerminalActionActionType = "QR_CODE"
	TerminalActionActionTypePing                  TerminalActionActionType = "PING"
	TerminalActionActionTypeSaveCard              TerminalActionActionType = "SAVE_CARD"
	TerminalActionActionTypeSignature             TerminalActionActionType = "SIGNATURE"
	TerminalActionActionTypeConfirmation          TerminalActionActionType = "CONFIRMATION"
	TerminalActionActionTypeReceipt               TerminalActionActionType = "RECEIPT"
	TerminalActionActionTypeDataCollection        TerminalActionActionType = "DATA_COLLECTION"
	TerminalActionActionTypeSelect                TerminalActionActionType = "SELECT"
)

func NewTerminalActionActionTypeFromString(s string) (TerminalActionActionType, error) {
	switch s {
	case "INVALID_TYPE":
		return TerminalActionActionTypeInvalidType, nil
	case "UNSUPPORTED_ACTION_TYPE":
		return TerminalActionActionTypeUnsupportedActionType, nil
	case "CHECKOUT":
		return TerminalActionActionTypeCheckout, nil
	case "REFUND":
		return TerminalActionActionTypeRefund, nil
	case "QR_CODE":
		return TerminalActionActionTypeQrCode, nil
	case "PING":
		return TerminalActionActionTypePing, nil
	case "SAVE_CARD":
		return TerminalActionActionTypeSaveCard, nil
	case "SIGNATURE":
		return TerminalActionActionTypeSignature, nil
	case "CONFIRMATION":
		return TerminalActionActionTypeConfirmation, nil
	case "RECEIPT":
		return TerminalActionActionTypeReceipt, nil
	case "DATA_COLLECTION":
		return TerminalActionActionTypeDataCollection, nil
	case "SELECT":
		return TerminalActionActionTypeSelect, nil
	}
	var t TerminalActionActionType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (t TerminalActionActionType) Ptr() *TerminalActionActionType {
	return &t
}

// Published when a TerminalAction is created.
type TerminalActionCreatedWebhook struct {
	// The ID of the target merchant associated with the event.
	MerchantId *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The type of event this represents, `"terminal.action.created"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// A unique ID for the webhook event.
	EventId *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// RFC 3339 timestamp of when the webhook event was created.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// Data associated with the event.
	Data *TerminalActionCreatedWebhookData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (t *TerminalActionCreatedWebhook) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TerminalActionCreatedWebhook) UnmarshalJSON(data []byte) error {
	type unmarshaler TerminalActionCreatedWebhook
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TerminalActionCreatedWebhook(value)

	extraProperties, err := core.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties

	t._rawJSON = json.RawMessage(data)
	return nil
}

func (t *TerminalActionCreatedWebhook) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type TerminalActionCreatedWebhookData struct {
	// Name of the created object’s type, `"terminal.action"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// ID of the created terminal action.
	Id *string `json:"id,omitempty" url:"id,omitempty"`
	// An object containing the created terminal action.
	Object *TerminalActionCreatedWebhookObject `json:"object,omitempty" url:"object,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (t *TerminalActionCreatedWebhookData) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TerminalActionCreatedWebhookData) UnmarshalJSON(data []byte) error {
	type unmarshaler TerminalActionCreatedWebhookData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TerminalActionCreatedWebhookData(value)

	extraProperties, err := core.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties

	t._rawJSON = json.RawMessage(data)
	return nil
}

func (t *TerminalActionCreatedWebhookData) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type TerminalActionCreatedWebhookObject struct {
	// The created terminal action.
	Action *TerminalAction `json:"action,omitempty" url:"action,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (t *TerminalActionCreatedWebhookObject) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TerminalActionCreatedWebhookObject) UnmarshalJSON(data []byte) error {
	type unmarshaler TerminalActionCreatedWebhookObject
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TerminalActionCreatedWebhookObject(value)

	extraProperties, err := core.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties

	t._rawJSON = json.RawMessage(data)
	return nil
}

func (t *TerminalActionCreatedWebhookObject) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type TerminalActionQuery struct {
	// Options for filtering returned `TerminalAction`s
	Filter *TerminalActionQueryFilter `json:"filter,omitempty" url:"filter,omitempty"`
	// Option for sorting returned `TerminalAction` objects.
	Sort *TerminalActionQuerySort `json:"sort,omitempty" url:"sort,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (t *TerminalActionQuery) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TerminalActionQuery) UnmarshalJSON(data []byte) error {
	type unmarshaler TerminalActionQuery
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TerminalActionQuery(value)

	extraProperties, err := core.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties

	t._rawJSON = json.RawMessage(data)
	return nil
}

func (t *TerminalActionQuery) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type TerminalActionQueryFilter struct {
	// `TerminalAction`s associated with a specific device. If no device is specified then all
	// `TerminalAction`s for the merchant will be displayed.
	DeviceId *string `json:"device_id,omitempty" url:"device_id,omitempty"`
	// Time range for the beginning of the reporting period. Inclusive.
	// Default value: The current time minus one day.
	// Note that `TerminalAction`s are available for 30 days after creation.
	CreatedAt *TimeRange `json:"created_at,omitempty" url:"created_at,omitempty"`
	// Filter results with the desired status of the `TerminalAction`
	// Options: PENDING, IN_PROGRESS, CANCELED, COMPLETED
	Status *string `json:"status,omitempty" url:"status,omitempty"`
	// Filter results with the requested ActionType.
	// See [TerminalActionActionType](#type-terminalactionactiontype) for possible values
	Type *TerminalActionActionType `json:"type,omitempty" url:"type,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (t *TerminalActionQueryFilter) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TerminalActionQueryFilter) UnmarshalJSON(data []byte) error {
	type unmarshaler TerminalActionQueryFilter
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TerminalActionQueryFilter(value)

	extraProperties, err := core.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties

	t._rawJSON = json.RawMessage(data)
	return nil
}

func (t *TerminalActionQueryFilter) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type TerminalActionQuerySort struct {
	// The order in which results are listed.
	//
	//   - `ASC` - Oldest to newest.
	//   - `DESC` - Newest to oldest (default).
	//     See [SortOrder](#type-sortorder) for possible values
	SortOrder *SortOrder `json:"sort_order,omitempty" url:"sort_order,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (t *TerminalActionQuerySort) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TerminalActionQuerySort) UnmarshalJSON(data []byte) error {
	type unmarshaler TerminalActionQuerySort
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TerminalActionQuerySort(value)

	extraProperties, err := core.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties

	t._rawJSON = json.RawMessage(data)
	return nil
}

func (t *TerminalActionQuerySort) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// Published when a TerminalAction is updated.
type TerminalActionUpdatedWebhook struct {
	// The ID of the target merchant associated with the event.
	MerchantId *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The type of event this represents, `"terminal.action.updated"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// A unique ID for the webhook event.
	EventId *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// RFC 3339 timestamp of when the webhook event was created.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// Data associated with the event.
	Data *TerminalActionUpdatedWebhookData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (t *TerminalActionUpdatedWebhook) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TerminalActionUpdatedWebhook) UnmarshalJSON(data []byte) error {
	type unmarshaler TerminalActionUpdatedWebhook
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TerminalActionUpdatedWebhook(value)

	extraProperties, err := core.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties

	t._rawJSON = json.RawMessage(data)
	return nil
}

func (t *TerminalActionUpdatedWebhook) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type TerminalActionUpdatedWebhookData struct {
	// Name of the updated object’s type, `"terminal.action"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// ID of the updated terminal action.
	Id *string `json:"id,omitempty" url:"id,omitempty"`
	// An object containing the updated terminal action.
	Object *TerminalActionUpdatedWebhookObject `json:"object,omitempty" url:"object,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (t *TerminalActionUpdatedWebhookData) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TerminalActionUpdatedWebhookData) UnmarshalJSON(data []byte) error {
	type unmarshaler TerminalActionUpdatedWebhookData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TerminalActionUpdatedWebhookData(value)

	extraProperties, err := core.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties

	t._rawJSON = json.RawMessage(data)
	return nil
}

func (t *TerminalActionUpdatedWebhookData) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type TerminalActionUpdatedWebhookObject struct {
	// The updated terminal action.
	Action *TerminalAction `json:"action,omitempty" url:"action,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (t *TerminalActionUpdatedWebhookObject) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TerminalActionUpdatedWebhookObject) UnmarshalJSON(data []byte) error {
	type unmarshaler TerminalActionUpdatedWebhookObject
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TerminalActionUpdatedWebhookObject(value)

	extraProperties, err := core.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties

	t._rawJSON = json.RawMessage(data)
	return nil
}

func (t *TerminalActionUpdatedWebhookObject) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// Represents a checkout processed by the Square Terminal.
type TerminalCheckout struct {
	// A unique ID for this `TerminalCheckout`.
	Id *string `json:"id,omitempty" url:"id,omitempty"`
	// The amount of money (including the tax amount) that the Square Terminal device should try to collect.
	AmountMoney *Money `json:"amount_money,omitempty" url:"amount_money,omitempty"`
	// An optional user-defined reference ID that can be used to associate
	// this `TerminalCheckout` to another entity in an external system. For example, an order
	// ID generated by a third-party shopping cart. The ID is also associated with any payments
	// used to complete the checkout.
	ReferenceId *string `json:"reference_id,omitempty" url:"reference_id,omitempty"`
	// An optional note to associate with the checkout, as well as with any payments used to complete the checkout.
	// Note: maximum 500 characters
	Note *string `json:"note,omitempty" url:"note,omitempty"`
	// The reference to the Square order ID for the checkout request. Supported only in the US.
	OrderId *string `json:"order_id,omitempty" url:"order_id,omitempty"`
	// Payment-specific options for the checkout request. Supported only in the US.
	PaymentOptions *PaymentOptions `json:"payment_options,omitempty" url:"payment_options,omitempty"`
	// Options to control the display and behavior of the Square Terminal device.
	DeviceOptions *DeviceCheckoutOptions `json:"device_options,omitempty" url:"device_options,omitempty"`
	// An RFC 3339 duration, after which the checkout is automatically canceled.
	// A `TerminalCheckout` that is `PENDING` is automatically `CANCELED` and has a cancellation reason
	// of `TIMED_OUT`.
	//
	// Default: 5 minutes from creation
	//
	// Maximum: 5 minutes
	DeadlineDuration *string `json:"deadline_duration,omitempty" url:"deadline_duration,omitempty"`
	// The status of the `TerminalCheckout`.
	// Options: `PENDING`, `IN_PROGRESS`, `CANCEL_REQUESTED`, `CANCELED`, `COMPLETED`
	Status *string `json:"status,omitempty" url:"status,omitempty"`
	// The reason why `TerminalCheckout` is canceled. Present if the status is `CANCELED`.
	// See [ActionCancelReason](#type-actioncancelreason) for possible values
	CancelReason *ActionCancelReason `json:"cancel_reason,omitempty" url:"cancel_reason,omitempty"`
	// A list of IDs for payments created by this `TerminalCheckout`.
	PaymentIds []string `json:"payment_ids,omitempty" url:"payment_ids,omitempty"`
	// The time when the `TerminalCheckout` was created, as an RFC 3339 timestamp.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The time when the `TerminalCheckout` was last updated, as an RFC 3339 timestamp.
	UpdatedAt *string `json:"updated_at,omitempty" url:"updated_at,omitempty"`
	// The ID of the application that created the checkout.
	AppId *string `json:"app_id,omitempty" url:"app_id,omitempty"`
	// The location of the device where the `TerminalCheckout` was directed.
	LocationId *string `json:"location_id,omitempty" url:"location_id,omitempty"`
	// The type of payment the terminal should attempt to capture from. Defaults to `CARD_PRESENT`.
	// See [CheckoutOptionsPaymentType](#type-checkoutoptionspaymenttype) for possible values
	PaymentType *CheckoutOptionsPaymentType `json:"payment_type,omitempty" url:"payment_type,omitempty"`
	// An optional ID of the customer associated with the checkout.
	CustomerId *string `json:"customer_id,omitempty" url:"customer_id,omitempty"`
	// The amount the developer is taking as a fee for facilitating the payment on behalf
	// of the seller.
	//
	// The amount cannot be more than 90% of the total amount of the payment.
	//
	// The amount must be specified in the smallest denomination of the applicable currency (for example, US dollar amounts are specified in cents). For more information, see [Working with Monetary Amounts](https://developer.squareup.com/docs/build-basics/working-with-monetary-amounts).
	//
	// The fee currency code must match the currency associated with the seller that is accepting the payment. The application must be from a developer account in the same country and using the same currency code as the seller.
	//
	// For more information about the application fee scenario, see [Take Payments and Collect Fees](https://developer.squareup.com/docs/payments-api/take-payments-and-collect-fees).
	//
	// To set this field, PAYMENTS_WRITE_ADDITIONAL_RECIPIENTS OAuth permission is required. For more information, see [Permissions](https://developer.squareup.com/docs/payments-api/take-payments-and-collect-fees#permissions).
	//
	// Supported only in the US.
	AppFeeMoney *Money `json:"app_fee_money,omitempty" url:"app_fee_money,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (t *TerminalCheckout) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TerminalCheckout) UnmarshalJSON(data []byte) error {
	type unmarshaler TerminalCheckout
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TerminalCheckout(value)

	extraProperties, err := core.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties

	t._rawJSON = json.RawMessage(data)
	return nil
}

func (t *TerminalCheckout) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// Published when a [TerminalCheckout](entity:TerminalCheckout) is created.
type TerminalCheckoutCreatedWebhook struct {
	// The ID of the target merchant associated with the event.
	MerchantId *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The type of event this represents, `"terminal.checkout.created"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// A unique ID for the webhook event.
	EventId *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// RFC 3339 timestamp of when the webhook event was created.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// Data associated with the event.
	Data *TerminalCheckoutCreatedWebhookData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (t *TerminalCheckoutCreatedWebhook) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TerminalCheckoutCreatedWebhook) UnmarshalJSON(data []byte) error {
	type unmarshaler TerminalCheckoutCreatedWebhook
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TerminalCheckoutCreatedWebhook(value)

	extraProperties, err := core.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties

	t._rawJSON = json.RawMessage(data)
	return nil
}

func (t *TerminalCheckoutCreatedWebhook) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type TerminalCheckoutCreatedWebhookData struct {
	// Name of the created object’s type, `"terminal.checkout"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// ID of the created terminal checkout.
	Id *string `json:"id,omitempty" url:"id,omitempty"`
	// An object containing the created terminal checkout
	Object *TerminalCheckoutCreatedWebhookObject `json:"object,omitempty" url:"object,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (t *TerminalCheckoutCreatedWebhookData) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TerminalCheckoutCreatedWebhookData) UnmarshalJSON(data []byte) error {
	type unmarshaler TerminalCheckoutCreatedWebhookData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TerminalCheckoutCreatedWebhookData(value)

	extraProperties, err := core.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties

	t._rawJSON = json.RawMessage(data)
	return nil
}

func (t *TerminalCheckoutCreatedWebhookData) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type TerminalCheckoutCreatedWebhookObject struct {
	// The created terminal checkout
	Checkout *TerminalCheckout `json:"checkout,omitempty" url:"checkout,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (t *TerminalCheckoutCreatedWebhookObject) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TerminalCheckoutCreatedWebhookObject) UnmarshalJSON(data []byte) error {
	type unmarshaler TerminalCheckoutCreatedWebhookObject
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TerminalCheckoutCreatedWebhookObject(value)

	extraProperties, err := core.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties

	t._rawJSON = json.RawMessage(data)
	return nil
}

func (t *TerminalCheckoutCreatedWebhookObject) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type TerminalCheckoutQuery struct {
	// Options for filtering returned `TerminalCheckout` objects.
	Filter *TerminalCheckoutQueryFilter `json:"filter,omitempty" url:"filter,omitempty"`
	// Option for sorting returned `TerminalCheckout` objects.
	Sort *TerminalCheckoutQuerySort `json:"sort,omitempty" url:"sort,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (t *TerminalCheckoutQuery) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TerminalCheckoutQuery) UnmarshalJSON(data []byte) error {
	type unmarshaler TerminalCheckoutQuery
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TerminalCheckoutQuery(value)

	extraProperties, err := core.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties

	t._rawJSON = json.RawMessage(data)
	return nil
}

func (t *TerminalCheckoutQuery) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type TerminalCheckoutQueryFilter struct {
	// The `TerminalCheckout` objects associated with a specific device. If no device is specified, then all
	// `TerminalCheckout` objects for the merchant are displayed.
	DeviceId *string `json:"device_id,omitempty" url:"device_id,omitempty"`
	// The time range for the beginning of the reporting period, which is inclusive.
	// Default value: The current time minus one day.
	// Note that `TerminalCheckout`s are available for 30 days after creation.
	CreatedAt *TimeRange `json:"created_at,omitempty" url:"created_at,omitempty"`
	// Filtered results with the desired status of the `TerminalCheckout`.
	// Options: PENDING, IN_PROGRESS, CANCELED, COMPLETED
	Status *string `json:"status,omitempty" url:"status,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (t *TerminalCheckoutQueryFilter) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TerminalCheckoutQueryFilter) UnmarshalJSON(data []byte) error {
	type unmarshaler TerminalCheckoutQueryFilter
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TerminalCheckoutQueryFilter(value)

	extraProperties, err := core.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties

	t._rawJSON = json.RawMessage(data)
	return nil
}

func (t *TerminalCheckoutQueryFilter) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type TerminalCheckoutQuerySort struct {
	// The order in which results are listed.
	// Default: `DESC`
	// See [SortOrder](#type-sortorder) for possible values
	SortOrder *SortOrder `json:"sort_order,omitempty" url:"sort_order,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (t *TerminalCheckoutQuerySort) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TerminalCheckoutQuerySort) UnmarshalJSON(data []byte) error {
	type unmarshaler TerminalCheckoutQuerySort
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TerminalCheckoutQuerySort(value)

	extraProperties, err := core.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties

	t._rawJSON = json.RawMessage(data)
	return nil
}

func (t *TerminalCheckoutQuerySort) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// Published when a [TerminalCheckout](entity:TerminalCheckout) is updated.
type TerminalCheckoutUpdatedWebhook struct {
	// The ID of the target merchant associated with the event.
	MerchantId *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The type of event this represents, `"terminal.checkout.updated"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// A unique ID for the webhook event.
	EventId *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// RFC 3339 timestamp of when the webhook event was created.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// Data associated with the event.
	Data *TerminalCheckoutUpdatedWebhookData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (t *TerminalCheckoutUpdatedWebhook) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TerminalCheckoutUpdatedWebhook) UnmarshalJSON(data []byte) error {
	type unmarshaler TerminalCheckoutUpdatedWebhook
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TerminalCheckoutUpdatedWebhook(value)

	extraProperties, err := core.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties

	t._rawJSON = json.RawMessage(data)
	return nil
}

func (t *TerminalCheckoutUpdatedWebhook) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type TerminalCheckoutUpdatedWebhookData struct {
	// Name of the updated object’s type, `"terminal.checkout"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// ID of the updated terminal checkout.
	Id *string `json:"id,omitempty" url:"id,omitempty"`
	// An object containing the updated terminal checkout
	Object *TerminalCheckoutUpdatedWebhookObject `json:"object,omitempty" url:"object,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (t *TerminalCheckoutUpdatedWebhookData) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TerminalCheckoutUpdatedWebhookData) UnmarshalJSON(data []byte) error {
	type unmarshaler TerminalCheckoutUpdatedWebhookData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TerminalCheckoutUpdatedWebhookData(value)

	extraProperties, err := core.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties

	t._rawJSON = json.RawMessage(data)
	return nil
}

func (t *TerminalCheckoutUpdatedWebhookData) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type TerminalCheckoutUpdatedWebhookObject struct {
	// The updated terminal checkout
	Checkout *TerminalCheckout `json:"checkout,omitempty" url:"checkout,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (t *TerminalCheckoutUpdatedWebhookObject) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TerminalCheckoutUpdatedWebhookObject) UnmarshalJSON(data []byte) error {
	type unmarshaler TerminalCheckoutUpdatedWebhookObject
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TerminalCheckoutUpdatedWebhookObject(value)

	extraProperties, err := core.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties

	t._rawJSON = json.RawMessage(data)
	return nil
}

func (t *TerminalCheckoutUpdatedWebhookObject) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// Represents a payment refund processed by the Square Terminal. Only supports Interac (Canadian debit network) payment refunds.
type TerminalRefund struct {
	// A unique ID for this `TerminalRefund`.
	Id *string `json:"id,omitempty" url:"id,omitempty"`
	// The reference to the payment refund created by completing this `TerminalRefund`.
	RefundId *string `json:"refund_id,omitempty" url:"refund_id,omitempty"`
	// The unique ID of the payment being refunded.
	PaymentId string `json:"payment_id" url:"payment_id"`
	// The reference to the Square order ID for the payment identified by the `payment_id`.
	OrderId *string `json:"order_id,omitempty" url:"order_id,omitempty"`
	// The amount of money, inclusive of `tax_money`, that the `TerminalRefund` should return.
	// This value is limited to the amount taken in the original payment minus any completed or
	// pending refunds.
	AmountMoney *Money `json:"amount_money,omitempty" url:"amount_money,omitempty"`
	// A description of the reason for the refund.
	Reason string `json:"reason" url:"reason"`
	// The unique ID of the device intended for this `TerminalRefund`.
	// The Id can be retrieved from /v2/devices api.
	DeviceId string `json:"device_id" url:"device_id"`
	// The RFC 3339 duration, after which the refund is automatically canceled.
	// A `TerminalRefund` that is `PENDING` is automatically `CANCELED` and has a cancellation reason
	// of `TIMED_OUT`.
	//
	// Default: 5 minutes from creation.
	//
	// Maximum: 5 minutes
	DeadlineDuration *string `json:"deadline_duration,omitempty" url:"deadline_duration,omitempty"`
	// The status of the `TerminalRefund`.
	// Options: `PENDING`, `IN_PROGRESS`, `CANCEL_REQUESTED`, `CANCELED`, or `COMPLETED`.
	Status *string `json:"status,omitempty" url:"status,omitempty"`
	// Present if the status is `CANCELED`.
	// See [ActionCancelReason](#type-actioncancelreason) for possible values
	CancelReason *ActionCancelReason `json:"cancel_reason,omitempty" url:"cancel_reason,omitempty"`
	// The time when the `TerminalRefund` was created, as an RFC 3339 timestamp.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The time when the `TerminalRefund` was last updated, as an RFC 3339 timestamp.
	UpdatedAt *string `json:"updated_at,omitempty" url:"updated_at,omitempty"`
	// The ID of the application that created the refund.
	AppId *string `json:"app_id,omitempty" url:"app_id,omitempty"`
	// The location of the device where the `TerminalRefund` was directed.
	LocationId *string `json:"location_id,omitempty" url:"location_id,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (t *TerminalRefund) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TerminalRefund) UnmarshalJSON(data []byte) error {
	type unmarshaler TerminalRefund
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TerminalRefund(value)

	extraProperties, err := core.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties

	t._rawJSON = json.RawMessage(data)
	return nil
}

func (t *TerminalRefund) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// Published when a Terminal API refund is created.
type TerminalRefundCreatedWebhook struct {
	// The ID of the target merchant associated with the event.
	MerchantId *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The type of event this represents, `"terminal.refund.created"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// A unique ID for the webhook event.
	EventId *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// RFC 3339 timestamp of when the webhook event was created.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// Data associated with the event.
	Data *TerminalRefundCreatedWebhookData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (t *TerminalRefundCreatedWebhook) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TerminalRefundCreatedWebhook) UnmarshalJSON(data []byte) error {
	type unmarshaler TerminalRefundCreatedWebhook
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TerminalRefundCreatedWebhook(value)

	extraProperties, err := core.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties

	t._rawJSON = json.RawMessage(data)
	return nil
}

func (t *TerminalRefundCreatedWebhook) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type TerminalRefundCreatedWebhookData struct {
	// Name of the created object’s type, `"terminal.refund"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// ID of the created terminal refund.
	Id *string `json:"id,omitempty" url:"id,omitempty"`
	// An object containing the created terminal refund.
	Object *TerminalRefundCreatedWebhookObject `json:"object,omitempty" url:"object,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (t *TerminalRefundCreatedWebhookData) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TerminalRefundCreatedWebhookData) UnmarshalJSON(data []byte) error {
	type unmarshaler TerminalRefundCreatedWebhookData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TerminalRefundCreatedWebhookData(value)

	extraProperties, err := core.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties

	t._rawJSON = json.RawMessage(data)
	return nil
}

func (t *TerminalRefundCreatedWebhookData) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type TerminalRefundCreatedWebhookObject struct {
	// The created terminal refund.
	Refund *TerminalRefund `json:"refund,omitempty" url:"refund,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (t *TerminalRefundCreatedWebhookObject) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TerminalRefundCreatedWebhookObject) UnmarshalJSON(data []byte) error {
	type unmarshaler TerminalRefundCreatedWebhookObject
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TerminalRefundCreatedWebhookObject(value)

	extraProperties, err := core.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties

	t._rawJSON = json.RawMessage(data)
	return nil
}

func (t *TerminalRefundCreatedWebhookObject) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type TerminalRefundQuery struct {
	// The filter for the Terminal refund query.
	Filter *TerminalRefundQueryFilter `json:"filter,omitempty" url:"filter,omitempty"`
	// The sort order for the Terminal refund query.
	Sort *TerminalRefundQuerySort `json:"sort,omitempty" url:"sort,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (t *TerminalRefundQuery) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TerminalRefundQuery) UnmarshalJSON(data []byte) error {
	type unmarshaler TerminalRefundQuery
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TerminalRefundQuery(value)

	extraProperties, err := core.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties

	t._rawJSON = json.RawMessage(data)
	return nil
}

func (t *TerminalRefundQuery) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type TerminalRefundQueryFilter struct {
	// `TerminalRefund` objects associated with a specific device. If no device is specified, then all
	// `TerminalRefund` objects for the signed-in account are displayed.
	DeviceId *string `json:"device_id,omitempty" url:"device_id,omitempty"`
	// The timestamp for the beginning of the reporting period, in RFC 3339 format. Inclusive.
	// Default value: The current time minus one day.
	// Note that `TerminalRefund`s are available for 30 days after creation.
	CreatedAt *TimeRange `json:"created_at,omitempty" url:"created_at,omitempty"`
	// Filtered results with the desired status of the `TerminalRefund`.
	// Options: `PENDING`, `IN_PROGRESS`, `CANCEL_REQUESTED`, `CANCELED`, or `COMPLETED`.
	Status *string `json:"status,omitempty" url:"status,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (t *TerminalRefundQueryFilter) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TerminalRefundQueryFilter) UnmarshalJSON(data []byte) error {
	type unmarshaler TerminalRefundQueryFilter
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TerminalRefundQueryFilter(value)

	extraProperties, err := core.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties

	t._rawJSON = json.RawMessage(data)
	return nil
}

func (t *TerminalRefundQueryFilter) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type TerminalRefundQuerySort struct {
	// The order in which results are listed.
	//
	// - `ASC` - Oldest to newest.
	// - `DESC` - Newest to oldest (default).
	SortOrder *string `json:"sort_order,omitempty" url:"sort_order,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (t *TerminalRefundQuerySort) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TerminalRefundQuerySort) UnmarshalJSON(data []byte) error {
	type unmarshaler TerminalRefundQuerySort
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TerminalRefundQuerySort(value)

	extraProperties, err := core.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties

	t._rawJSON = json.RawMessage(data)
	return nil
}

func (t *TerminalRefundQuerySort) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// Published when a Terminal API refund is updated.
type TerminalRefundUpdatedWebhook struct {
	// The ID of the target merchant associated with the event.
	MerchantId *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The type of event this represents, `"terminal.refund.updated"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// A unique ID for the webhook event.
	EventId *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// RFC 3339 timestamp of when the webhook event was created.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// Data associated with the event.
	Data *TerminalRefundUpdatedWebhookData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (t *TerminalRefundUpdatedWebhook) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TerminalRefundUpdatedWebhook) UnmarshalJSON(data []byte) error {
	type unmarshaler TerminalRefundUpdatedWebhook
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TerminalRefundUpdatedWebhook(value)

	extraProperties, err := core.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties

	t._rawJSON = json.RawMessage(data)
	return nil
}

func (t *TerminalRefundUpdatedWebhook) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type TerminalRefundUpdatedWebhookData struct {
	// Name of the updated object’s type, `"terminal.refund"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// ID of the updated terminal refund.
	Id *string `json:"id,omitempty" url:"id,omitempty"`
	// An object containing the updated terminal refund.
	Object *TerminalRefundUpdatedWebhookObject `json:"object,omitempty" url:"object,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (t *TerminalRefundUpdatedWebhookData) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TerminalRefundUpdatedWebhookData) UnmarshalJSON(data []byte) error {
	type unmarshaler TerminalRefundUpdatedWebhookData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TerminalRefundUpdatedWebhookData(value)

	extraProperties, err := core.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties

	t._rawJSON = json.RawMessage(data)
	return nil
}

func (t *TerminalRefundUpdatedWebhookData) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type TerminalRefundUpdatedWebhookObject struct {
	// The updated terminal refund.
	Refund *TerminalRefund `json:"refund,omitempty" url:"refund,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (t *TerminalRefundUpdatedWebhookObject) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TerminalRefundUpdatedWebhookObject) UnmarshalJSON(data []byte) error {
	type unmarshaler TerminalRefundUpdatedWebhookObject
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TerminalRefundUpdatedWebhookObject(value)

	extraProperties, err := core.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties

	t._rawJSON = json.RawMessage(data)
	return nil
}

func (t *TerminalRefundUpdatedWebhookObject) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// Defines the fields that are included in the response body of
// a request to the [TestWebhookSubscription](api-endpoint:WebhookSubscriptions-TestWebhookSubscription) endpoint.
//
// Note: If there are errors processing the request, the [SubscriptionTestResult](entity:SubscriptionTestResult) field is not
// present.
type TestWebhookSubscriptionResponse struct {
	// Information on errors encountered during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The [SubscriptionTestResult](entity:SubscriptionTestResult).
	SubscriptionTestResult *SubscriptionTestResult `json:"subscription_test_result,omitempty" url:"subscription_test_result,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (t *TestWebhookSubscriptionResponse) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TestWebhookSubscriptionResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler TestWebhookSubscriptionResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TestWebhookSubscriptionResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties

	t._rawJSON = json.RawMessage(data)
	return nil
}

func (t *TestWebhookSubscriptionResponse) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// Represents a generic time range. The start and end values are
// represented in RFC 3339 format. Time ranges are customized to be
// inclusive or exclusive based on the needs of a particular endpoint.
// Refer to the relevant endpoint-specific documentation to determine
// how time ranges are handled.
type TimeRange struct {
	// A datetime value in RFC 3339 format indicating when the time range
	// starts.
	StartAt *string `json:"start_at,omitempty" url:"start_at,omitempty"`
	// A datetime value in RFC 3339 format indicating when the time range
	// ends.
	EndAt *string `json:"end_at,omitempty" url:"end_at,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (t *TimeRange) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TimeRange) UnmarshalJSON(data []byte) error {
	type unmarshaler TimeRange
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TimeRange(value)

	extraProperties, err := core.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties

	t._rawJSON = json.RawMessage(data)
	return nil
}

func (t *TimeRange) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type TipSettings struct {
	// Indicates whether tipping is enabled for this checkout. Defaults to false.
	AllowTipping *bool `json:"allow_tipping,omitempty" url:"allow_tipping,omitempty"`
	// Indicates whether tip options should be presented on the screen before presenting
	// the signature screen during card payment. Defaults to false.
	SeparateTipScreen *bool `json:"separate_tip_screen,omitempty" url:"separate_tip_screen,omitempty"`
	// Indicates whether custom tip amounts are allowed during the checkout flow. Defaults to false.
	CustomTipField *bool `json:"custom_tip_field,omitempty" url:"custom_tip_field,omitempty"`
	// A list of tip percentages that should be presented during the checkout flow, specified as
	// up to 3 non-negative integers from 0 to 100 (inclusive). Defaults to 15, 20, and 25.
	TipPercentages []int `json:"tip_percentages,omitempty" url:"tip_percentages,omitempty"`
	// Enables the "Smart Tip Amounts" behavior.
	// Exact tipping options depend on the region in which the Square seller is active.
	//
	// For payments under 10.00, in the Australia, Canada, Ireland, United Kingdom, and United States, tipping options are presented as no tip, .50, 1.00 or 2.00.
	//
	// For payment amounts of 10.00 or greater, tipping options are presented as the following percentages: 0%, 5%, 10%, 15%.
	//
	// If set to true, the `tip_percentages` settings is ignored.
	// Defaults to false.
	//
	// To learn more about smart tipping, see [Accept Tips with the Square App](https://squareup.com/help/us/en/article/5069-accept-tips-with-the-square-app).
	SmartTipping *bool `json:"smart_tipping,omitempty" url:"smart_tipping,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (t *TipSettings) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TipSettings) UnmarshalJSON(data []byte) error {
	type unmarshaler TipSettings
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TipSettings(value)

	extraProperties, err := core.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties

	t._rawJSON = json.RawMessage(data)
	return nil
}

func (t *TipSettings) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// Represents a transaction processed with Square, either with the
// Connect API or with Square Point of Sale.
//
// The `tenders` field of this object lists all methods of payment used to pay in
// the transaction.
type Transaction struct {
	// The transaction's unique ID, issued by Square payments servers.
	Id *string `json:"id,omitempty" url:"id,omitempty"`
	// The ID of the transaction's associated location.
	LocationId *string `json:"location_id,omitempty" url:"location_id,omitempty"`
	// The timestamp for when the transaction was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The tenders used to pay in the transaction.
	Tenders []*Tender `json:"tenders,omitempty" url:"tenders,omitempty"`
	// Refunds that have been applied to any tender in the transaction.
	Refunds []*Refund `json:"refunds,omitempty" url:"refunds,omitempty"`
	// If the transaction was created with the [Charge](api-endpoint:Transactions-Charge)
	// endpoint, this value is the same as the value provided for the `reference_id`
	// parameter in the request to that endpoint. Otherwise, it is not set.
	ReferenceId *string `json:"reference_id,omitempty" url:"reference_id,omitempty"`
	// The Square product that processed the transaction.
	// See [TransactionProduct](#type-transactionproduct) for possible values
	Product *TransactionProduct `json:"product,omitempty" url:"product,omitempty"`
	// If the transaction was created in the Square Point of Sale app, this value
	// is the ID generated for the transaction by Square Point of Sale.
	//
	// This ID has no relationship to the transaction's canonical `id`, which is
	// generated by Square's backend servers. This value is generated for bookkeeping
	// purposes, in case the transaction cannot immediately be completed (for example,
	// if the transaction is processed in offline mode).
	//
	// It is not currently possible with the Connect API to perform a transaction
	// lookup by this value.
	ClientId *string `json:"client_id,omitempty" url:"client_id,omitempty"`
	// The shipping address provided in the request, if any.
	ShippingAddress *Address `json:"shipping_address,omitempty" url:"shipping_address,omitempty"`
	// The order_id is an identifier for the order associated with this transaction, if any.
	OrderId *string `json:"order_id,omitempty" url:"order_id,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (t *Transaction) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *Transaction) UnmarshalJSON(data []byte) error {
	type unmarshaler Transaction
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = Transaction(value)

	extraProperties, err := core.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties

	t._rawJSON = json.RawMessage(data)
	return nil
}

func (t *Transaction) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// Indicates the Square product used to process a transaction.
type TransactionProduct string

const (
	TransactionProductRegister     TransactionProduct = "REGISTER"
	TransactionProductExternalApi  TransactionProduct = "EXTERNAL_API"
	TransactionProductBilling      TransactionProduct = "BILLING"
	TransactionProductAppointments TransactionProduct = "APPOINTMENTS"
	TransactionProductInvoices     TransactionProduct = "INVOICES"
	TransactionProductOnlineStore  TransactionProduct = "ONLINE_STORE"
	TransactionProductPayroll      TransactionProduct = "PAYROLL"
	TransactionProductOther        TransactionProduct = "OTHER"
)

func NewTransactionProductFromString(s string) (TransactionProduct, error) {
	switch s {
	case "REGISTER":
		return TransactionProductRegister, nil
	case "EXTERNAL_API":
		return TransactionProductExternalApi, nil
	case "BILLING":
		return TransactionProductBilling, nil
	case "APPOINTMENTS":
		return TransactionProductAppointments, nil
	case "INVOICES":
		return TransactionProductInvoices, nil
	case "ONLINE_STORE":
		return TransactionProductOnlineStore, nil
	case "PAYROLL":
		return TransactionProductPayroll, nil
	case "OTHER":
		return TransactionProductOther, nil
	}
	var t TransactionProduct
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (t TransactionProduct) Ptr() *TransactionProduct {
	return &t
}

// The transaction type used in the disputed payment.
type TransactionType string

const (
	TransactionTypeDebit  TransactionType = "DEBIT"
	TransactionTypeCredit TransactionType = "CREDIT"
)

func NewTransactionTypeFromString(s string) (TransactionType, error) {
	switch s {
	case "DEBIT":
		return TransactionTypeDebit, nil
	case "CREDIT":
		return TransactionTypeCredit, nil
	}
	var t TransactionType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (t TransactionType) Ptr() *TransactionType {
	return &t
}

// A response to a request to update a `BreakType`. The response contains
// the requested `BreakType` objects and might contain a set of `Error` objects if
// the request resulted in errors.
type UpdateBreakTypeResponse struct {
	// The response object.
	BreakType *BreakType `json:"break_type,omitempty" url:"break_type,omitempty"`
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (u *UpdateBreakTypeResponse) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdateBreakTypeResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler UpdateBreakTypeResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpdateBreakTypeResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties

	u._rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateBreakTypeResponse) String() string {
	if len(u._rawJSON) > 0 {
		if value, err := core.StringifyJSON(u._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UpdateCatalogImageResponse struct {
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The newly updated `CatalogImage` including a Square-generated
	// URL for the encapsulated image file.
	Image *CatalogObject `json:"image,omitempty" url:"image,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (u *UpdateCatalogImageResponse) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdateCatalogImageResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler UpdateCatalogImageResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpdateCatalogImageResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties

	u._rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateCatalogImageResponse) String() string {
	if len(u._rawJSON) > 0 {
		if value, err := core.StringifyJSON(u._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

// Defines the fields that are included in the response body of
// a request to the [UpdateCustomerGroup](api-endpoint:CustomerGroups-UpdateCustomerGroup) endpoint.
//
// Either `errors` or `group` is present in a given response (never both).
type UpdateCustomerGroupResponse struct {
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The successfully updated customer group.
	Group *CustomerGroup `json:"group,omitempty" url:"group,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (u *UpdateCustomerGroupResponse) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdateCustomerGroupResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler UpdateCustomerGroupResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpdateCustomerGroupResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties

	u._rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateCustomerGroupResponse) String() string {
	if len(u._rawJSON) > 0 {
		if value, err := core.StringifyJSON(u._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UpdatePaymentLinkResponse struct {
	// Any errors that occurred when updating the payment link.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The updated payment link.
	PaymentLink *PaymentLink `json:"payment_link,omitempty" url:"payment_link,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (u *UpdatePaymentLinkResponse) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdatePaymentLinkResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler UpdatePaymentLinkResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpdatePaymentLinkResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties

	u._rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdatePaymentLinkResponse) String() string {
	if len(u._rawJSON) > 0 {
		if value, err := core.StringifyJSON(u._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

// The response to a request to update a `Shift`. The response contains
// the updated `Shift` object and might contain a set of `Error` objects if
// the request resulted in errors.
type UpdateShiftResponse struct {
	// The updated `Shift`.
	Shift *Shift `json:"shift,omitempty" url:"shift,omitempty"`
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (u *UpdateShiftResponse) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdateShiftResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler UpdateShiftResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpdateShiftResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties

	u._rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateShiftResponse) String() string {
	if len(u._rawJSON) > 0 {
		if value, err := core.StringifyJSON(u._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

// Represents a response from an update request containing the updated `WageSetting` object
// or error messages.
type UpdateWageSettingResponse struct {
	// The successfully updated `WageSetting` object.
	WageSetting *WageSetting `json:"wage_setting,omitempty" url:"wage_setting,omitempty"`
	// The errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (u *UpdateWageSettingResponse) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdateWageSettingResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler UpdateWageSettingResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpdateWageSettingResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties

	u._rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateWageSettingResponse) String() string {
	if len(u._rawJSON) > 0 {
		if value, err := core.StringifyJSON(u._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

// Defines the fields that are included in the response body of
// a request to the [UpdateWebhookSubscription](api-endpoint:WebhookSubscriptions-UpdateWebhookSubscription) endpoint.
//
// Note: If there are errors processing the request, the [Subscription](entity:WebhookSubscription) is not
// present.
type UpdateWebhookSubscriptionResponse struct {
	// Information on errors encountered during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The updated [Subscription](entity:WebhookSubscription).
	Subscription *WebhookSubscription `json:"subscription,omitempty" url:"subscription,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (u *UpdateWebhookSubscriptionResponse) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdateWebhookSubscriptionResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler UpdateWebhookSubscriptionResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpdateWebhookSubscriptionResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties

	u._rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateWebhookSubscriptionResponse) String() string {
	if len(u._rawJSON) > 0 {
		if value, err := core.StringifyJSON(u._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

// Defines the fields that are included in the response body of
// a request to the [UpdateWebhookSubscriptionSignatureKey](api-endpoint:WebhookSubscriptions-UpdateWebhookSubscriptionSignatureKey) endpoint.
//
// Note: If there are errors processing the request, the [Subscription](entity:WebhookSubscription) is not
// present.
type UpdateWebhookSubscriptionSignatureKeyResponse struct {
	// Information on errors encountered during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The new Square-generated signature key used to validate the origin of the webhook event.
	SignatureKey *string `json:"signature_key,omitempty" url:"signature_key,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (u *UpdateWebhookSubscriptionSignatureKeyResponse) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdateWebhookSubscriptionSignatureKeyResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler UpdateWebhookSubscriptionSignatureKeyResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpdateWebhookSubscriptionSignatureKeyResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties

	u._rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateWebhookSubscriptionSignatureKeyResponse) String() string {
	if len(u._rawJSON) > 0 {
		if value, err := core.StringifyJSON(u._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

// The response to a request to update a `WorkweekConfig` object. The response contains
// the updated `WorkweekConfig` object and might contain a set of `Error` objects if
// the request resulted in errors.
type UpdateWorkweekConfigResponse struct {
	// The response object.
	WorkweekConfig *WorkweekConfig `json:"workweek_config,omitempty" url:"workweek_config,omitempty"`
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (u *UpdateWorkweekConfigResponse) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdateWorkweekConfigResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler UpdateWorkweekConfigResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpdateWorkweekConfigResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties

	u._rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateWorkweekConfigResponse) String() string {
	if len(u._rawJSON) > 0 {
		if value, err := core.StringifyJSON(u._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UpsertCatalogObjectResponse struct {
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The successfully created or updated CatalogObject.
	CatalogObject *CatalogObject `json:"catalog_object,omitempty" url:"catalog_object,omitempty"`
	// The mapping between client and server IDs for this upsert.
	IdMappings []*CatalogIdMapping `json:"id_mappings,omitempty" url:"id_mappings,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (u *UpsertCatalogObjectResponse) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpsertCatalogObjectResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler UpsertCatalogObjectResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpsertCatalogObjectResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties

	u._rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpsertCatalogObjectResponse) String() string {
	if len(u._rawJSON) > 0 {
		if value, err := core.StringifyJSON(u._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

// Represents an [UpsertCustomerCustomAttribute](api-endpoint:CustomerCustomAttributes-UpsertCustomerCustomAttribute) response.
// Either `custom_attribute_definition` or `errors` is present in the response.
type UpsertCustomerCustomAttributeResponse struct {
	// The new or updated custom attribute.
	CustomAttribute *CustomAttribute `json:"custom_attribute,omitempty" url:"custom_attribute,omitempty"`
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (u *UpsertCustomerCustomAttributeResponse) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpsertCustomerCustomAttributeResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler UpsertCustomerCustomAttributeResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpsertCustomerCustomAttributeResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties

	u._rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpsertCustomerCustomAttributeResponse) String() string {
	if len(u._rawJSON) > 0 {
		if value, err := core.StringifyJSON(u._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type V1CreateRefundRequestType string

const (
	V1CreateRefundRequestTypeFull    V1CreateRefundRequestType = "FULL"
	V1CreateRefundRequestTypePartial V1CreateRefundRequestType = "PARTIAL"
)

func NewV1CreateRefundRequestTypeFromString(s string) (V1CreateRefundRequestType, error) {
	switch s {
	case "FULL":
		return V1CreateRefundRequestTypeFull, nil
	case "PARTIAL":
		return V1CreateRefundRequestTypePartial, nil
	}
	var t V1CreateRefundRequestType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (v V1CreateRefundRequestType) Ptr() *V1CreateRefundRequestType {
	return &v
}

type V1GetPaymentRequest struct {
	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (v *V1GetPaymentRequest) GetExtraProperties() map[string]interface{} {
	return v.extraProperties
}

func (v *V1GetPaymentRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler V1GetPaymentRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = V1GetPaymentRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *v)
	if err != nil {
		return err
	}
	v.extraProperties = extraProperties

	v._rawJSON = json.RawMessage(data)
	return nil
}

func (v *V1GetPaymentRequest) String() string {
	if len(v._rawJSON) > 0 {
		if value, err := core.StringifyJSON(v._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

type V1GetSettlementRequest struct {
	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (v *V1GetSettlementRequest) GetExtraProperties() map[string]interface{} {
	return v.extraProperties
}

func (v *V1GetSettlementRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler V1GetSettlementRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = V1GetSettlementRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *v)
	if err != nil {
		return err
	}
	v.extraProperties = extraProperties

	v._rawJSON = json.RawMessage(data)
	return nil
}

func (v *V1GetSettlementRequest) String() string {
	if len(v._rawJSON) > 0 {
		if value, err := core.StringifyJSON(v._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

// Published when the inventory quantity for a catalog item is updated.
type V1InventoryUpdatedWebhook struct {
	// The ID of the target merchant associated with the event.
	MerchantId *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The ID of the target merchant associated with the event.
	LocationId *string `json:"location_id,omitempty" url:"location_id,omitempty"`
	// The type of event this represents, i.e. `INVENTORY_UPDATED`.
	EventType *string `json:"event_type,omitempty" url:"event_type,omitempty"`
	// The ID of the V1 Item whose inventory was updated.
	EntityId *string `json:"entity_id,omitempty" url:"entity_id,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (v *V1InventoryUpdatedWebhook) GetExtraProperties() map[string]interface{} {
	return v.extraProperties
}

func (v *V1InventoryUpdatedWebhook) UnmarshalJSON(data []byte) error {
	type unmarshaler V1InventoryUpdatedWebhook
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = V1InventoryUpdatedWebhook(value)

	extraProperties, err := core.ExtractExtraProperties(data, *v)
	if err != nil {
		return err
	}
	v.extraProperties = extraProperties

	v._rawJSON = json.RawMessage(data)
	return nil
}

func (v *V1InventoryUpdatedWebhook) String() string {
	if len(v._rawJSON) > 0 {
		if value, err := core.StringifyJSON(v._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

type V1ListPaymentsResponse struct {
	Items []*V1Payment `json:"items,omitempty" url:"items,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (v *V1ListPaymentsResponse) GetExtraProperties() map[string]interface{} {
	return v.extraProperties
}

func (v *V1ListPaymentsResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler V1ListPaymentsResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = V1ListPaymentsResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *v)
	if err != nil {
		return err
	}
	v.extraProperties = extraProperties

	v._rawJSON = json.RawMessage(data)
	return nil
}

func (v *V1ListPaymentsResponse) String() string {
	if len(v._rawJSON) > 0 {
		if value, err := core.StringifyJSON(v._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

type V1ListRefundsRequest struct {
	// The order in which payments are listed in the response.
	// See [SortOrder](#type-sortorder) for possible values
	Order *SortOrder `json:"order,omitempty" url:"order,omitempty"`
	// The beginning of the requested reporting period, in ISO 8601 format. If this value is before January 1, 2013 (2013-01-01T00:00:00Z), this endpoint returns an error. Default value: The current time minus one year.
	BeginTime *string `json:"begin_time,omitempty" url:"begin_time,omitempty"`
	// The end of the requested reporting period, in ISO 8601 format. If this value is more than one year greater than begin_time, this endpoint returns an error. Default value: The current time.
	EndTime *string `json:"end_time,omitempty" url:"end_time,omitempty"`
	// The approximate number of refunds to return in a single response. Default: 100. Max: 200. Response may contain more results than the prescribed limit when refunds are made simultaneously to multiple tenders in a payment or when refunds are generated in an exchange to account for the value of returned goods.
	Limit *int `json:"limit,omitempty" url:"limit,omitempty"`
	// A pagination cursor to retrieve the next set of results for your
	// original query to the endpoint.
	BatchToken *string `json:"batch_token,omitempty" url:"batch_token,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (v *V1ListRefundsRequest) GetExtraProperties() map[string]interface{} {
	return v.extraProperties
}

func (v *V1ListRefundsRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler V1ListRefundsRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = V1ListRefundsRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *v)
	if err != nil {
		return err
	}
	v.extraProperties = extraProperties

	v._rawJSON = json.RawMessage(data)
	return nil
}

func (v *V1ListRefundsRequest) String() string {
	if len(v._rawJSON) > 0 {
		if value, err := core.StringifyJSON(v._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

type V1ListRefundsResponse struct {
	Items []*V1Refund `json:"items,omitempty" url:"items,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (v *V1ListRefundsResponse) GetExtraProperties() map[string]interface{} {
	return v.extraProperties
}

func (v *V1ListRefundsResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler V1ListRefundsResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = V1ListRefundsResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *v)
	if err != nil {
		return err
	}
	v.extraProperties = extraProperties

	v._rawJSON = json.RawMessage(data)
	return nil
}

func (v *V1ListRefundsResponse) String() string {
	if len(v._rawJSON) > 0 {
		if value, err := core.StringifyJSON(v._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

type V1ListSettlementsRequest struct {
	// The order in which settlements are listed in the response.
	// See [SortOrder](#type-sortorder) for possible values
	Order *SortOrder `json:"order,omitempty" url:"order,omitempty"`
	// The beginning of the requested reporting period, in ISO 8601 format. If this value is before January 1, 2013 (2013-01-01T00:00:00Z), this endpoint returns an error. Default value: The current time minus one year.
	BeginTime *string `json:"begin_time,omitempty" url:"begin_time,omitempty"`
	// The end of the requested reporting period, in ISO 8601 format. If this value is more than one year greater than begin_time, this endpoint returns an error. Default value: The current time.
	EndTime *string `json:"end_time,omitempty" url:"end_time,omitempty"`
	// The maximum number of settlements to return in a single response. This value cannot exceed 200.
	Limit *int `json:"limit,omitempty" url:"limit,omitempty"`
	// Provide this parameter to retrieve only settlements with a particular status (SENT or FAILED).
	// See [V1ListSettlementsRequestStatus](#type-v1listsettlementsrequeststatus) for possible values
	Status *V1ListSettlementsRequestStatus `json:"status,omitempty" url:"status,omitempty"`
	// A pagination cursor to retrieve the next set of results for your
	// original query to the endpoint.
	BatchToken *string `json:"batch_token,omitempty" url:"batch_token,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (v *V1ListSettlementsRequest) GetExtraProperties() map[string]interface{} {
	return v.extraProperties
}

func (v *V1ListSettlementsRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler V1ListSettlementsRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = V1ListSettlementsRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *v)
	if err != nil {
		return err
	}
	v.extraProperties = extraProperties

	v._rawJSON = json.RawMessage(data)
	return nil
}

func (v *V1ListSettlementsRequest) String() string {
	if len(v._rawJSON) > 0 {
		if value, err := core.StringifyJSON(v._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

type V1ListSettlementsRequestStatus string

const (
	V1ListSettlementsRequestStatusSent   V1ListSettlementsRequestStatus = "SENT"
	V1ListSettlementsRequestStatusFailed V1ListSettlementsRequestStatus = "FAILED"
)

func NewV1ListSettlementsRequestStatusFromString(s string) (V1ListSettlementsRequestStatus, error) {
	switch s {
	case "SENT":
		return V1ListSettlementsRequestStatusSent, nil
	case "FAILED":
		return V1ListSettlementsRequestStatusFailed, nil
	}
	var t V1ListSettlementsRequestStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (v V1ListSettlementsRequestStatus) Ptr() *V1ListSettlementsRequestStatus {
	return &v
}

type V1ListSettlementsResponse struct {
	Items []*V1Settlement `json:"items,omitempty" url:"items,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (v *V1ListSettlementsResponse) GetExtraProperties() map[string]interface{} {
	return v.extraProperties
}

func (v *V1ListSettlementsResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler V1ListSettlementsResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = V1ListSettlementsResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *v)
	if err != nil {
		return err
	}
	v.extraProperties = extraProperties

	v._rawJSON = json.RawMessage(data)
	return nil
}

func (v *V1ListSettlementsResponse) String() string {
	if len(v._rawJSON) > 0 {
		if value, err := core.StringifyJSON(v._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

// V1ListWebhooksRequest
type V1ListWebhooksRequest struct {
	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (v *V1ListWebhooksRequest) GetExtraProperties() map[string]interface{} {
	return v.extraProperties
}

func (v *V1ListWebhooksRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler V1ListWebhooksRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = V1ListWebhooksRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *v)
	if err != nil {
		return err
	}
	v.extraProperties = extraProperties

	v._rawJSON = json.RawMessage(data)
	return nil
}

func (v *V1ListWebhooksRequest) String() string {
	if len(v._rawJSON) > 0 {
		if value, err := core.StringifyJSON(v._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

// V1ListWebhooksResponse
type V1ListWebhooksResponse struct {
	// A list of webhook event enums.
	// See [V1WebhooksEvents](#type-v1webhooksevents) for possible values
	Events []V1WebhooksEvents `json:"events,omitempty" url:"events,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (v *V1ListWebhooksResponse) GetExtraProperties() map[string]interface{} {
	return v.extraProperties
}

func (v *V1ListWebhooksResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler V1ListWebhooksResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = V1ListWebhooksResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *v)
	if err != nil {
		return err
	}
	v.extraProperties = extraProperties

	v._rawJSON = json.RawMessage(data)
	return nil
}

func (v *V1ListWebhooksResponse) String() string {
	if len(v._rawJSON) > 0 {
		if value, err := core.StringifyJSON(v._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

type V1Money struct {
	// Amount in the lowest denominated value of this Currency. E.g. in USD
	// these are cents, in JPY they are Yen (which do not have a 'cent' concept).
	Amount *int `json:"amount,omitempty" url:"amount,omitempty"`
	// See [Currency](#type-currency) for possible values
	CurrencyCode *Currency `json:"currency_code,omitempty" url:"currency_code,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (v *V1Money) GetExtraProperties() map[string]interface{} {
	return v.extraProperties
}

func (v *V1Money) UnmarshalJSON(data []byte) error {
	type unmarshaler V1Money
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = V1Money(value)

	extraProperties, err := core.ExtractExtraProperties(data, *v)
	if err != nil {
		return err
	}
	v.extraProperties = extraProperties

	v._rawJSON = json.RawMessage(data)
	return nil
}

func (v *V1Money) String() string {
	if len(v._rawJSON) > 0 {
		if value, err := core.StringifyJSON(v._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

// A payment represents a paid transaction between a Square merchant and a
// customer. Payment details are usually available from Connect API endpoints
// within a few minutes after the transaction completes.
//
// Each Payment object includes several fields that end in `_money`. These fields
// describe the various amounts of money that contribute to the payment total:
//
// <ul>
// <li>
// Monetary values are <b>positive</b> if they represent an
// <em>increase</em> in the amount of money the merchant receives (e.g.,
// <code>tax_money</code>, <code>tip_money</code>).
// </li>
// <li>
// Monetary values are <b>negative</b> if they represent an
// <em>decrease</em> in the amount of money the merchant receives (e.g.,
// <code>discount_money</code>, <code>refunded_money</code>).
// </li>
// </ul>
type V1Payment struct {
	// The payment's unique identifier.
	Id *string `json:"id,omitempty" url:"id,omitempty"`
	// The unique identifier of the merchant that took the payment.
	MerchantId *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The time when the payment was created, in ISO 8601 format. Reflects the time of the first payment if the object represents an incomplete partial payment, and the time of the last or complete payment otherwise.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The unique identifier of the Square account that took the payment.
	CreatorId *string `json:"creator_id,omitempty" url:"creator_id,omitempty"`
	// The device that took the payment.
	Device *Device `json:"device,omitempty" url:"device,omitempty"`
	// The URL of the payment's detail page in the merchant dashboard. The merchant must be signed in to the merchant dashboard to view this page.
	PaymentUrl *string `json:"payment_url,omitempty" url:"payment_url,omitempty"`
	// The URL of the receipt for the payment. Note that for split tender
	// payments, this URL corresponds to the receipt for the first tender
	// listed in the payment's tender field. Each Tender object has its own
	// receipt_url field you can use to get the other receipts associated with
	// a split tender payment.
	ReceiptUrl *string `json:"receipt_url,omitempty" url:"receipt_url,omitempty"`
	// The sum of all inclusive taxes associated with the payment.
	InclusiveTaxMoney *V1Money `json:"inclusive_tax_money,omitempty" url:"inclusive_tax_money,omitempty"`
	// The sum of all additive taxes associated with the payment.
	AdditiveTaxMoney *V1Money `json:"additive_tax_money,omitempty" url:"additive_tax_money,omitempty"`
	// The total of all taxes applied to the payment. This is always the sum of inclusive_tax_money and additive_tax_money.
	TaxMoney *V1Money `json:"tax_money,omitempty" url:"tax_money,omitempty"`
	// The total of all tips applied to the payment.
	TipMoney *V1Money `json:"tip_money,omitempty" url:"tip_money,omitempty"`
	// The total of all discounts applied to the payment.
	DiscountMoney *V1Money `json:"discount_money,omitempty" url:"discount_money,omitempty"`
	// The total of all discounts applied to the payment.
	TotalCollectedMoney *V1Money `json:"total_collected_money,omitempty" url:"total_collected_money,omitempty"`
	// The total of all processing fees collected by Square for the payment.
	ProcessingFeeMoney *V1Money `json:"processing_fee_money,omitempty" url:"processing_fee_money,omitempty"`
	// The amount to be deposited into the merchant's bank account for the payment.
	NetTotalMoney *V1Money `json:"net_total_money,omitempty" url:"net_total_money,omitempty"`
	// The total of all refunds applied to the payment.
	RefundedMoney *V1Money `json:"refunded_money,omitempty" url:"refunded_money,omitempty"`
	// The total of all sales, including any applicable taxes, rounded to the smallest legal unit of currency (e.g., the nearest penny in USD, the nearest nickel in CAD)
	SwedishRoundingMoney *V1Money `json:"swedish_rounding_money,omitempty" url:"swedish_rounding_money,omitempty"`
	// The total of all sales, including any applicable taxes.
	GrossSalesMoney *V1Money `json:"gross_sales_money,omitempty" url:"gross_sales_money,omitempty"`
	// The total of all sales, minus any applicable taxes.
	NetSalesMoney *V1Money `json:"net_sales_money,omitempty" url:"net_sales_money,omitempty"`
	// All of the inclusive taxes associated with the payment.
	InclusiveTax []*V1PaymentTax `json:"inclusive_tax,omitempty" url:"inclusive_tax,omitempty"`
	// All of the additive taxes associated with the payment.
	AdditiveTax []*V1PaymentTax `json:"additive_tax,omitempty" url:"additive_tax,omitempty"`
	// All of the tenders associated with the payment.
	Tender []*V1Tender `json:"tender,omitempty" url:"tender,omitempty"`
	// All of the refunds applied to the payment. Note that the value of all refunds on a payment can exceed the value of all tenders if a merchant chooses to refund money to a tender after previously accepting returned goods as part of an exchange.
	Refunds []*V1Refund `json:"refunds,omitempty" url:"refunds,omitempty"`
	// The items purchased in the payment.
	Itemizations []*V1PaymentItemization `json:"itemizations,omitempty" url:"itemizations,omitempty"`
	// The total of all surcharges applied to the payment.
	SurchargeMoney *V1Money `json:"surcharge_money,omitempty" url:"surcharge_money,omitempty"`
	// A list of all surcharges associated with the payment.
	Surcharges []*V1PaymentSurcharge `json:"surcharges,omitempty" url:"surcharges,omitempty"`
	// Indicates whether or not the payment is only partially paid for.
	// If true, this payment will have the tenders collected so far, but the
	// itemizations will be empty until the payment is completed.
	IsPartial *bool `json:"is_partial,omitempty" url:"is_partial,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (v *V1Payment) GetExtraProperties() map[string]interface{} {
	return v.extraProperties
}

func (v *V1Payment) UnmarshalJSON(data []byte) error {
	type unmarshaler V1Payment
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = V1Payment(value)

	extraProperties, err := core.ExtractExtraProperties(data, *v)
	if err != nil {
		return err
	}
	v.extraProperties = extraProperties

	v._rawJSON = json.RawMessage(data)
	return nil
}

func (v *V1Payment) String() string {
	if len(v._rawJSON) > 0 {
		if value, err := core.StringifyJSON(v._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

// V1PaymentDiscount
type V1PaymentDiscount struct {
	// The discount's name.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// The amount of money that this discount adds to the payment (note that this value is always negative or zero).
	AppliedMoney *V1Money `json:"applied_money,omitempty" url:"applied_money,omitempty"`
	// The ID of the applied discount, if available. Discounts applied in older versions of Square Register might not have an ID.
	DiscountId *string `json:"discount_id,omitempty" url:"discount_id,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (v *V1PaymentDiscount) GetExtraProperties() map[string]interface{} {
	return v.extraProperties
}

func (v *V1PaymentDiscount) UnmarshalJSON(data []byte) error {
	type unmarshaler V1PaymentDiscount
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = V1PaymentDiscount(value)

	extraProperties, err := core.ExtractExtraProperties(data, *v)
	if err != nil {
		return err
	}
	v.extraProperties = extraProperties

	v._rawJSON = json.RawMessage(data)
	return nil
}

func (v *V1PaymentDiscount) String() string {
	if len(v._rawJSON) > 0 {
		if value, err := core.StringifyJSON(v._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

// V1PaymentItemDetail
type V1PaymentItemDetail struct {
	// The name of the item's merchant-defined category, if any.
	CategoryName *string `json:"category_name,omitempty" url:"category_name,omitempty"`
	// The item's merchant-defined SKU, if any.
	Sku *string `json:"sku,omitempty" url:"sku,omitempty"`
	// The unique ID of the item purchased, if any.
	ItemId *string `json:"item_id,omitempty" url:"item_id,omitempty"`
	// The unique ID of the item variation purchased, if any.
	ItemVariationId *string `json:"item_variation_id,omitempty" url:"item_variation_id,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (v *V1PaymentItemDetail) GetExtraProperties() map[string]interface{} {
	return v.extraProperties
}

func (v *V1PaymentItemDetail) UnmarshalJSON(data []byte) error {
	type unmarshaler V1PaymentItemDetail
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = V1PaymentItemDetail(value)

	extraProperties, err := core.ExtractExtraProperties(data, *v)
	if err != nil {
		return err
	}
	v.extraProperties = extraProperties

	v._rawJSON = json.RawMessage(data)
	return nil
}

func (v *V1PaymentItemDetail) String() string {
	if len(v._rawJSON) > 0 {
		if value, err := core.StringifyJSON(v._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

// Payment include an` itemizations` field that lists the items purchased,
// along with associated fees, modifiers, and discounts. Each itemization has an
// `itemization_type` field that indicates which of the following the itemization
// represents:
//
// <ul>
// <li>An item variation from the merchant's item library</li>
// <li>A custom monetary amount</li>
// <li>
// An action performed on a Square gift card, such as activating or
// reloading it.
// </li>
// </ul>
//
// \*Note**: itemization information included in a `Payment` object reflects
// details collected **at the time of the payment\*\*. Details such as the name or
// price of items might have changed since the payment was processed.
type V1PaymentItemization struct {
	// The item's name.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// The quantity of the item purchased. This can be a decimal value.
	Quantity *float64 `json:"quantity,omitempty" url:"quantity,omitempty"`
	// The type of purchase that the itemization represents, such as an ITEM or CUSTOM_AMOUNT
	// See [V1PaymentItemizationItemizationType](#type-v1paymentitemizationitemizationtype) for possible values
	ItemizationType *V1PaymentItemizationItemizationType `json:"itemization_type,omitempty" url:"itemization_type,omitempty"`
	// Details of the item, including its unique identifier and the identifier of the item variation purchased.
	ItemDetail *V1PaymentItemDetail `json:"item_detail,omitempty" url:"item_detail,omitempty"`
	// Notes entered by the merchant about the item at the time of payment, if any.
	Notes *string `json:"notes,omitempty" url:"notes,omitempty"`
	// The name of the item variation purchased, if any.
	ItemVariationName *string `json:"item_variation_name,omitempty" url:"item_variation_name,omitempty"`
	// The total cost of the item, including all taxes and discounts.
	TotalMoney *V1Money `json:"total_money,omitempty" url:"total_money,omitempty"`
	// The cost of a single unit of this item.
	SingleQuantityMoney *V1Money `json:"single_quantity_money,omitempty" url:"single_quantity_money,omitempty"`
	// The total cost of the itemization and its modifiers, not including taxes or discounts.
	GrossSalesMoney *V1Money `json:"gross_sales_money,omitempty" url:"gross_sales_money,omitempty"`
	// The total of all discounts applied to the itemization. This value is always negative or zero.
	DiscountMoney *V1Money `json:"discount_money,omitempty" url:"discount_money,omitempty"`
	// The sum of gross_sales_money and discount_money.
	NetSalesMoney *V1Money `json:"net_sales_money,omitempty" url:"net_sales_money,omitempty"`
	// All taxes applied to this itemization.
	Taxes []*V1PaymentTax `json:"taxes,omitempty" url:"taxes,omitempty"`
	// All discounts applied to this itemization.
	Discounts []*V1PaymentDiscount `json:"discounts,omitempty" url:"discounts,omitempty"`
	// All modifier options applied to this itemization.
	Modifiers []*V1PaymentModifier `json:"modifiers,omitempty" url:"modifiers,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (v *V1PaymentItemization) GetExtraProperties() map[string]interface{} {
	return v.extraProperties
}

func (v *V1PaymentItemization) UnmarshalJSON(data []byte) error {
	type unmarshaler V1PaymentItemization
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = V1PaymentItemization(value)

	extraProperties, err := core.ExtractExtraProperties(data, *v)
	if err != nil {
		return err
	}
	v.extraProperties = extraProperties

	v._rawJSON = json.RawMessage(data)
	return nil
}

func (v *V1PaymentItemization) String() string {
	if len(v._rawJSON) > 0 {
		if value, err := core.StringifyJSON(v._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

type V1PaymentItemizationItemizationType string

const (
	V1PaymentItemizationItemizationTypeItem               V1PaymentItemizationItemizationType = "ITEM"
	V1PaymentItemizationItemizationTypeCustomAmount       V1PaymentItemizationItemizationType = "CUSTOM_AMOUNT"
	V1PaymentItemizationItemizationTypeGiftCardActivation V1PaymentItemizationItemizationType = "GIFT_CARD_ACTIVATION"
	V1PaymentItemizationItemizationTypeGiftCardReload     V1PaymentItemizationItemizationType = "GIFT_CARD_RELOAD"
	V1PaymentItemizationItemizationTypeGiftCardUnknown    V1PaymentItemizationItemizationType = "GIFT_CARD_UNKNOWN"
	V1PaymentItemizationItemizationTypeOther              V1PaymentItemizationItemizationType = "OTHER"
)

func NewV1PaymentItemizationItemizationTypeFromString(s string) (V1PaymentItemizationItemizationType, error) {
	switch s {
	case "ITEM":
		return V1PaymentItemizationItemizationTypeItem, nil
	case "CUSTOM_AMOUNT":
		return V1PaymentItemizationItemizationTypeCustomAmount, nil
	case "GIFT_CARD_ACTIVATION":
		return V1PaymentItemizationItemizationTypeGiftCardActivation, nil
	case "GIFT_CARD_RELOAD":
		return V1PaymentItemizationItemizationTypeGiftCardReload, nil
	case "GIFT_CARD_UNKNOWN":
		return V1PaymentItemizationItemizationTypeGiftCardUnknown, nil
	case "OTHER":
		return V1PaymentItemizationItemizationTypeOther, nil
	}
	var t V1PaymentItemizationItemizationType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (v V1PaymentItemizationItemizationType) Ptr() *V1PaymentItemizationItemizationType {
	return &v
}

// V1PaymentModifier
type V1PaymentModifier struct {
	// The modifier option's name.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// The amount of money that this modifier option adds to the payment.
	AppliedMoney *V1Money `json:"applied_money,omitempty" url:"applied_money,omitempty"`
	// The ID of the applied modifier option, if available. Modifier options applied in older versions of Square Register might not have an ID.
	ModifierOptionId *string `json:"modifier_option_id,omitempty" url:"modifier_option_id,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (v *V1PaymentModifier) GetExtraProperties() map[string]interface{} {
	return v.extraProperties
}

func (v *V1PaymentModifier) UnmarshalJSON(data []byte) error {
	type unmarshaler V1PaymentModifier
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = V1PaymentModifier(value)

	extraProperties, err := core.ExtractExtraProperties(data, *v)
	if err != nil {
		return err
	}
	v.extraProperties = extraProperties

	v._rawJSON = json.RawMessage(data)
	return nil
}

func (v *V1PaymentModifier) String() string {
	if len(v._rawJSON) > 0 {
		if value, err := core.StringifyJSON(v._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

// V1PaymentSurcharge
type V1PaymentSurcharge struct {
	// The name of the surcharge.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// The amount of money applied to the order as a result of the surcharge.
	AppliedMoney *V1Money `json:"applied_money,omitempty" url:"applied_money,omitempty"`
	// The amount of the surcharge as a percentage. The percentage is provided as a string representing the decimal equivalent of the percentage. For example, "0.7" corresponds to a 7% surcharge. Exactly one of rate or amount_money should be set.
	Rate *string `json:"rate,omitempty" url:"rate,omitempty"`
	// The amount of the surcharge as a Money object. Exactly one of rate or amount_money should be set.
	AmountMoney *V1Money `json:"amount_money,omitempty" url:"amount_money,omitempty"`
	// Indicates the source of the surcharge. For example, if it was applied as an automatic gratuity for a large group.
	// See [V1PaymentSurchargeType](#type-v1paymentsurchargetype) for possible values
	Type *V1PaymentSurchargeType `json:"type,omitempty" url:"type,omitempty"`
	// Indicates whether the surcharge is taxable.
	Taxable *bool `json:"taxable,omitempty" url:"taxable,omitempty"`
	// The list of taxes that should be applied to the surcharge.
	Taxes []*V1PaymentTax `json:"taxes,omitempty" url:"taxes,omitempty"`
	// A Square-issued unique identifier associated with the surcharge.
	SurchargeId *string `json:"surcharge_id,omitempty" url:"surcharge_id,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (v *V1PaymentSurcharge) GetExtraProperties() map[string]interface{} {
	return v.extraProperties
}

func (v *V1PaymentSurcharge) UnmarshalJSON(data []byte) error {
	type unmarshaler V1PaymentSurcharge
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = V1PaymentSurcharge(value)

	extraProperties, err := core.ExtractExtraProperties(data, *v)
	if err != nil {
		return err
	}
	v.extraProperties = extraProperties

	v._rawJSON = json.RawMessage(data)
	return nil
}

func (v *V1PaymentSurcharge) String() string {
	if len(v._rawJSON) > 0 {
		if value, err := core.StringifyJSON(v._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

type V1PaymentSurchargeType string

const (
	V1PaymentSurchargeTypeUnknown      V1PaymentSurchargeType = "UNKNOWN"
	V1PaymentSurchargeTypeAutoGratuity V1PaymentSurchargeType = "AUTO_GRATUITY"
	V1PaymentSurchargeTypeCustom       V1PaymentSurchargeType = "CUSTOM"
)

func NewV1PaymentSurchargeTypeFromString(s string) (V1PaymentSurchargeType, error) {
	switch s {
	case "UNKNOWN":
		return V1PaymentSurchargeTypeUnknown, nil
	case "AUTO_GRATUITY":
		return V1PaymentSurchargeTypeAutoGratuity, nil
	case "CUSTOM":
		return V1PaymentSurchargeTypeCustom, nil
	}
	var t V1PaymentSurchargeType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (v V1PaymentSurchargeType) Ptr() *V1PaymentSurchargeType {
	return &v
}

// V1PaymentTax
type V1PaymentTax struct {
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The merchant-defined name of the tax.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// The amount of money that this tax adds to the payment.
	AppliedMoney *V1Money `json:"applied_money,omitempty" url:"applied_money,omitempty"`
	// The rate of the tax, as a string representation of a decimal number. A value of 0.07 corresponds to a rate of 7%.
	Rate *string `json:"rate,omitempty" url:"rate,omitempty"`
	// Whether the tax is an ADDITIVE tax or an INCLUSIVE tax.
	// See [V1PaymentTaxInclusionType](#type-v1paymenttaxinclusiontype) for possible values
	InclusionType *V1PaymentTaxInclusionType `json:"inclusion_type,omitempty" url:"inclusion_type,omitempty"`
	// The ID of the tax, if available. Taxes applied in older versions of Square Register might not have an ID.
	FeeId *string `json:"fee_id,omitempty" url:"fee_id,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (v *V1PaymentTax) GetExtraProperties() map[string]interface{} {
	return v.extraProperties
}

func (v *V1PaymentTax) UnmarshalJSON(data []byte) error {
	type unmarshaler V1PaymentTax
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = V1PaymentTax(value)

	extraProperties, err := core.ExtractExtraProperties(data, *v)
	if err != nil {
		return err
	}
	v.extraProperties = extraProperties

	v._rawJSON = json.RawMessage(data)
	return nil
}

func (v *V1PaymentTax) String() string {
	if len(v._rawJSON) > 0 {
		if value, err := core.StringifyJSON(v._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

type V1PaymentTaxInclusionType string

const (
	V1PaymentTaxInclusionTypeAdditive  V1PaymentTaxInclusionType = "ADDITIVE"
	V1PaymentTaxInclusionTypeInclusive V1PaymentTaxInclusionType = "INCLUSIVE"
)

func NewV1PaymentTaxInclusionTypeFromString(s string) (V1PaymentTaxInclusionType, error) {
	switch s {
	case "ADDITIVE":
		return V1PaymentTaxInclusionTypeAdditive, nil
	case "INCLUSIVE":
		return V1PaymentTaxInclusionTypeInclusive, nil
	}
	var t V1PaymentTaxInclusionType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (v V1PaymentTaxInclusionType) Ptr() *V1PaymentTaxInclusionType {
	return &v
}

// Published when a charge is made or refunded through the Square
// Point of Sale app or the Transactions API.
type V1PaymentUpdatedWebhook struct {
	// The ID of the target merchant associated with the event.
	MerchantId *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The ID of the target merchant associated with the event.
	LocationId *string `json:"location_id,omitempty" url:"location_id,omitempty"`
	// The type of event this represents, i.e. `PAYMENT_UPDATED`.
	EventType *string `json:"event_type,omitempty" url:"event_type,omitempty"`
	// The ID of the updated V1 Payment.
	EntityId *string `json:"entity_id,omitempty" url:"entity_id,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (v *V1PaymentUpdatedWebhook) GetExtraProperties() map[string]interface{} {
	return v.extraProperties
}

func (v *V1PaymentUpdatedWebhook) UnmarshalJSON(data []byte) error {
	type unmarshaler V1PaymentUpdatedWebhook
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = V1PaymentUpdatedWebhook(value)

	extraProperties, err := core.ExtractExtraProperties(data, *v)
	if err != nil {
		return err
	}
	v.extraProperties = extraProperties

	v._rawJSON = json.RawMessage(data)
	return nil
}

func (v *V1PaymentUpdatedWebhook) String() string {
	if len(v._rawJSON) > 0 {
		if value, err := core.StringifyJSON(v._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

// Represents a phone number.
type V1PhoneNumber struct {
	// The phone number's international calling code. For US phone numbers, this value is +1.
	CallingCode string `json:"calling_code" url:"calling_code"`
	// The phone number.
	Number string `json:"number" url:"number"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (v *V1PhoneNumber) GetExtraProperties() map[string]interface{} {
	return v.extraProperties
}

func (v *V1PhoneNumber) UnmarshalJSON(data []byte) error {
	type unmarshaler V1PhoneNumber
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = V1PhoneNumber(value)

	extraProperties, err := core.ExtractExtraProperties(data, *v)
	if err != nil {
		return err
	}
	v.extraProperties = extraProperties

	v._rawJSON = json.RawMessage(data)
	return nil
}

func (v *V1PhoneNumber) String() string {
	if len(v._rawJSON) > 0 {
		if value, err := core.StringifyJSON(v._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

// V1Refund
type V1Refund struct {
	// The type of refund
	// See [V1RefundType](#type-v1refundtype) for possible values
	Type *V1RefundType `json:"type,omitempty" url:"type,omitempty"`
	// The merchant-specified reason for the refund.
	Reason *string `json:"reason,omitempty" url:"reason,omitempty"`
	// The amount of money refunded. This amount is always negative.
	RefundedMoney *V1Money `json:"refunded_money,omitempty" url:"refunded_money,omitempty"`
	// The amount of processing fee money refunded. This amount is always positive.
	RefundedProcessingFeeMoney *V1Money `json:"refunded_processing_fee_money,omitempty" url:"refunded_processing_fee_money,omitempty"`
	// The total amount of tax money refunded. This amount is always negative.
	RefundedTaxMoney *V1Money `json:"refunded_tax_money,omitempty" url:"refunded_tax_money,omitempty"`
	// The amount of additive tax money refunded. This amount is always negative.
	RefundedAdditiveTaxMoney *V1Money `json:"refunded_additive_tax_money,omitempty" url:"refunded_additive_tax_money,omitempty"`
	// All of the additive taxes associated with the refund.
	RefundedAdditiveTax []*V1PaymentTax `json:"refunded_additive_tax,omitempty" url:"refunded_additive_tax,omitempty"`
	// The amount of inclusive tax money refunded. This amount is always negative.
	RefundedInclusiveTaxMoney *V1Money `json:"refunded_inclusive_tax_money,omitempty" url:"refunded_inclusive_tax_money,omitempty"`
	// All of the inclusive taxes associated with the refund.
	RefundedInclusiveTax []*V1PaymentTax `json:"refunded_inclusive_tax,omitempty" url:"refunded_inclusive_tax,omitempty"`
	// The amount of tip money refunded. This amount is always negative.
	RefundedTipMoney *V1Money `json:"refunded_tip_money,omitempty" url:"refunded_tip_money,omitempty"`
	// The amount of discount money refunded. This amount is always positive.
	RefundedDiscountMoney *V1Money `json:"refunded_discount_money,omitempty" url:"refunded_discount_money,omitempty"`
	// The amount of surcharge money refunded. This amount is always negative.
	RefundedSurchargeMoney *V1Money `json:"refunded_surcharge_money,omitempty" url:"refunded_surcharge_money,omitempty"`
	// A list of all surcharges associated with the refund.
	RefundedSurcharges []*V1PaymentSurcharge `json:"refunded_surcharges,omitempty" url:"refunded_surcharges,omitempty"`
	// The time when the merchant initiated the refund for Square to process, in ISO 8601 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The time when Square processed the refund on behalf of the merchant, in ISO 8601 format.
	ProcessedAt *string `json:"processed_at,omitempty" url:"processed_at,omitempty"`
	// A Square-issued ID associated with the refund. For single-tender refunds, payment_id is the ID of the original payment ID. For split-tender refunds, payment_id is the ID of the original tender. For exchange-based refunds (is_exchange == true), payment_id is the ID of the original payment ID even if the payment includes other tenders.
	PaymentId  *string `json:"payment_id,omitempty" url:"payment_id,omitempty"`
	MerchantId *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// Indicates whether or not the refund is associated with an exchange. If is_exchange is true, the refund reflects the value of goods returned in the exchange not the total money refunded.
	IsExchange *bool `json:"is_exchange,omitempty" url:"is_exchange,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (v *V1Refund) GetExtraProperties() map[string]interface{} {
	return v.extraProperties
}

func (v *V1Refund) UnmarshalJSON(data []byte) error {
	type unmarshaler V1Refund
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = V1Refund(value)

	extraProperties, err := core.ExtractExtraProperties(data, *v)
	if err != nil {
		return err
	}
	v.extraProperties = extraProperties

	v._rawJSON = json.RawMessage(data)
	return nil
}

func (v *V1Refund) String() string {
	if len(v._rawJSON) > 0 {
		if value, err := core.StringifyJSON(v._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

type V1RefundType string

const (
	V1RefundTypeFull    V1RefundType = "FULL"
	V1RefundTypePartial V1RefundType = "PARTIAL"
)

func NewV1RefundTypeFromString(s string) (V1RefundType, error) {
	switch s {
	case "FULL":
		return V1RefundTypeFull, nil
	case "PARTIAL":
		return V1RefundTypePartial, nil
	}
	var t V1RefundType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (v V1RefundType) Ptr() *V1RefundType {
	return &v
}

// V1Settlement
type V1Settlement struct {
	// The settlement's unique identifier.
	Id *string `json:"id,omitempty" url:"id,omitempty"`
	// The settlement's current status.
	// See [V1SettlementStatus](#type-v1settlementstatus) for possible values
	Status *V1SettlementStatus `json:"status,omitempty" url:"status,omitempty"`
	// The amount of money involved in the settlement. A positive amount indicates a deposit, and a negative amount indicates a withdrawal. This amount is never zero.
	TotalMoney *V1Money `json:"total_money,omitempty" url:"total_money,omitempty"`
	// The time when the settlement was submitted for deposit or withdrawal, in ISO 8601 format.
	InitiatedAt *string `json:"initiated_at,omitempty" url:"initiated_at,omitempty"`
	// The Square-issued unique identifier for the bank account associated with the settlement.
	BankAccountId *string `json:"bank_account_id,omitempty" url:"bank_account_id,omitempty"`
	// The entries included in this settlement.
	Entries []*V1SettlementEntry `json:"entries,omitempty" url:"entries,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (v *V1Settlement) GetExtraProperties() map[string]interface{} {
	return v.extraProperties
}

func (v *V1Settlement) UnmarshalJSON(data []byte) error {
	type unmarshaler V1Settlement
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = V1Settlement(value)

	extraProperties, err := core.ExtractExtraProperties(data, *v)
	if err != nil {
		return err
	}
	v.extraProperties = extraProperties

	v._rawJSON = json.RawMessage(data)
	return nil
}

func (v *V1Settlement) String() string {
	if len(v._rawJSON) > 0 {
		if value, err := core.StringifyJSON(v._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

// V1SettlementEntry
type V1SettlementEntry struct {
	// The settlement's unique identifier.
	PaymentId *string `json:"payment_id,omitempty" url:"payment_id,omitempty"`
	// The settlement's current status.
	// See [V1SettlementEntryType](#type-v1settlemententrytype) for possible values
	Type *V1SettlementEntryType `json:"type,omitempty" url:"type,omitempty"`
	// The total amount of money this entry contributes to the total settlement amount.
	AmountMoney *V1Money `json:"amount_money,omitempty" url:"amount_money,omitempty"`
	// The amount of all Square fees associated with this settlement entry. This value is always negative or zero.
	FeeMoney *V1Money `json:"fee_money,omitempty" url:"fee_money,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (v *V1SettlementEntry) GetExtraProperties() map[string]interface{} {
	return v.extraProperties
}

func (v *V1SettlementEntry) UnmarshalJSON(data []byte) error {
	type unmarshaler V1SettlementEntry
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = V1SettlementEntry(value)

	extraProperties, err := core.ExtractExtraProperties(data, *v)
	if err != nil {
		return err
	}
	v.extraProperties = extraProperties

	v._rawJSON = json.RawMessage(data)
	return nil
}

func (v *V1SettlementEntry) String() string {
	if len(v._rawJSON) > 0 {
		if value, err := core.StringifyJSON(v._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

type V1SettlementEntryType string

const (
	V1SettlementEntryTypeAdjustment                   V1SettlementEntryType = "ADJUSTMENT"
	V1SettlementEntryTypeBalanceCharge                V1SettlementEntryType = "BALANCE_CHARGE"
	V1SettlementEntryTypeCharge                       V1SettlementEntryType = "CHARGE"
	V1SettlementEntryTypeFreeProcessing               V1SettlementEntryType = "FREE_PROCESSING"
	V1SettlementEntryTypeHoldAdjustment               V1SettlementEntryType = "HOLD_ADJUSTMENT"
	V1SettlementEntryTypePaidServiceFee               V1SettlementEntryType = "PAID_SERVICE_FEE"
	V1SettlementEntryTypePaidServiceFeeRefund         V1SettlementEntryType = "PAID_SERVICE_FEE_REFUND"
	V1SettlementEntryTypeRedemptionCode               V1SettlementEntryType = "REDEMPTION_CODE"
	V1SettlementEntryTypeRefund                       V1SettlementEntryType = "REFUND"
	V1SettlementEntryTypeReturnedPayout               V1SettlementEntryType = "RETURNED_PAYOUT"
	V1SettlementEntryTypeSquareCapitalAdvance         V1SettlementEntryType = "SQUARE_CAPITAL_ADVANCE"
	V1SettlementEntryTypeSquareCapitalPayment         V1SettlementEntryType = "SQUARE_CAPITAL_PAYMENT"
	V1SettlementEntryTypeSquareCapitalReversedPayment V1SettlementEntryType = "SQUARE_CAPITAL_REVERSED_PAYMENT"
	V1SettlementEntryTypeSubscriptionFee              V1SettlementEntryType = "SUBSCRIPTION_FEE"
	V1SettlementEntryTypeSubscriptionFeeRefund        V1SettlementEntryType = "SUBSCRIPTION_FEE_REFUND"
	V1SettlementEntryTypeOther                        V1SettlementEntryType = "OTHER"
	V1SettlementEntryTypeIncentedPayment              V1SettlementEntryType = "INCENTED_PAYMENT"
	V1SettlementEntryTypeReturnedAchEntry             V1SettlementEntryType = "RETURNED_ACH_ENTRY"
	V1SettlementEntryTypeReturnedSquare275            V1SettlementEntryType = "RETURNED_SQUARE_275"
	V1SettlementEntryTypeSquare275                    V1SettlementEntryType = "SQUARE_275"
	V1SettlementEntryTypeSquareCard                   V1SettlementEntryType = "SQUARE_CARD"
)

func NewV1SettlementEntryTypeFromString(s string) (V1SettlementEntryType, error) {
	switch s {
	case "ADJUSTMENT":
		return V1SettlementEntryTypeAdjustment, nil
	case "BALANCE_CHARGE":
		return V1SettlementEntryTypeBalanceCharge, nil
	case "CHARGE":
		return V1SettlementEntryTypeCharge, nil
	case "FREE_PROCESSING":
		return V1SettlementEntryTypeFreeProcessing, nil
	case "HOLD_ADJUSTMENT":
		return V1SettlementEntryTypeHoldAdjustment, nil
	case "PAID_SERVICE_FEE":
		return V1SettlementEntryTypePaidServiceFee, nil
	case "PAID_SERVICE_FEE_REFUND":
		return V1SettlementEntryTypePaidServiceFeeRefund, nil
	case "REDEMPTION_CODE":
		return V1SettlementEntryTypeRedemptionCode, nil
	case "REFUND":
		return V1SettlementEntryTypeRefund, nil
	case "RETURNED_PAYOUT":
		return V1SettlementEntryTypeReturnedPayout, nil
	case "SQUARE_CAPITAL_ADVANCE":
		return V1SettlementEntryTypeSquareCapitalAdvance, nil
	case "SQUARE_CAPITAL_PAYMENT":
		return V1SettlementEntryTypeSquareCapitalPayment, nil
	case "SQUARE_CAPITAL_REVERSED_PAYMENT":
		return V1SettlementEntryTypeSquareCapitalReversedPayment, nil
	case "SUBSCRIPTION_FEE":
		return V1SettlementEntryTypeSubscriptionFee, nil
	case "SUBSCRIPTION_FEE_REFUND":
		return V1SettlementEntryTypeSubscriptionFeeRefund, nil
	case "OTHER":
		return V1SettlementEntryTypeOther, nil
	case "INCENTED_PAYMENT":
		return V1SettlementEntryTypeIncentedPayment, nil
	case "RETURNED_ACH_ENTRY":
		return V1SettlementEntryTypeReturnedAchEntry, nil
	case "RETURNED_SQUARE_275":
		return V1SettlementEntryTypeReturnedSquare275, nil
	case "SQUARE_275":
		return V1SettlementEntryTypeSquare275, nil
	case "SQUARE_CARD":
		return V1SettlementEntryTypeSquareCard, nil
	}
	var t V1SettlementEntryType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (v V1SettlementEntryType) Ptr() *V1SettlementEntryType {
	return &v
}

type V1SettlementStatus string

const (
	V1SettlementStatusFailed V1SettlementStatus = "FAILED"
	V1SettlementStatusSent   V1SettlementStatus = "SENT"
)

func NewV1SettlementStatusFromString(s string) (V1SettlementStatus, error) {
	switch s {
	case "FAILED":
		return V1SettlementStatusFailed, nil
	case "SENT":
		return V1SettlementStatusSent, nil
	}
	var t V1SettlementStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (v V1SettlementStatus) Ptr() *V1SettlementStatus {
	return &v
}

type V1SubmitBatchRequest struct {
	// The set of API actions to perform.
	Requests []*BatchRequest `json:"requests,omitempty" url:"requests,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (v *V1SubmitBatchRequest) GetExtraProperties() map[string]interface{} {
	return v.extraProperties
}

func (v *V1SubmitBatchRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler V1SubmitBatchRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = V1SubmitBatchRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *v)
	if err != nil {
		return err
	}
	v.extraProperties = extraProperties

	v._rawJSON = json.RawMessage(data)
	return nil
}

func (v *V1SubmitBatchRequest) String() string {
	if len(v._rawJSON) > 0 {
		if value, err := core.StringifyJSON(v._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

type V1SubmitBatchResponse struct {
	// An array of `BatchResponse` objects corresponding to requests. The
	// index of each response in the array matches the index of the
	// corresponding request.
	Items []*BatchResponse `json:"items,omitempty" url:"items,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (v *V1SubmitBatchResponse) GetExtraProperties() map[string]interface{} {
	return v.extraProperties
}

func (v *V1SubmitBatchResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler V1SubmitBatchResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = V1SubmitBatchResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *v)
	if err != nil {
		return err
	}
	v.extraProperties = extraProperties

	v._rawJSON = json.RawMessage(data)
	return nil
}

func (v *V1SubmitBatchResponse) String() string {
	if len(v._rawJSON) > 0 {
		if value, err := core.StringifyJSON(v._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

// A tender represents a discrete monetary exchange. Square represents this
// exchange as a money object with a specific currency and amount, where the
// amount is given in the smallest denomination of the given currency.
//
// Square POS can accept more than one form of tender for a single payment (such
// as by splitting a bill between a credit card and a gift card). The `tender`
// field of the Payment object lists all forms of tender used for the payment.
//
// Split tender payments behave slightly differently from single tender payments:
//
// The receipt_url for a split tender corresponds only to the first tender listed
// in the tender field. To get the receipt URLs for the remaining tenders, use
// the receipt_url fields of the corresponding Tender objects.
//
// \*A note on gift cards\*\*: when a customer purchases a Square gift card from a
// merchant, the merchant receives the full amount of the gift card in the
// associated payment.
//
// When that gift card is used as a tender, the balance of the gift card is
// reduced and the merchant receives no funds. A `Tender` object with a type of
// `SQUARE_GIFT_CARD` indicates a gift card was used for some or all of the
// associated payment.
type V1Tender struct {
	// The tender's unique ID.
	Id *string `json:"id,omitempty" url:"id,omitempty"`
	// The type of tender.
	// See [V1TenderType](#type-v1tendertype) for possible values
	Type *V1TenderType `json:"type,omitempty" url:"type,omitempty"`
	// A human-readable description of the tender.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// The ID of the employee that processed the tender.
	EmployeeId *string `json:"employee_id,omitempty" url:"employee_id,omitempty"`
	// The URL of the receipt for the tender.
	ReceiptUrl *string `json:"receipt_url,omitempty" url:"receipt_url,omitempty"`
	// The brand of credit card provided.
	// See [V1TenderCardBrand](#type-v1tendercardbrand) for possible values
	CardBrand *V1TenderCardBrand `json:"card_brand,omitempty" url:"card_brand,omitempty"`
	// The last four digits of the provided credit card's account number.
	PanSuffix *string `json:"pan_suffix,omitempty" url:"pan_suffix,omitempty"`
	// The tender's unique ID.
	// See [V1TenderEntryMethod](#type-v1tenderentrymethod) for possible values
	EntryMethod *V1TenderEntryMethod `json:"entry_method,omitempty" url:"entry_method,omitempty"`
	// Notes entered by the merchant about the tender at the time of payment, if any. Typically only present for tender with the type: OTHER.
	PaymentNote *string `json:"payment_note,omitempty" url:"payment_note,omitempty"`
	// The total amount of money provided in this form of tender.
	TotalMoney *V1Money `json:"total_money,omitempty" url:"total_money,omitempty"`
	// The amount of total_money applied to the payment.
	TenderedMoney *V1Money `json:"tendered_money,omitempty" url:"tendered_money,omitempty"`
	// The time when the tender was created, in ISO 8601 format.
	TenderedAt *string `json:"tendered_at,omitempty" url:"tendered_at,omitempty"`
	// The time when the tender was settled, in ISO 8601 format.
	SettledAt *string `json:"settled_at,omitempty" url:"settled_at,omitempty"`
	// The amount of total_money returned to the buyer as change.
	ChangeBackMoney *V1Money `json:"change_back_money,omitempty" url:"change_back_money,omitempty"`
	// The total of all refunds applied to this tender. This amount is always negative or zero.
	RefundedMoney *V1Money `json:"refunded_money,omitempty" url:"refunded_money,omitempty"`
	// Indicates whether or not the tender is associated with an exchange. If is_exchange is true, the tender represents the value of goods returned in an exchange not the actual money paid. The exchange value reduces the tender amounts needed to pay for items purchased in the exchange.
	IsExchange *bool `json:"is_exchange,omitempty" url:"is_exchange,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (v *V1Tender) GetExtraProperties() map[string]interface{} {
	return v.extraProperties
}

func (v *V1Tender) UnmarshalJSON(data []byte) error {
	type unmarshaler V1Tender
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = V1Tender(value)

	extraProperties, err := core.ExtractExtraProperties(data, *v)
	if err != nil {
		return err
	}
	v.extraProperties = extraProperties

	v._rawJSON = json.RawMessage(data)
	return nil
}

func (v *V1Tender) String() string {
	if len(v._rawJSON) > 0 {
		if value, err := core.StringifyJSON(v._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

// The brand of a credit card.
type V1TenderCardBrand string

const (
	V1TenderCardBrandOtherBrand      V1TenderCardBrand = "OTHER_BRAND"
	V1TenderCardBrandVisa            V1TenderCardBrand = "VISA"
	V1TenderCardBrandMasterCard      V1TenderCardBrand = "MASTER_CARD"
	V1TenderCardBrandAmericanExpress V1TenderCardBrand = "AMERICAN_EXPRESS"
	V1TenderCardBrandDiscover        V1TenderCardBrand = "DISCOVER"
	V1TenderCardBrandDiscoverDiners  V1TenderCardBrand = "DISCOVER_DINERS"
	V1TenderCardBrandJcb             V1TenderCardBrand = "JCB"
	V1TenderCardBrandChinaUnionpay   V1TenderCardBrand = "CHINA_UNIONPAY"
	V1TenderCardBrandSquareGiftCard  V1TenderCardBrand = "SQUARE_GIFT_CARD"
)

func NewV1TenderCardBrandFromString(s string) (V1TenderCardBrand, error) {
	switch s {
	case "OTHER_BRAND":
		return V1TenderCardBrandOtherBrand, nil
	case "VISA":
		return V1TenderCardBrandVisa, nil
	case "MASTER_CARD":
		return V1TenderCardBrandMasterCard, nil
	case "AMERICAN_EXPRESS":
		return V1TenderCardBrandAmericanExpress, nil
	case "DISCOVER":
		return V1TenderCardBrandDiscover, nil
	case "DISCOVER_DINERS":
		return V1TenderCardBrandDiscoverDiners, nil
	case "JCB":
		return V1TenderCardBrandJcb, nil
	case "CHINA_UNIONPAY":
		return V1TenderCardBrandChinaUnionpay, nil
	case "SQUARE_GIFT_CARD":
		return V1TenderCardBrandSquareGiftCard, nil
	}
	var t V1TenderCardBrand
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (v V1TenderCardBrand) Ptr() *V1TenderCardBrand {
	return &v
}

type V1TenderEntryMethod string

const (
	V1TenderEntryMethodManual       V1TenderEntryMethod = "MANUAL"
	V1TenderEntryMethodScanned      V1TenderEntryMethod = "SCANNED"
	V1TenderEntryMethodSquareCash   V1TenderEntryMethod = "SQUARE_CASH"
	V1TenderEntryMethodSquareWallet V1TenderEntryMethod = "SQUARE_WALLET"
	V1TenderEntryMethodSwiped       V1TenderEntryMethod = "SWIPED"
	V1TenderEntryMethodWebForm      V1TenderEntryMethod = "WEB_FORM"
	V1TenderEntryMethodOther        V1TenderEntryMethod = "OTHER"
)

func NewV1TenderEntryMethodFromString(s string) (V1TenderEntryMethod, error) {
	switch s {
	case "MANUAL":
		return V1TenderEntryMethodManual, nil
	case "SCANNED":
		return V1TenderEntryMethodScanned, nil
	case "SQUARE_CASH":
		return V1TenderEntryMethodSquareCash, nil
	case "SQUARE_WALLET":
		return V1TenderEntryMethodSquareWallet, nil
	case "SWIPED":
		return V1TenderEntryMethodSwiped, nil
	case "WEB_FORM":
		return V1TenderEntryMethodWebForm, nil
	case "OTHER":
		return V1TenderEntryMethodOther, nil
	}
	var t V1TenderEntryMethod
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (v V1TenderEntryMethod) Ptr() *V1TenderEntryMethod {
	return &v
}

type V1TenderType string

const (
	V1TenderTypeCreditCard     V1TenderType = "CREDIT_CARD"
	V1TenderTypeCash           V1TenderType = "CASH"
	V1TenderTypeThirdPartyCard V1TenderType = "THIRD_PARTY_CARD"
	V1TenderTypeNoSale         V1TenderType = "NO_SALE"
	V1TenderTypeSquareWallet   V1TenderType = "SQUARE_WALLET"
	V1TenderTypeSquareGiftCard V1TenderType = "SQUARE_GIFT_CARD"
	V1TenderTypeUnknown        V1TenderType = "UNKNOWN"
	V1TenderTypeOther          V1TenderType = "OTHER"
)

func NewV1TenderTypeFromString(s string) (V1TenderType, error) {
	switch s {
	case "CREDIT_CARD":
		return V1TenderTypeCreditCard, nil
	case "CASH":
		return V1TenderTypeCash, nil
	case "THIRD_PARTY_CARD":
		return V1TenderTypeThirdPartyCard, nil
	case "NO_SALE":
		return V1TenderTypeNoSale, nil
	case "SQUARE_WALLET":
		return V1TenderTypeSquareWallet, nil
	case "SQUARE_GIFT_CARD":
		return V1TenderTypeSquareGiftCard, nil
	case "UNKNOWN":
		return V1TenderTypeUnknown, nil
	case "OTHER":
		return V1TenderTypeOther, nil
	}
	var t V1TenderType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (v V1TenderType) Ptr() *V1TenderType {
	return &v
}

// Published when a timecard is created in the Seller Dashboard
// or an employee clocks in using the Square Point of Sale app.
type V1TimecardUpdatedWebhook struct {
	// The ID of the target merchant associated with the event.
	MerchantId *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The ID of the target merchant associated with the event.
	LocationId *string `json:"location_id,omitempty" url:"location_id,omitempty"`
	// The type of event this represents, i.e. `TIMECARD_UPDATED`.
	EventType *string `json:"event_type,omitempty" url:"event_type,omitempty"`
	// The ID of the updated V1 Timecard.
	EntityId *string `json:"entity_id,omitempty" url:"entity_id,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (v *V1TimecardUpdatedWebhook) GetExtraProperties() map[string]interface{} {
	return v.extraProperties
}

func (v *V1TimecardUpdatedWebhook) UnmarshalJSON(data []byte) error {
	type unmarshaler V1TimecardUpdatedWebhook
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = V1TimecardUpdatedWebhook(value)

	extraProperties, err := core.ExtractExtraProperties(data, *v)
	if err != nil {
		return err
	}
	v.extraProperties = extraProperties

	v._rawJSON = json.RawMessage(data)
	return nil
}

func (v *V1TimecardUpdatedWebhook) String() string {
	if len(v._rawJSON) > 0 {
		if value, err := core.StringifyJSON(v._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

// V1UpdateWebhooksRequest
type V1UpdateWebhooksRequest struct {
	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (v *V1UpdateWebhooksRequest) GetExtraProperties() map[string]interface{} {
	return v.extraProperties
}

func (v *V1UpdateWebhooksRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler V1UpdateWebhooksRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = V1UpdateWebhooksRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *v)
	if err != nil {
		return err
	}
	v.extraProperties = extraProperties

	v._rawJSON = json.RawMessage(data)
	return nil
}

func (v *V1UpdateWebhooksRequest) String() string {
	if len(v._rawJSON) > 0 {
		if value, err := core.StringifyJSON(v._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

// V1UpdateWebhooksResponse
type V1UpdateWebhooksResponse struct {
	// A list of webhook event enums the location is currently subscribed to.
	// See [V1WebhooksEvents](#type-v1webhooksevents) for possible values
	Events []V1WebhooksEvents `json:"events,omitempty" url:"events,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (v *V1UpdateWebhooksResponse) GetExtraProperties() map[string]interface{} {
	return v.extraProperties
}

func (v *V1UpdateWebhooksResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler V1UpdateWebhooksResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = V1UpdateWebhooksResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *v)
	if err != nil {
		return err
	}
	v.extraProperties = extraProperties

	v._rawJSON = json.RawMessage(data)
	return nil
}

func (v *V1UpdateWebhooksResponse) String() string {
	if len(v._rawJSON) > 0 {
		if value, err := core.StringifyJSON(v._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

// V1WebhooksEvents
type V1WebhooksEvents string

const (
	V1WebhooksEventsPaymentUpdated   V1WebhooksEvents = "PAYMENT_UPDATED"
	V1WebhooksEventsInventoryUpdated V1WebhooksEvents = "INVENTORY_UPDATED"
	V1WebhooksEventsTimecardUpdated  V1WebhooksEvents = "TIMECARD_UPDATED"
)

func NewV1WebhooksEventsFromString(s string) (V1WebhooksEvents, error) {
	switch s {
	case "PAYMENT_UPDATED":
		return V1WebhooksEventsPaymentUpdated, nil
	case "INVENTORY_UPDATED":
		return V1WebhooksEventsInventoryUpdated, nil
	case "TIMECARD_UPDATED":
		return V1WebhooksEventsTimecardUpdated, nil
	}
	var t V1WebhooksEvents
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (v V1WebhooksEvents) Ptr() *V1WebhooksEvents {
	return &v
}

// Represents a contact of a [Vendor](entity:Vendor).
type VendorContact struct {
	// A unique Square-generated ID for the [VendorContact](entity:VendorContact).
	// This field is required when attempting to update a [VendorContact](entity:VendorContact).
	Id *string `json:"id,omitempty" url:"id,omitempty"`
	// The name of the [VendorContact](entity:VendorContact).
	// This field is required when attempting to create a [Vendor](entity:Vendor).
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// The email address of the [VendorContact](entity:VendorContact).
	EmailAddress *string `json:"email_address,omitempty" url:"email_address,omitempty"`
	// The phone number of the [VendorContact](entity:VendorContact).
	PhoneNumber *string `json:"phone_number,omitempty" url:"phone_number,omitempty"`
	// The state of the [VendorContact](entity:VendorContact).
	Removed *bool `json:"removed,omitempty" url:"removed,omitempty"`
	// The ordinal of the [VendorContact](entity:VendorContact).
	Ordinal int `json:"ordinal" url:"ordinal"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (v *VendorContact) GetExtraProperties() map[string]interface{} {
	return v.extraProperties
}

func (v *VendorContact) UnmarshalJSON(data []byte) error {
	type unmarshaler VendorContact
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = VendorContact(value)

	extraProperties, err := core.ExtractExtraProperties(data, *v)
	if err != nil {
		return err
	}
	v.extraProperties = extraProperties

	v._rawJSON = json.RawMessage(data)
	return nil
}

func (v *VendorContact) String() string {
	if len(v._rawJSON) > 0 {
		if value, err := core.StringifyJSON(v._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

// Published when a [Vendor](entity:Vendor) is created.
type VendorCreatedWebhook struct {
	// The ID of a seller associated with this webhook event.
	MerchantId *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The ID of a target platform account associated with this webhook event, if the event is associated with the platform account.
	AccountId *string `json:"account_id,omitempty" url:"account_id,omitempty"`
	// The ID of a location associated with the webhook event, if the event is associated with the location of the seller.
	LocationId *string `json:"location_id,omitempty" url:"location_id,omitempty"`
	// The type of this webhook event. The value is `"vendor.created".`
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// A unique ID for this webhoook event.
	EventId *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// The RFC 3339-formatted time when the underlying webhook event data object is created.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The data associated with this webhook event.
	Data *VendorCreatedWebhookData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (v *VendorCreatedWebhook) GetExtraProperties() map[string]interface{} {
	return v.extraProperties
}

func (v *VendorCreatedWebhook) UnmarshalJSON(data []byte) error {
	type unmarshaler VendorCreatedWebhook
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = VendorCreatedWebhook(value)

	extraProperties, err := core.ExtractExtraProperties(data, *v)
	if err != nil {
		return err
	}
	v.extraProperties = extraProperties

	v._rawJSON = json.RawMessage(data)
	return nil
}

func (v *VendorCreatedWebhook) String() string {
	if len(v._rawJSON) > 0 {
		if value, err := core.StringifyJSON(v._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

// Defines the `vendor.created` webhook event data structure.
type VendorCreatedWebhookData struct {
	// The type of the event data object. The value is `vendor`
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// The ID of the webhook event data object.
	Id *string `json:"id,omitempty" url:"id,omitempty"`
	// An object containing the created vendor.
	Object *VendorCreatedWebhookObject `json:"object,omitempty" url:"object,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (v *VendorCreatedWebhookData) GetExtraProperties() map[string]interface{} {
	return v.extraProperties
}

func (v *VendorCreatedWebhookData) UnmarshalJSON(data []byte) error {
	type unmarshaler VendorCreatedWebhookData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = VendorCreatedWebhookData(value)

	extraProperties, err := core.ExtractExtraProperties(data, *v)
	if err != nil {
		return err
	}
	v.extraProperties = extraProperties

	v._rawJSON = json.RawMessage(data)
	return nil
}

func (v *VendorCreatedWebhookData) String() string {
	if len(v._rawJSON) > 0 {
		if value, err := core.StringifyJSON(v._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

type VendorCreatedWebhookObject struct {
	// The operation on the vendor that caused the webhook event to be published. The value is `CREATED`.
	// See [Operation](#type-operation) for possible values
	Operation *VendorCreatedWebhookObjectOperation `json:"operation,omitempty" url:"operation,omitempty"`
	// The created vendor as the result of the specified operation.
	Vendor *Vendor `json:"vendor,omitempty" url:"vendor,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (v *VendorCreatedWebhookObject) GetExtraProperties() map[string]interface{} {
	return v.extraProperties
}

func (v *VendorCreatedWebhookObject) UnmarshalJSON(data []byte) error {
	type unmarshaler VendorCreatedWebhookObject
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = VendorCreatedWebhookObject(value)

	extraProperties, err := core.ExtractExtraProperties(data, *v)
	if err != nil {
		return err
	}
	v.extraProperties = extraProperties

	v._rawJSON = json.RawMessage(data)
	return nil
}

func (v *VendorCreatedWebhookObject) String() string {
	if len(v._rawJSON) > 0 {
		if value, err := core.StringifyJSON(v._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

// The operation that can be performed against a vendor to cause the webhook event to be published.
type VendorCreatedWebhookObjectOperation = string

// The status of the [Vendor](entity:Vendor),
// whether a [Vendor](entity:Vendor) is active or inactive.
type VendorStatus string

const (
	VendorStatusDoNotUse VendorStatus = "DO_NOT_USE"
	VendorStatusActive   VendorStatus = "ACTIVE"
	VendorStatusInactive VendorStatus = "INACTIVE"
)

func NewVendorStatusFromString(s string) (VendorStatus, error) {
	switch s {
	case "DO_NOT_USE":
		return VendorStatusDoNotUse, nil
	case "ACTIVE":
		return VendorStatusActive, nil
	case "INACTIVE":
		return VendorStatusInactive, nil
	}
	var t VendorStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (v VendorStatus) Ptr() *VendorStatus {
	return &v
}

// Published when a [Vendor](entity:Vendor) is updated.
type VendorUpdatedWebhook struct {
	// The ID of a seller associated with this webhook event.
	MerchantId *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The ID of a target platform account associated with this webhook event, if the event is associated with the platform account.
	AccountId *string `json:"account_id,omitempty" url:"account_id,omitempty"`
	// The ID of a seller location associated with this webhook event, if the event is associated with the location.
	LocationId *string `json:"location_id,omitempty" url:"location_id,omitempty"`
	// The type of this webhook event. The value is `"vendor.updated".`
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// A unique ID for this webhoook event.
	EventId *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// The RFC 3339-formatted time when the underlying webhook event data object is created.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The data associated with this webhook event.
	Data *VendorUpdatedWebhookData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (v *VendorUpdatedWebhook) GetExtraProperties() map[string]interface{} {
	return v.extraProperties
}

func (v *VendorUpdatedWebhook) UnmarshalJSON(data []byte) error {
	type unmarshaler VendorUpdatedWebhook
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = VendorUpdatedWebhook(value)

	extraProperties, err := core.ExtractExtraProperties(data, *v)
	if err != nil {
		return err
	}
	v.extraProperties = extraProperties

	v._rawJSON = json.RawMessage(data)
	return nil
}

func (v *VendorUpdatedWebhook) String() string {
	if len(v._rawJSON) > 0 {
		if value, err := core.StringifyJSON(v._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

// Defines the `vendor.updated` webhook event data structure.
type VendorUpdatedWebhookData struct {
	// The type of the event data object. The value is `vendor`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// The ID of the event data object.
	Id *string `json:"id,omitempty" url:"id,omitempty"`
	// An object containing updated vendor.
	Object *VendorUpdatedWebhookObject `json:"object,omitempty" url:"object,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (v *VendorUpdatedWebhookData) GetExtraProperties() map[string]interface{} {
	return v.extraProperties
}

func (v *VendorUpdatedWebhookData) UnmarshalJSON(data []byte) error {
	type unmarshaler VendorUpdatedWebhookData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = VendorUpdatedWebhookData(value)

	extraProperties, err := core.ExtractExtraProperties(data, *v)
	if err != nil {
		return err
	}
	v.extraProperties = extraProperties

	v._rawJSON = json.RawMessage(data)
	return nil
}

func (v *VendorUpdatedWebhookData) String() string {
	if len(v._rawJSON) > 0 {
		if value, err := core.StringifyJSON(v._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

type VendorUpdatedWebhookObject struct {
	// The operation on the vendor that caused the webhook event to be published. The value is `UPDATED`.
	// See [Operation](#type-operation) for possible values
	Operation *VendorUpdatedWebhookObjectOperation `json:"operation,omitempty" url:"operation,omitempty"`
	// The updated vendor as the result of the specified operation.
	Vendor *Vendor `json:"vendor,omitempty" url:"vendor,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (v *VendorUpdatedWebhookObject) GetExtraProperties() map[string]interface{} {
	return v.extraProperties
}

func (v *VendorUpdatedWebhookObject) UnmarshalJSON(data []byte) error {
	type unmarshaler VendorUpdatedWebhookObject
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = VendorUpdatedWebhookObject(value)

	extraProperties, err := core.ExtractExtraProperties(data, *v)
	if err != nil {
		return err
	}
	v.extraProperties = extraProperties

	v._rawJSON = json.RawMessage(data)
	return nil
}

func (v *VendorUpdatedWebhookObject) String() string {
	if len(v._rawJSON) > 0 {
		if value, err := core.StringifyJSON(v._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

// The operation that can be performed against a vendor to cause the webhook event to be published.
type VendorUpdatedWebhookObjectOperation = string

// Enumeration of visibility-filter values used to set the ability to view custom attributes or custom attribute definitions.
type VisibilityFilter string

const (
	VisibilityFilterVisibilityFilterDoNotUse VisibilityFilter = "VISIBILITY_FILTER_DO_NOT_USE"
	VisibilityFilterAll                      VisibilityFilter = "ALL"
	VisibilityFilterRead                     VisibilityFilter = "READ"
	VisibilityFilterReadWrite                VisibilityFilter = "READ_WRITE"
)

func NewVisibilityFilterFromString(s string) (VisibilityFilter, error) {
	switch s {
	case "VISIBILITY_FILTER_DO_NOT_USE":
		return VisibilityFilterVisibilityFilterDoNotUse, nil
	case "ALL":
		return VisibilityFilterAll, nil
	case "READ":
		return VisibilityFilterRead, nil
	case "READ_WRITE":
		return VisibilityFilterReadWrite, nil
	}
	var t VisibilityFilter
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (v VisibilityFilter) Ptr() *VisibilityFilter {
	return &v
}

type VoidTransactionRequest struct {
	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (v *VoidTransactionRequest) GetExtraProperties() map[string]interface{} {
	return v.extraProperties
}

func (v *VoidTransactionRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler VoidTransactionRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = VoidTransactionRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *v)
	if err != nil {
		return err
	}
	v.extraProperties = extraProperties

	v._rawJSON = json.RawMessage(data)
	return nil
}

func (v *VoidTransactionRequest) String() string {
	if len(v._rawJSON) > 0 {
		if value, err := core.StringifyJSON(v._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

// Defines the fields that are included in the response body of
// a request to the [VoidTransaction](api-endpoint:Transactions-VoidTransaction) endpoint.
type VoidTransactionResponse struct {
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (v *VoidTransactionResponse) GetExtraProperties() map[string]interface{} {
	return v.extraProperties
}

func (v *VoidTransactionResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler VoidTransactionResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = VoidTransactionResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *v)
	if err != nil {
		return err
	}
	v.extraProperties = extraProperties

	v._rawJSON = json.RawMessage(data)
	return nil
}

func (v *VoidTransactionResponse) String() string {
	if len(v._rawJSON) > 0 {
		if value, err := core.StringifyJSON(v._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

// An object representing a team member's wage information.
type WageSetting struct {
	// The unique ID of the `TeamMember` whom this wage setting describes.
	TeamMemberId *string `json:"team_member_id,omitempty" url:"team_member_id,omitempty"`
	// Required. The ordered list of jobs that the team member is assigned to.
	// The first job assignment is considered the team member's primary job.
	//
	// The minimum length is 1 and the maximum length is 12.
	JobAssignments []*JobAssignment `json:"job_assignments,omitempty" url:"job_assignments,omitempty"`
	// Whether the team member is exempt from the overtime rules of the seller's country.
	IsOvertimeExempt *bool `json:"is_overtime_exempt,omitempty" url:"is_overtime_exempt,omitempty"`
	// Used for resolving concurrency issues. The request fails if the version
	// provided does not match the server version at the time of the request. If not provided,
	// Square executes a blind write, potentially overwriting data from another write. For more information,
	// see [optimistic concurrency](https://developer.squareup.com/docs/working-with-apis/optimistic-concurrency).
	Version *int `json:"version,omitempty" url:"version,omitempty"`
	// The timestamp, in RFC 3339 format, describing when the wage setting object was created.
	// For example, "2018-10-04T04:00:00-07:00" or "2019-02-05T12:00:00Z".
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The timestamp, in RFC 3339 format, describing when the wage setting object was last updated.
	// For example, "2018-10-04T04:00:00-07:00" or "2019-02-05T12:00:00Z".
	UpdatedAt *string `json:"updated_at,omitempty" url:"updated_at,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (w *WageSetting) GetExtraProperties() map[string]interface{} {
	return w.extraProperties
}

func (w *WageSetting) UnmarshalJSON(data []byte) error {
	type unmarshaler WageSetting
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*w = WageSetting(value)

	extraProperties, err := core.ExtractExtraProperties(data, *w)
	if err != nil {
		return err
	}
	w.extraProperties = extraProperties

	w._rawJSON = json.RawMessage(data)
	return nil
}

func (w *WageSetting) String() string {
	if len(w._rawJSON) > 0 {
		if value, err := core.StringifyJSON(w._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(w); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", w)
}

type Webhook struct {
	// The ID of the target merchant associated with the event.
	MerchantId *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The ID of the target platform account associated with the event.
	AccountId *string `json:"account_id,omitempty" url:"account_id,omitempty"`
	// The ID of the location associated with the event.
	LocationId *string `json:"location_id,omitempty" url:"location_id,omitempty"`
	// The type of event this represents.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// A unique ID for the webhook event.
	EventId *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// Timestamp of when the webhook event was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// Data associated with the event.
	Data *WebhookData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (w *Webhook) GetExtraProperties() map[string]interface{} {
	return w.extraProperties
}

func (w *Webhook) UnmarshalJSON(data []byte) error {
	type unmarshaler Webhook
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*w = Webhook(value)

	extraProperties, err := core.ExtractExtraProperties(data, *w)
	if err != nil {
		return err
	}
	w.extraProperties = extraProperties

	w._rawJSON = json.RawMessage(data)
	return nil
}

func (w *Webhook) String() string {
	if len(w._rawJSON) > 0 {
		if value, err := core.StringifyJSON(w._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(w); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", w)
}

type WebhookData struct {
	// Name of the affected object’s type.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// ID of the affected object.
	Id *string `json:"id,omitempty" url:"id,omitempty"`
	// Is true if the affected object was deleted. Otherwise absent.
	Deleted *bool `json:"deleted,omitempty" url:"deleted,omitempty"`
	// An object containing fields and values relevant to the event. Is absent if affected object was deleted.
	Object map[string]interface{} `json:"object,omitempty" url:"object,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (w *WebhookData) GetExtraProperties() map[string]interface{} {
	return w.extraProperties
}

func (w *WebhookData) UnmarshalJSON(data []byte) error {
	type unmarshaler WebhookData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*w = WebhookData(value)

	extraProperties, err := core.ExtractExtraProperties(data, *w)
	if err != nil {
		return err
	}
	w.extraProperties = extraProperties

	w._rawJSON = json.RawMessage(data)
	return nil
}

func (w *WebhookData) String() string {
	if len(w._rawJSON) > 0 {
		if value, err := core.StringifyJSON(w._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(w); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", w)
}

// Represents the details of a webhook subscription, including notification URL,
// event types, and signature key.
type WebhookSubscription struct {
	// A Square-generated unique ID for the subscription.
	Id *string `json:"id,omitempty" url:"id,omitempty"`
	// The name of this subscription.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// Indicates whether the subscription is enabled (`true`) or not (`false`).
	Enabled *bool `json:"enabled,omitempty" url:"enabled,omitempty"`
	// The event types associated with this subscription.
	EventTypes []string `json:"event_types,omitempty" url:"event_types,omitempty"`
	// The URL to which webhooks are sent.
	NotificationUrl *string `json:"notification_url,omitempty" url:"notification_url,omitempty"`
	// The API version of the subscription.
	// This field is optional for `CreateWebhookSubscription`.
	// The value defaults to the API version used by the application.
	ApiVersion *string `json:"api_version,omitempty" url:"api_version,omitempty"`
	// The Square-generated signature key used to validate the origin of the webhook event.
	SignatureKey *string `json:"signature_key,omitempty" url:"signature_key,omitempty"`
	// The timestamp of when the subscription was created, in RFC 3339 format. For example, "2016-09-04T23:59:33.123Z".
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The timestamp of when the subscription was last updated, in RFC 3339 format.
	// For example, "2016-09-04T23:59:33.123Z".
	UpdatedAt *string `json:"updated_at,omitempty" url:"updated_at,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (w *WebhookSubscription) GetExtraProperties() map[string]interface{} {
	return w.extraProperties
}

func (w *WebhookSubscription) UnmarshalJSON(data []byte) error {
	type unmarshaler WebhookSubscription
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*w = WebhookSubscription(value)

	extraProperties, err := core.ExtractExtraProperties(data, *w)
	if err != nil {
		return err
	}
	w.extraProperties = extraProperties

	w._rawJSON = json.RawMessage(data)
	return nil
}

func (w *WebhookSubscription) String() string {
	if len(w._rawJSON) > 0 {
		if value, err := core.StringifyJSON(w._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(w); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", w)
}

// The days of the week.
type Weekday string

const (
	WeekdayUnknownWeekday Weekday = "UNKNOWN_WEEKDAY"
	WeekdayMon            Weekday = "MON"
	WeekdayTue            Weekday = "TUE"
	WeekdayWed            Weekday = "WED"
	WeekdayThu            Weekday = "THU"
	WeekdayFri            Weekday = "FRI"
	WeekdaySat            Weekday = "SAT"
	WeekdaySun            Weekday = "SUN"
)

func NewWeekdayFromString(s string) (Weekday, error) {
	switch s {
	case "UNKNOWN_WEEKDAY":
		return WeekdayUnknownWeekday, nil
	case "MON":
		return WeekdayMon, nil
	case "TUE":
		return WeekdayTue, nil
	case "WED":
		return WeekdayWed, nil
	case "THU":
		return WeekdayThu, nil
	case "FRI":
		return WeekdayFri, nil
	case "SAT":
		return WeekdaySat, nil
	case "SUN":
		return WeekdaySun, nil
	}
	var t Weekday
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (w Weekday) Ptr() *Weekday {
	return &w
}

// Sets the day of the week and hour of the day that a business starts a
// workweek. This is used to calculate overtime pay.
type WorkweekConfig struct {
	// The UUID for this object.
	Id *string `json:"id,omitempty" url:"id,omitempty"`
	// The day of the week on which a business week starts for
	// compensation purposes.
	// See [Weekday](#type-weekday) for possible values
	StartOfWeek Weekday `json:"start_of_week" url:"start_of_week"`
	// The local time at which a business week starts. Represented as a
	// string in `HH:MM` format (`HH:MM:SS` is also accepted, but seconds are
	// truncated).
	StartOfDayLocalTime string `json:"start_of_day_local_time" url:"start_of_day_local_time"`
	// Used for resolving concurrency issues. The request fails if the version
	// provided does not match the server version at the time of the request. If not provided,
	// Square executes a blind write; potentially overwriting data from another
	// write.
	Version *int `json:"version,omitempty" url:"version,omitempty"`
	// A read-only timestamp in RFC 3339 format; presented in UTC.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// A read-only timestamp in RFC 3339 format; presented in UTC.
	UpdatedAt *string `json:"updated_at,omitempty" url:"updated_at,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (w *WorkweekConfig) GetExtraProperties() map[string]interface{} {
	return w.extraProperties
}

func (w *WorkweekConfig) UnmarshalJSON(data []byte) error {
	type unmarshaler WorkweekConfig
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*w = WorkweekConfig(value)

	extraProperties, err := core.ExtractExtraProperties(data, *w)
	if err != nil {
		return err
	}
	w.extraProperties = extraProperties

	w._rawJSON = json.RawMessage(data)
	return nil
}

func (w *WorkweekConfig) String() string {
	if len(w._rawJSON) > 0 {
		if value, err := core.StringifyJSON(w._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(w); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", w)
}
